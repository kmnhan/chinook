<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Documentation for chinook &mdash; chinook 1.0 documentation</title>
      <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
        <script src="_static/jquery.js"></script>
        <script src="_static/underscore.js"></script>
        <script src="_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script src="_static/doctools.js"></script>
        <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="_static/js/theme.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="index.html">
            <img src="_static/chinook_header_logo.png" class="logo" alt="Logo"/>
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="introduction.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="arpes.html">ARPES Simulation</a></li>
<li class="toctree-l1"><a class="reference internal" href="tightbinding.html">Tight Binding</a></li>
<li class="toctree-l1"><a class="reference internal" href="operator.html">Model Diagnostics</a></li>
<li class="toctree-l1"><a class="reference internal" href="slab.html">Slab Calculation</a></li>
<li class="toctree-l1"><a class="reference internal" href="support.html">Support Files</a></li>
<li class="toctree-l1"><a class="reference internal" href="input.html">Input Arguments</a></li>
<li class="toctree-l1"><a class="reference internal" href="tutorial.html">Tutorial</a></li>
<li class="toctree-l1"><a class="reference internal" href="license.html">License</a></li>
<li class="toctree-l1"><a class="reference internal" href="license.html#contact">Contact</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">chinook</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="index.html" class="icon icon-home"></a> &raquo;</li>
      <li>Documentation for chinook</li>
      <li class="wy-breadcrumbs-aside">
            <a href="_sources/code.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <div class="toctree-wrapper compound">
</div>
<section id="documentation-for-chinook">
<h1>Documentation for chinook<a class="headerlink" href="#documentation-for-chinook" title="Permalink to this heading"></a></h1>
<section id="module-adaptive_int">
<span id="adaptive-int"></span><h2>adaptive_int:<a class="headerlink" href="#module-adaptive_int" title="Permalink to this heading"></a></h2>
<dl class="py function">
<dt class="sig sig-object py" id="adaptive_int.general_Bnl_integrand">
<span class="sig-prename descclassname"><span class="pre">adaptive_int.</span></span><span class="sig-name descname"><span class="pre">general_Bnl_integrand</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">func</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">kn</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lp</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#adaptive_int.general_Bnl_integrand" title="Permalink to this definition"></a></dt>
<dd><p>Standard form of executable integrand in the e.r approximation of the matrix element</p>
<p><em>args</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p><strong>func</strong>: executable function of position (float), in units of Angstrom</p></li>
<li><p><strong>kn</strong>: float, norm of the k vector (in inverse Angstrom)</p></li>
<li><p><strong>lp</strong>: int, final state angular momentum quantum number</p></li>
</ul>
</div></blockquote>
<p><em>return</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p>executable function of float (position)</p></li>
</ul>
</div></blockquote>
<p><a href="#id1"><span class="problematic" id="id2">**</span></a><a href="#id3"><span class="problematic" id="id4">*</span></a></p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="adaptive_int.integrate">
<span class="sig-prename descclassname"><span class="pre">adaptive_int.</span></span><span class="sig-name descname"><span class="pre">integrate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">func</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tol</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#adaptive_int.integrate" title="Permalink to this definition"></a></dt>
<dd><p>Evaluate the integral of <strong>func</strong> over the domain covered by <strong>a</strong>, <strong>b</strong>. This 
begins by seeding the evaluation with a maximally coarse approximation
to the integral.</p>
<p><em>args</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p><strong>func</strong>: executable</p></li>
<li><p><strong>a</strong>: float, start of interval</p></li>
<li><p><strong>b</strong>: float, end of interval</p></li>
<li><p><strong>tol</strong>: float, tolerance for convergence</p></li>
</ul>
</div></blockquote>
<p><em>return</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p><strong>Q</strong>: (complex) float, value of the integral</p></li>
</ul>
</div></blockquote>
<p><a href="#id5"><span class="problematic" id="id6">**</span></a><a href="#id7"><span class="problematic" id="id8">*</span></a></p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="adaptive_int.rect">
<span class="sig-prename descclassname"><span class="pre">adaptive_int.</span></span><span class="sig-name descname"><span class="pre">rect</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">func</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#adaptive_int.rect" title="Permalink to this definition"></a></dt>
<dd><p>Approximation to contribution of a finite domain to the integral, 
evaluated as a rough rectangle</p>
<p><em>args</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p><strong>func</strong>: executable to evaluate</p></li>
<li><p><strong>a</strong>: float, start of interval</p></li>
<li><p><strong>b</strong>: float, end of interval</p></li>
</ul>
</div></blockquote>
<p><em>return</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p><strong>recsum</strong>: (complex) float approximated area of the region under</p></li>
</ul>
<p>function between <strong>a</strong> and <strong>b</strong></p>
</div></blockquote>
<p><a href="#id9"><span class="problematic" id="id10">**</span></a><a href="#id11"><span class="problematic" id="id12">*</span></a></p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="adaptive_int.recursion">
<span class="sig-prename descclassname"><span class="pre">adaptive_int.</span></span><span class="sig-name descname"><span class="pre">recursion</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">func</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tol</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">currsum</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#adaptive_int.recursion" title="Permalink to this definition"></a></dt>
<dd><p>Recursive integration algorithm–rect is used to approximate the integral
under each half of the domain, with the domain further divided until
result has converged</p>
<p><em>args</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p><strong>func</strong>: executable</p></li>
<li><p><strong>a</strong>: float, start of interval</p></li>
<li><p><strong>b</strong>: float, end of interval</p></li>
<li><p><strong>tol</strong>: float, tolerance for convergence</p></li>
<li><p><strong>currsum</strong>: (complex) float, current evaluation for the integral</p></li>
</ul>
</div></blockquote>
<p><em>return</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p>recursive call to the function if not converged, otherwise the result as complex (or real) float</p></li>
</ul>
</div></blockquote>
<p><a href="#id13"><span class="problematic" id="id14">**</span></a><a href="#id15"><span class="problematic" id="id16">*</span></a></p>
</dd></dl>

</section>
<section id="module-ARPES_lib">
<span id="arpes-lib"></span><h2>ARPES_lib:<a class="headerlink" href="#module-ARPES_lib" title="Permalink to this heading"></a></h2>
<dl class="py function">
<dt class="sig sig-object py" id="ARPES_lib.G_dic">
<span class="sig-prename descclassname"><span class="pre">ARPES_lib.</span></span><span class="sig-name descname"><span class="pre">G_dic</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ARPES_lib.G_dic" title="Permalink to this definition"></a></dt>
<dd><p>Initialize the gaunt coefficients associated with all possible transitions relevant</p>
<dl>
<dt><em>return</em>:</dt><dd><ul class="simple">
<li><p><strong>Gdict</strong>: dictionary with keys as a string representing (l,l’,m,dm) “ll’mdm” and values complex float.</p></li>
</ul>
<p>All unacceptable transitions set to zero.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="ARPES_lib.Gmat_make">
<span class="sig-prename descclassname"><span class="pre">ARPES_lib.</span></span><span class="sig-name descname"><span class="pre">Gmat_make</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">lm</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Gdictionary</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#ARPES_lib.Gmat_make" title="Permalink to this definition"></a></dt>
<dd><p>Use the dictionary of relevant Gaunt coefficients to generate a small 2x3 array of  
float which carries the relevant Gaunt coefficients for a given initial state.</p>
<dl class="simple">
<dt><em>args</em>:</dt><dd><ul class="simple">
<li><p><strong>lm</strong>: tuple of 2 int, initial state orbital angular momentum and azimuthal angular momentum</p></li>
<li><p><strong>Gdictionary</strong>: pre-calculated dictionary of Gaunt coefficients, with key-values associated with “ll’mdm”</p></li>
</ul>
</dd>
<dt><em>return</em>:</dt><dd><ul class="simple">
<li><p><strong>mats</strong>: numpy array of float 2x3</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="ARPES_lib.all_Y">
<span class="sig-prename descclassname"><span class="pre">ARPES_lib.</span></span><span class="sig-name descname"><span class="pre">all_Y</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">basis</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#ARPES_lib.all_Y" title="Permalink to this definition"></a></dt>
<dd><p>Build L-M argument array input arguments for every combination of l,m in the basis. The idea is for a given k-point to have a single call
to evaluate all spherical harmonics at once. The pointer array orb_point is a list of lists, where for each projection in the basis, the integer
in the list indicates which row (first axis) of the Ylm array should be taken. This allows for very quick access to the l+/-1, m+/-1,0 Ylm evaluation
required.</p>
<dl class="simple">
<dt><em>args</em>:</dt><dd><ul class="simple">
<li><p><strong>basis</strong>: list of orbital objects</p></li>
</ul>
</dd>
<dt><em>return</em>:</dt><dd><ul class="simple">
<li><p><strong>l_args</strong>: numpy array of int, of shape len(<em>lm_inds</em>),3,2, with the latter two indicating the final state orbital angular momentum</p></li>
<li><p><strong>m_args</strong>: numpy array of int, of shape len(<em>lm_inds</em>),3,2, with the latter two indicating the final state azimuthal angular momentum</p></li>
<li><p><strong>g_arr</strong>: numpy array of float, shape len(<em>lm_inds</em>),3,2, providing the related Gaunt coefficients.</p></li>
<li><p><strong>orb_point</strong>: numpy array of int, matching the related sub-array of <em>l_args</em>, <em>m_args</em>, <em>g_arr</em> related to each orbital in basis</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="ARPES_lib.con_ferm">
<span class="sig-prename descclassname"><span class="pre">ARPES_lib.</span></span><span class="sig-name descname"><span class="pre">con_ferm</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ekbt</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#ARPES_lib.con_ferm" title="Permalink to this definition"></a></dt>
<dd><p>Typical values in the relevant domain for execution of the Fermi distribution will
result in an overflow associated with 64-bit float. To circumvent, set fermi-function
to zero when the argument of the exponential in the denominator is too large.</p>
<dl class="simple">
<dt><em>args</em>:</dt><dd><ul class="simple">
<li><p><strong>ekbt</strong>: float, (E-u)/kbT in terms of eV</p></li>
</ul>
</dd>
<dt><em>return</em>:</dt><dd><ul class="simple">
<li><p><strong>fermi</strong>: float, evaluation of Fermi function.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="ARPES_lib.experiment">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">ARPES_lib.</span></span><span class="sig-name descname"><span class="pre">experiment</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">TB</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ARPES_dict</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#ARPES_lib.experiment" title="Permalink to this definition"></a></dt>
<dd><p>The experiment object is at the centre of the ARPES matrix element 
calculation.This object keeps track of the experimental geometry as 
well as a local copy of the tight-binding model and its dependents. 
Such a copy is used to avoid corruption of these objects in the global
space during a given run of the ARPES experiment.</p>
<p><em>args</em>:</p>
<blockquote>
<div><ul>
<li><p><strong>TB</strong>: instance of a tight-binding model object</p></li>
<li><p><strong>ARPES_dict</strong>: dictionary of relevant experimental parameters including</p>
<blockquote>
<div><ul>
<li><p><em>‘hv’</em>: float, photon energy (eV),</p></li>
<li><p><em>‘mfp’</em>: float, mean-free path (Angstrom),</p></li>
<li><p><em>‘resolution’</em>: dictionary for energy and momentum resolution:</p>
<blockquote>
<div><ul class="simple">
<li><p><em>‘dE’</em>: float, energy resolution (FWHM eV),</p></li>
<li><p><em>‘dk’</em>: float, momentum resolution (FWHM 1/Angstrom)</p></li>
</ul>
</div></blockquote>
</li>
<li><p><em>‘T’</em>: float, Temperature of sample (Kelvin)</p></li>
<li><p><em>‘cube’</em>: dictionary momentum and energy domain</p></li>
</ul>
<p>(<em>‘kz’</em> as float, all others ( <em>‘X’</em> , <em>‘Y’</em> , <em>‘E’</em> ) are list
or tuple of floats Xo,Xf,dX)</p>
</div></blockquote>
</li>
</ul>
</div></blockquote>
<p><em>optional args</em>:</p>
<blockquote>
<div><p>In addition to the keys above, <em>ARPES_dict</em> can also be fed the following:</p>
<blockquote>
<div><ul class="simple">
<li><p><em>‘spin’</em>: spin-ARPES measurement, list [+/-1,np.array([a,b,c])]</p></li>
</ul>
<p>with the numpy array indicating the spin-projection 
direction (with respect to) experimental frame.</p>
<ul class="simple">
<li><p><em>‘rad_type’</em>: string, radial wavefunctions, c.f. <em>chinook.rad_int.py</em> for details</p></li>
<li><p><em>‘threads’</em>: int, number of threads on which to calculate the matrix elements.</p></li>
</ul>
<p>Requires very large calculation to see improvement over single core.</p>
<ul class="simple">
<li><p><em>‘slab’</em>: boolean, will truncate the eigenfunctions beyond the penetration depth (specifically 4x penetration depth), default is False</p></li>
<li><p><em>‘angle’</em>: float, rotation of sample about normal emission i.e. z-axis (radian), default is 0.0</p></li>
<li><p><em>‘W’</em>: float, work function (eV), default is 4.0</p></li>
</ul>
</div></blockquote>
</div></blockquote>
<p><a href="#id17"><span class="problematic" id="id18">**</span></a><a href="#id19"><span class="problematic" id="id20">*</span></a></p>
<dl class="py method">
<dt class="sig sig-object py" id="ARPES_lib.experiment.M_compute">
<span class="sig-name descname"><span class="pre">M_compute</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">i</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#ARPES_lib.experiment.M_compute" title="Permalink to this definition"></a></dt>
<dd><p>The core method called during matrix element computation.</p>
<dl class="simple">
<dt><em>args</em>:</dt><dd><ul class="simple">
<li><p><strong>i</strong>: integer, index and energy of state</p></li>
</ul>
</dd>
<dt><em>return</em>:</dt><dd><ul class="simple">
<li><p><strong>Mtmp</strong>: numpy array (2x3) of complex float corresponding to the matrix element
projection for dm = -1,0,1 (columns) and spin down or up (rows) for a given
state in k and energy.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="ARPES_lib.experiment.Mk_wrapper">
<span class="sig-name descname"><span class="pre">Mk_wrapper</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ilist</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#ARPES_lib.experiment.Mk_wrapper" title="Permalink to this definition"></a></dt>
<dd><p>Wrapper function for use in multiprocessing, to run each of the processes
as a serial matrix element calculation over a sublist of state indices.</p>
<dl class="simple">
<dt><em>args</em>:</dt><dd><ul class="simple">
<li><p><strong>ilist</strong>: list of int, all state indices for execution.</p></li>
</ul>
</dd>
<dt><em>return</em>:</dt><dd><ul class="simple">
<li><p><strong>Mk_out</strong>: numpy array of complex float with shape (len(ilist), 2,3)</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="ARPES_lib.experiment.SE_gen">
<span class="sig-name descname"><span class="pre">SE_gen</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ARPES_lib.experiment.SE_gen" title="Permalink to this definition"></a></dt>
<dd><p>Self energy arguments are passed as a list, which supports mixed-datatype.
The first entry in list is a string, indicating the type of self-energy, 
and the remaining entries are the self-energy.</p>
<dl>
<dt><em>args</em>:</dt><dd><ul class="simple">
<li><p><strong>SE_args</strong>: list, first entry can be ‘func’, ‘poly’, ‘constant’, or ‘grid’</p></li>
</ul>
<p>indicating an executable function, polynomial factors, constant, or a grid of values</p>
</dd>
<dt><em>return</em>:</dt><dd><ul class="simple">
<li><p>SE, numpy array of complex float, with either shape of the datacube,</p></li>
</ul>
<p>or as a one dimensional array over energy only.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="ARPES_lib.experiment.T_distribution">
<span class="sig-name descname"><span class="pre">T_distribution</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ARPES_lib.experiment.T_distribution" title="Permalink to this definition"></a></dt>
<dd><p>Compute the Fermi-distribution for a fixed temperature, over the domain of energy of interest</p>
<dl class="simple">
<dt><em>return</em>:</dt><dd><ul class="simple">
<li><p><strong>fermi</strong>: numpy array of float, same length as energy domain array defined by <em>cube[2]</em> attribute.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="ARPES_lib.experiment.datacube">
<span class="sig-name descname"><span class="pre">datacube</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ARPES_dict</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">diagonalize</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#ARPES_lib.experiment.datacube" title="Permalink to this definition"></a></dt>
<dd><p>This function computes the photoemission matrix elements.
Given a kmesh to calculate the photoemission over, the mesh is reshaped to an nx3 array and the Hamiltonian
diagonalized over this set of k points. The matrix elements are then calculated for each 
of these E-k points</p>
<dl>
<dt><em>kwargs</em>:</dt><dd><ul class="simple">
<li><p><strong>ARPES_dict</strong>: can optionally pass a dictionary of experimental parameters, to update those defined</p></li>
</ul>
<p>in the initialization of the <em>experiment</em> object.</p>
</dd>
<dt><em>return</em>:</dt><dd><ul class="simple">
<li><p>boolean, True if function finishes successfully.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="ARPES_lib.experiment.diagonalize">
<span class="sig-name descname"><span class="pre">diagonalize</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">diagonalize</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#ARPES_lib.experiment.diagonalize" title="Permalink to this definition"></a></dt>
<dd><p>Diagonalize the Hamiltonian over the desired range of momentum, reshaping the 
band-energies into a 1-dimensional array. If the user has not selected a energy
grain for calculation, automatically calculate this.</p>
<dl class="simple">
<dt><em>return</em>:</dt><dd><p>None, however <em>experiment</em> attributes <em>X</em>, <em>Y</em>, <em>ph</em>, <em>TB.Kobj</em>, <em>Eb</em>, <em>Ev</em>, <em>cube</em>
are modified.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="ARPES_lib.experiment.gen_all_pol">
<span class="sig-name descname"><span class="pre">gen_all_pol</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ARPES_lib.experiment.gen_all_pol" title="Permalink to this definition"></a></dt>
<dd><p>Rotate polarization vector, as it appears for each angle in the experiment.
Assume that it only rotates with THETA_y (vertical cryostat), and that the polarization
vector defined by the user relates to centre of THETA_x axis. 
Right now only handles zero vertical rotation (just tilt)</p>
<dl>
<dt><em>return</em>:</dt><dd><ul class="simple">
<li><p>numpy array of len(expmt.cube[1]) x 3 complex float, rotated polarization vectors</p></li>
</ul>
<p>expressed in basis of spherical harmonics</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="ARPES_lib.experiment.plot_gui">
<span class="sig-name descname"><span class="pre">plot_gui</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ARPES_lib.experiment.plot_gui" title="Permalink to this definition"></a></dt>
<dd><p>Generate the Tkinter gui for exploring the experimental parameter-space
associated with the present experiment.</p>
<dl>
<dt><em>args</em>:</dt><dd><ul class="simple">
<li><p><strong>ARPES_dict</strong>: dictionary of experimental parameters, c.f. the</p></li>
</ul>
<p><em>__init__</em> function for details.</p>
</dd>
<dt><em>return</em>:</dt><dd><ul class="simple">
<li><p><strong>Tk_win</strong>: Tkinter window.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="ARPES_lib.experiment.plot_intensity_map">
<span class="sig-name descname"><span class="pre">plot_intensity_map</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">plot_map</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">slice_select</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">plot_bands</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ax_img</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">colourmap</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#ARPES_lib.experiment.plot_intensity_map" title="Permalink to this definition"></a></dt>
<dd><p>Plot a slice of the intensity map computed in <em>spectral</em>. The user selects either
an array index along one of the axes, or the fixed value of interest, allowing
either integer, or float selection.</p>
<dl>
<dt><em>args</em>:</dt><dd><ul class="simple">
<li><p><strong>plot_map</strong>: numpy array of shape (self.cube[0],self.cube[1],self.cube[2]) of float</p></li>
<li><p><strong>slice_select</strong>: list of either [int,int] or [str,float], corresponding to</p></li>
</ul>
<p>dimension, index or label, value. The former option takes dimensions 0,1,2 while
the latter can handle ‘x’, ‘kx’, ‘y’, ‘ky’, ‘energy’, ‘w’, or ‘e’, and is not
case-sensitive.</p>
<ul class="simple">
<li><p><strong>plot_bands</strong>: boolean, option to overlay a constant-momentum cut with</p></li>
</ul>
<p>the dispersion calculated from tight-binding</p>
<ul class="simple">
<li><p><strong>ax_img</strong>: matplotlib Axes, for option to plot onto existing Axes</p></li>
<li><p><strong>colourmap</strong>: matplotlib colourmap</p></li>
</ul>
</dd>
</dl>
<p><em>return</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p><strong>ax_img</strong>: matplotlib axis object</p></li>
</ul>
</div></blockquote>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="ARPES_lib.experiment.rot_basis">
<span class="sig-name descname"><span class="pre">rot_basis</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ARPES_lib.experiment.rot_basis" title="Permalink to this definition"></a></dt>
<dd><p>Rotate the basis orbitals and their positions in the lab frame to be consistent with the
experimental geometry</p>
<dl>
<dt><em>return</em>:</dt><dd><ul class="simple">
<li><p>list of orbital objects, representing a rotated version of the original basis if the</p></li>
</ul>
<p>angle is finite. Otherwise, just return the original basis.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="ARPES_lib.experiment.sarpes_projector">
<span class="sig-name descname"><span class="pre">sarpes_projector</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ARPES_lib.experiment.sarpes_projector" title="Permalink to this definition"></a></dt>
<dd><p>For use in spin-resolved ARPES experiments, project the computed
matrix element values onto the desired spin-projection direction.
In the event that the spin projection direction is not along the 
standard out-of-plane quantization axis, we rotate the matrix elements
computed into the desired basis direction.</p>
<dl>
<dt><em>return</em>:</dt><dd><ul class="simple">
<li><p><strong>spin_projected_Mk</strong>: numpy array of complex float with same</p></li>
</ul>
<p>shape as <em>Mk</em></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="ARPES_lib.experiment.serial_Mk">
<span class="sig-name descname"><span class="pre">serial_Mk</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">indices</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#ARPES_lib.experiment.serial_Mk" title="Permalink to this definition"></a></dt>
<dd><p>Run matrix element on a single thread, directly modifies the <em>Mk</em> attribute.</p>
<dl>
<dt><em>args</em>:</dt><dd><ul class="simple">
<li><p><strong>indices</strong>: list of all state indices for execution; restricting states</p></li>
</ul>
<blockquote>
<div><p>in <em>cube_indx</em> to those within the desired window</p>
</div></blockquote>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="ARPES_lib.experiment.smat_gen">
<span class="sig-name descname"><span class="pre">smat_gen</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">svector</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#ARPES_lib.experiment.smat_gen" title="Permalink to this definition"></a></dt>
<dd><p>Define the spin-projection matrix related to a spin-resolved ARPES experiment.</p>
<dl class="simple">
<dt><em>return</em>:</dt><dd><ul class="simple">
<li><p><strong>Smat</strong>: numpy array of 2x2 complex float corresponding to Pauli operator along the desired direction</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="ARPES_lib.experiment.spectral">
<span class="sig-name descname"><span class="pre">spectral</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ARPES_dict</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">slice_select</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">add_map</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">plot_bands</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ax</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">colourmap</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#ARPES_lib.experiment.spectral" title="Permalink to this definition"></a></dt>
<dd><p>Take the matrix elements and build a simulated ARPES spectrum. 
The user has several options here for the self-energy to be used,  c.f. <em>SE_gen()</em> for details.
Gaussian resolution broadening is the last operation performed, to be consistent with the
practical experiment. <em>slice_select</em> instructs the method to also produce a plot of the designated
slice through momentum or energy. If this is done, the function also returns the associated matplotlib.Axes
object for further manipulation of the plot window.</p>
<dl class="simple">
<dt><em>kwargs</em>:</dt><dd><ul class="simple">
<li><p><strong>ARPES_dict</strong>: dictionary, experimental configuration. See <em>experiment.__init__</em> and <em>experiment.update_pars()</em></p></li>
<li><p><strong>slice_select</strong>: tuple, of either (int,int) or (str,float) format. If (int,int), first is axis index (0,1,2 for x,y,E) and the second is the index of the array. More useful typically is (str,float) format, with str as ‘x’, ‘kx’, ‘y’, ‘ky’, ‘E’, ‘w’ and the float the value requested. It will find the index along this direction closest to the request. Note the strings are not case-sensitive.</p></li>
<li><p><strong>add_map</strong>: boolean, add intensity map to list of intensity maps. If true, a list of intensity objects is appended, otherwise, the intensity map is overwritten</p></li>
<li><p><strong>plot_bands</strong>: boolean, plot bandstructure from tight-binding over the intensity map</p></li>
<li><p><strong>ax</strong>: matplotlib Axes, only relevant if <strong>slice_select</strong>, option to pass existing Axes to plot onto</p></li>
</ul>
</dd>
<dt><em>return</em>:</dt><dd><ul class="simple">
<li><p><strong>I</strong>: numpy array of float, raw intensity map.</p></li>
<li><p><strong>Ig</strong>: numpy array of float, resolution-broadened intensity map.</p></li>
<li><p><strong>ax</strong>: matplotlib Axes, for further modifications to plot only if <strong>slice_select</strong> True</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="ARPES_lib.experiment.thread_Mk">
<span class="sig-name descname"><span class="pre">thread_Mk</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">N</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">indices</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#ARPES_lib.experiment.thread_Mk" title="Permalink to this definition"></a></dt>
<dd><p>Run matrix element on <em>N</em> threads using multiprocess functions, directly modifies the <em>Mk</em>
attribute.</p>
<p>NOTE 21/2/2019 – this has not been optimized to show any measureable improvement over serial execution.
May require a more clever way to do this to get a proper speedup.</p>
<dl>
<dt><em>args</em>:</dt><dd><ul class="simple">
<li><p><strong>N</strong>: int, number of threads</p></li>
<li><p><strong>indices</strong>: list of int, all state indices for execution; restricting</p></li>
</ul>
<p>states in cube_indx to those within the desired window.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="ARPES_lib.experiment.truncate_model">
<span class="sig-name descname"><span class="pre">truncate_model</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ARPES_lib.experiment.truncate_model" title="Permalink to this definition"></a></dt>
<dd><p>For slab calculations, the number of basis states becomes a significant memory load,
as well as a time bottleneck. In reality, an ARPES calculation only needs the small
number of basis states near the surface. Then for slab-calculations, we can truncate
the basis and eigenvectors used in the calculation to dramatically improve our
capacity to perform such calculations. We keep all eigenvectors, but retain only the
projection of the basis states within 2*the mean free path of the surface. The 
states associated with this projection are retained, while remainders are not.</p>
<dl>
<dt><em>return</em>:</dt><dd><ul class="simple">
<li><p><strong>tmp_basis</strong>: list, truncated subset of the basis’ orbital objects</p></li>
<li><p><strong>Evec</strong>: numpy array of complex float corresponding to the truncated eigenvector</p></li>
</ul>
<blockquote>
<div><p>array containing only the surface-projected wavefunctions</p>
</div></blockquote>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="ARPES_lib.experiment.update_pars">
<span class="sig-name descname"><span class="pre">update_pars</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ARPES_dict</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">datacube</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#ARPES_lib.experiment.update_pars" title="Permalink to this definition"></a></dt>
<dd><p>Several experimental parameters can be updated without re-calculating 
the ARPES intensity explicitly. Specifically here, we can update 
resolution in both energy and momentum, as well as temperature,
spin-projection, self-energy function, and polarization.</p>
<dl>
<dt><em>args</em>:</dt><dd><ul>
<li><p><strong>ARPES_dict</strong>: dictionary, specifically containing</p>
<blockquote>
<div><ul class="simple">
<li><p><em>‘resolution’</em>: dictionary with ‘E’:float and ‘k’:float</p></li>
<li><p><em>‘T’</em>: float, temperature, a negative value will suppress the Fermi function</p></li>
<li><p><em>‘spin’</em>: list of [int, numpy array of 3 float] indicating projection and spin vector</p></li>
<li><p><em>‘SE’</em>: various types accepted, see <em>SE_gen</em> for details</p></li>
<li><p><em>‘pol’</em>: numpy array of 3 complex float, polarization of light</p></li>
</ul>
</div></blockquote>
</li>
</ul>
</dd>
<dt><em>kwargs</em>:</dt><dd><ul class="simple">
<li><p><strong>datacube</strong>: bool, if updating in <em>spectral</em>, only the above  can be changed. If instead, updating</p></li>
</ul>
<dl class="simple">
<dt>at the start of <em>datacube</em>, can also pass:</dt><dd><ul class="simple">
<li><p><strong>hv</strong>: float, photon energy, eV</p></li>
<li><p><strong>ang</strong>: float, sample orientation around normal, radiants</p></li>
<li><p><strong>rad_type</strong>: string, radial integral type</p></li>
<li><p><strong>rad_args</strong>: various datatype, see <em>radint_lib</em> for details</p></li>
<li><p><strong>kz</strong>: float, out-of-plane momentum, inverse Angstrom</p></li>
<li><p><strong>mfp</strong>: float, mean-free path, Angstrom</p></li>
</ul>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="ARPES_lib.experiment.write_Ik">
<span class="sig-name descname"><span class="pre">write_Ik</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">filename</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mat</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#ARPES_lib.experiment.write_Ik" title="Permalink to this definition"></a></dt>
<dd><p>Function for producing the textfiles associated with a 2 dimensional numpy array of float</p>
<p><em>args</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p><strong>filename</strong>: string indicating destination of file</p></li>
<li><p><strong>mat</strong>: numpy array of float, two dimensional</p></li>
</ul>
</div></blockquote>
<dl class="simple">
<dt><em>return</em>:</dt><dd><ul class="simple">
<li><p>boolean, True</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="ARPES_lib.experiment.write_map">
<span class="sig-name descname"><span class="pre">write_map</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">_map</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">directory</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#ARPES_lib.experiment.write_map" title="Permalink to this definition"></a></dt>
<dd><p>Write the intensity maps to a series of text files in the indicated directory.</p>
<dl class="simple">
<dt><em>args</em>:</dt><dd><ul class="simple">
<li><p><strong>_map</strong>: numpy array of float to write to file</p></li>
<li><p><strong>directory</strong>: string, name of directory + the file-lead name</p></li>
</ul>
</dd>
<dt><em>return</em>:</dt><dd><ul class="simple">
<li><p>boolean, True</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="ARPES_lib.experiment.write_params">
<span class="sig-name descname"><span class="pre">write_params</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">Adict</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">parfile</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#ARPES_lib.experiment.write_params" title="Permalink to this definition"></a></dt>
<dd><p>Generate metadata text file  associated with the saved map.</p>
<dl>
<dt><em>args</em>:</dt><dd><ul class="simple">
<li><p><strong>Adict</strong>: dictionary, ARPES_dict same as in above functions, containing</p></li>
</ul>
<p>relevant experimental parameters for use in saving the metadata associated
with the related calculation.</p>
<ul class="simple">
<li><p><strong>parfile</strong>: string, destination for the metadata</p></li>
</ul>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="ARPES_lib.find_mean_dE">
<span class="sig-prename descclassname"><span class="pre">ARPES_lib.</span></span><span class="sig-name descname"><span class="pre">find_mean_dE</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">Eb</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#ARPES_lib.find_mean_dE" title="Permalink to this definition"></a></dt>
<dd><p>Find the average spacing between adjacent points along the dispersion calculated.</p>
<dl class="simple">
<dt><em>args</em>:</dt><dd><ul class="simple">
<li><p><strong>Eb</strong>: numpy array of float, eigenvalues</p></li>
</ul>
</dd>
<dt><em>return</em>:</dt><dd><ul class="simple">
<li><p><strong>dE_mean</strong>: float, average difference between consecutive eigenvalues.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="ARPES_lib.gen_SE_KK">
<span class="sig-prename descclassname"><span class="pre">ARPES_lib.</span></span><span class="sig-name descname"><span class="pre">gen_SE_KK</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">w</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">SE_args</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#ARPES_lib.gen_SE_KK" title="Permalink to this definition"></a></dt>
<dd><p>The total self-energy is computed using Kramers’ Kronig relations:</p>
<blockquote>
<div><p>The user can pass the self-energy in the form of either a callable function, a list of polynomial coefficients, or as a numpy array with shape Nx2 (with the first
column an array of frequency values, and the second the values of a function). For the latter option, the user is responsible for ensuring that the function goes 
to zero at the tails of the domain. In the former two cases, the ‘cut’ parameter is used to impose an exponential cutoff near the edge of the domain to ensure this 
is the case. In all cases the input imaginary self-energy must be single-signed to ensure it is purely even function. It is forced to be negative in all cases to give
a positive spectral function.
With the input defined, along with the energy range of interest to the calculation, a MUCH larger domain (100x in the maximal extent of the energy region of interest) is defined
wf. This is the domain over which we evaluate the Hilbert transform, which itself is carried out using:
the scipy.signal.hilbert() function. This function acting on an array f: H(f(x)) -&gt; f(x) + i Hf(x). It relies on the FFT performed on the product of the sgn(w) and F(w) functions,
and then IFFT back so that we can use this to extract the real part of the self energy, given only the input.
args:</p>
<blockquote>
<div><p>w – numpy array energy values for the spectral peaks used in the ARPES simulation
SE_args – dictionary containing the ‘imfunc’ key value pair (values being either callable, list of polynomial prefactors (increasing order) or numpy array of energy and Im(SE) values)</p>
<blockquote>
<div><p>– for the first two options, a ‘cut’ key value pair is also required to force the function to vanish at the boundary of the Hilbert transform integration window.</p>
</div></blockquote>
</div></blockquote>
<p>return: self energy as a numpy array of complex float. The indexing matches that of w, the spectral features to be plotted in the matrix element simulation.</p>
</div></blockquote>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="ARPES_lib.pol_2_sph">
<span class="sig-prename descclassname"><span class="pre">ARPES_lib.</span></span><span class="sig-name descname"><span class="pre">pol_2_sph</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">pol</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#ARPES_lib.pol_2_sph" title="Permalink to this definition"></a></dt>
<dd><p>return polarization vector in spherical harmonics – order being Y_11, Y_10, Y_1-1.
If an array of polarization vectors is passed, use the einsum function to broadcast over
all vectors.</p>
<dl class="simple">
<dt><em>args</em>:</dt><dd><ul class="simple">
<li><p><strong>pol</strong>: numpy array of 3 complex float, polarization vector in Cartesian coordinates (x,y,z)</p></li>
</ul>
</dd>
<dt><em>return</em>:</dt><dd><ul class="simple">
<li><p>numpy array of 3 complex float, transformed polarization vector.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="ARPES_lib.poly">
<span class="sig-prename descclassname"><span class="pre">ARPES_lib.</span></span><span class="sig-name descname"><span class="pre">poly</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">input_x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">poly_args</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#ARPES_lib.poly" title="Permalink to this definition"></a></dt>
<dd><p>Recursive polynomial function.</p>
<dl>
<dt><em>args</em>:</dt><dd><ul class="simple">
<li><p><strong>input_x</strong>: float, int or numpy array of numeric type, input value(s) at which to evaluate the polynomial</p></li>
<li><p><strong>poly_args</strong>: list of coefficients, in INCREASING polynomial order i.e. [a_0,a_1,a_2] for y = a_0 + a_1 * x + a_2 <a href="#id21"><span class="problematic" id="id22">*</span></a>x <a href="#id23"><span class="problematic" id="id24">**</span></a>2</p></li>
</ul>
</dd>
<dt><em>return</em>:</dt><dd><ul class="simple">
<li><p>recursive call to <em>poly</em>, if <em>poly_args</em> is reduced to a single value, return explicit evaluation of the function.</p></li>
</ul>
<p>Same datatype as input, with int changed to float if <em>poly_args</em> are float, polynomial evaluated over domain of <em>input_x</em></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="ARPES_lib.progress_bar">
<span class="sig-prename descclassname"><span class="pre">ARPES_lib.</span></span><span class="sig-name descname"><span class="pre">progress_bar</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">N</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Nmax</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#ARPES_lib.progress_bar" title="Permalink to this definition"></a></dt>
<dd><p>Utility function, generate string to print matrix element calculation progress.</p>
<dl class="simple">
<dt><em>args</em>:</dt><dd><ul class="simple">
<li><p><strong>N</strong>: int, number of iterations complete</p></li>
<li><p><strong>Nmax</strong>: int, total number of iterations to complete</p></li>
</ul>
</dd>
<dt><em>return</em>:</dt><dd><ul class="simple">
<li><p><strong>st</strong>: string, progress status</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="ARPES_lib.projection_map">
<span class="sig-prename descclassname"><span class="pre">ARPES_lib.</span></span><span class="sig-name descname"><span class="pre">projection_map</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">basis</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#ARPES_lib.projection_map" title="Permalink to this definition"></a></dt>
<dd><p>In order to improve efficiency, an array of orbital projections is generated, carrying all and each
orbital projection for the elements of the model basis. As these do not in general have the same length,
the second dimension of this array corresponds to the largest of the sets of projections associated with
a given orbital. This will in practice remain a modest number of order 1, since at worst we assume f-orbitals,
in which case the projection can be no larger than 7 long. So output will be at worst len(basis)x7 complex float</p>
<dl class="simple">
<dt><em>args</em>:</dt><dd><ul class="simple">
<li><p><strong>basis</strong>: list of orbital objects</p></li>
</ul>
</dd>
<dt><em>return</em>:</dt><dd><ul class="simple">
<li><p><strong>projarr</strong>: numpy array of complex float</p></li>
</ul>
</dd>
</dl>
</dd></dl>

</section>
<section id="module-atomic_mass">
<span id="atomic-mass"></span><h2>atomic_mass:<a class="headerlink" href="#module-atomic_mass" title="Permalink to this heading"></a></h2>
<dl class="py function">
<dt class="sig sig-object py" id="atomic_mass.get_el_from_number">
<span class="sig-prename descclassname"><span class="pre">atomic_mass.</span></span><span class="sig-name descname"><span class="pre">get_el_from_number</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">N_at</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#atomic_mass.get_el_from_number" title="Permalink to this definition"></a></dt>
<dd><p>Get symbol for element, given the atomic number</p>
<p><em>args</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p><strong>N_at</strong>: int, atomic number</p></li>
</ul>
</div></blockquote>
<p><em>return</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p>string, symbol for element</p></li>
</ul>
</div></blockquote>
<p><a href="#id25"><span class="problematic" id="id26">**</span></a><a href="#id27"><span class="problematic" id="id28">*</span></a></p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="atomic_mass.get_mass_from_number">
<span class="sig-prename descclassname"><span class="pre">atomic_mass.</span></span><span class="sig-name descname"><span class="pre">get_mass_from_number</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">N_at</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#atomic_mass.get_mass_from_number" title="Permalink to this definition"></a></dt>
<dd><p>Pull atomic mass for the indicated atomic number</p>
<p><em>args</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p><strong>N_at</strong>: int, atomic number</p></li>
</ul>
</div></blockquote>
<p><em>return</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p>float, atomic mass, in atomic mass units</p></li>
</ul>
</div></blockquote>
<p><a href="#id29"><span class="problematic" id="id30">**</span></a><a href="#id31"><span class="problematic" id="id32">*</span></a></p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="atomic_mass.get_num_from_el">
<span class="sig-prename descclassname"><span class="pre">atomic_mass.</span></span><span class="sig-name descname"><span class="pre">get_num_from_el</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">el</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#atomic_mass.get_num_from_el" title="Permalink to this definition"></a></dt>
<dd><p>Get atomic number from the symbol for the associated element. Returns 0 for
invalid entry.</p>
<p><em>args</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p><strong>el</strong>: string, symbol for element</p></li>
</ul>
</div></blockquote>
<p><em>return</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p><strong>Z</strong>: int, atomic number.</p></li>
</ul>
</div></blockquote>
</dd></dl>

</section>
<section id="module-build_lib">
<span id="build-lib"></span><h2>build_lib:<a class="headerlink" href="#module-build_lib" title="Permalink to this heading"></a></h2>
<dl class="py function">
<dt class="sig sig-object py" id="build_lib.gen_K">
<span class="sig-prename descclassname"><span class="pre">build_lib.</span></span><span class="sig-name descname"><span class="pre">gen_K</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">Kdic</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#build_lib.gen_K" title="Permalink to this definition"></a></dt>
<dd><p>Generate k-path for TB model to be diagonalized along.</p>
<p><em>args</em>:</p>
<blockquote>
<div><ul>
<li><p><strong>Kdic</strong>: dictionary for generation of kpath with:</p>
<blockquote>
<div><ul class="simple">
<li><p><em>‘type’</em>: string ‘A’ (absolute) or ‘F’ (fractional) units</p></li>
<li><p><em>‘avec’</em>: numpy array of 3x3 float lattice vectors</p></li>
<li><p><em>‘pts’</em>: list of len3 array indicating the high-symmetry points</p></li>
</ul>
<p>along the path of interest</p>
<ul class="simple">
<li><p><em>‘grain’</em>: int, number of points between <em>each</em> element of <em>‘pts’</em></p></li>
</ul>
<p>optional:</p>
<blockquote>
<div><ul class="simple">
<li><p><em>‘labels’</em>:list of strings with same length as <em>‘pts’</em>, giving</p></li>
</ul>
<p>plotting labels for the kpath</p>
</div></blockquote>
</div></blockquote>
</li>
</ul>
</div></blockquote>
<p><em>return</em>:</p>
<blockquote>
<div><p><strong>Kobj</strong>: K-object including necessary attributes to be read by the <strong>TB_model</strong></p>
</div></blockquote>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="build_lib.gen_TB">
<span class="sig-prename descclassname"><span class="pre">build_lib.</span></span><span class="sig-name descname"><span class="pre">gen_TB</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">basis_dict</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">hamiltonian_dict</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Kobj</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">slab_dict</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#build_lib.gen_TB" title="Permalink to this definition"></a></dt>
<dd><p>Build a Tight-Binding Model using the user-input dictionaries</p>
<p><em>args</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p><strong>basis_dict</strong>: dictionary, including the <em>‘bulk’</em> key value pair</p></li>
</ul>
<p>generated by <strong>gen_basis</strong></p>
<ul>
<li><p><strong>hamiltonian_dict</strong>: dictionary,</p>
<blockquote>
<div><ul class="simple">
<li><p><em>‘spin’</em>: same dictionary as passed to <strong>gen_basis</strong></p></li>
<li><p><em>‘type’</em>: string, Hamiltonian type–‘list’ (list of matrix elements),</p></li>
</ul>
<p>‘SK’ (Slater-Koster dictionaries, requires also a ‘V’ and ‘avec’ entry),
‘txt’ (textfile, requires a ‘filename’ key as well)</p>
<ul class="simple">
<li><p><em>‘cutoff’</em>: float, cutoff hopping distance</p></li>
<li><p><em>‘renorm’</em>: optional float, renormalization factor default to 1.0</p></li>
<li><p><em>‘offset’</em>: optional float, offset of chemical potential, default to 0.0</p></li>
<li><p><em>‘tol’</em>: optional float, minimum matrix element tolerance, default to 1e-15</p></li>
</ul>
</div></blockquote>
</li>
<li><p><strong>Kobj</strong>: optional, standard K-object, as generated by <strong>gen_K</strong></p></li>
<li><p><strong>slab_dict</strong>: dictionary for slab generation</p>
<blockquote>
<div><ul class="simple">
<li><p><em>‘avec’</em>: numpy array of 3x3 float, lattice vectors</p></li>
<li><p><em>‘miller’</em>: numpy array of 3 integers, indicating the Miller</p></li>
</ul>
<p>index of the surface normal in units of lattice vectors</p>
<ul class="simple">
<li><p><em>‘fine’</em>: fine adjustment of the slab thickness, tuple of two</p></li>
</ul>
<p>numeric to get desired termination correct (for e.g. inversion symmetry)</p>
<ul class="simple">
<li><p><em>‘thick’</em>: integer approximate number of unit cells in the</p></li>
</ul>
<p>slab (will not be exact, depending on the fine, and termination</p>
<ul class="simple">
<li><p><em>‘vac’</em>: int size of the vacuum buffer – must be larger than</p></li>
</ul>
<p>the largest hopping length to ensure no coupling of slabs</p>
<ul class="simple">
<li><p><em>‘termination’</em>: tuple of 2 integers: atom indices which</p></li>
</ul>
<p>terminate the top and bottom of the slab</p>
</div></blockquote>
</li>
</ul>
</div></blockquote>
<p><em>return</em>:</p>
<blockquote>
<div><p><strong>TB_model</strong>: tight-binding object, as defined in <strong>chinook.TB_lib.py</strong></p>
</div></blockquote>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="build_lib.gen_basis">
<span class="sig-prename descclassname"><span class="pre">build_lib.</span></span><span class="sig-name descname"><span class="pre">gen_basis</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">basis</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#build_lib.gen_basis" title="Permalink to this definition"></a></dt>
<dd><p>Generate a list of orbital objects as the input basis for a tight-binding model.
User passes a basis dictionary, function returns a modified version of this
same dictionary, with the list of orbitals now appended as the <em>‘bulk’</em> entry</p>
<p><em>args</em>:</p>
<blockquote>
<div><ul>
<li><p><strong>basis</strong>–dictionary with keys:</p>
<blockquote>
<div><ul class="simple">
<li><p><em>‘atoms’</em>: list of integer, indices for distinct atoms,</p></li>
<li><p><em>‘Z’</em>: dictionary of integer: <em>‘atom’</em>:element (integer) pairs</p></li>
<li><p><em>‘orbs’</em>: list of lists of string, for each atom containing the</p></li>
</ul>
<p>orbital labels (usually in conventional nlxx format)),</p>
<ul class="simple">
<li><p><em>‘pos’</em>: list of numpy arrays of length 3 float indicating</p></li>
</ul>
<p>positions of the atoms in direct Angstrom units,</p>
<ul>
<li><p>optional keys:</p>
<blockquote>
<div><ul class="simple">
<li><p><em>‘orient’</em>: list, one entry for each atom, indicating a</p></li>
</ul>
<p>local rotation of the indicated atom, various formats accepted; 
for more details, c.f. <strong>chinook.orbital.py</strong></p>
<ul>
<li><p><em>‘spin’</em>: dictionary of spin information:</p>
<blockquote>
<div><ul class="simple">
<li><p><em>‘bool’</em>: boolean, double basis into spinor basis,</p></li>
<li><p><em>‘soc’</em>: boolean, include spin-orbit coupling</p></li>
<li><p><em>‘lam’</em>: dictionary of SOC constants, integer:float</p></li>
</ul>
<p>pairs for atoms in <em>‘atoms’</em> list, and lambda_SOC in eV</p>
</div></blockquote>
</li>
</ul>
</div></blockquote>
</li>
</ul>
</div></blockquote>
</li>
</ul>
</div></blockquote>
<p><em>return</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p><strong>basis</strong> dictionary, modified to include the <strong>bulk</strong> list of orbital</p></li>
</ul>
<p>objects</p>
</div></blockquote>
<p><a href="#id33"><span class="problematic" id="id34">**</span></a><a href="#id35"><span class="problematic" id="id36">*</span></a></p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="build_lib.recur_product">
<span class="sig-prename descclassname"><span class="pre">build_lib.</span></span><span class="sig-name descname"><span class="pre">recur_product</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">elements</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#build_lib.recur_product" title="Permalink to this definition"></a></dt>
<dd><p>Utility function: Recursive evaluation of the product of all elements in a list</p>
<p><em>args</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p><strong>elements</strong>: list of numeric type</p></li>
</ul>
</div></blockquote>
<p><em>return</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p>product of all elements of <strong>elements</strong></p></li>
</ul>
</div></blockquote>
<p><a href="#id37"><span class="problematic" id="id38">**</span></a><a href="#id39"><span class="problematic" id="id40">*</span></a></p>
</dd></dl>

</section>
<section id="module-dos">
<span id="dos-py"></span><h2>dos.py:<a class="headerlink" href="#module-dos" title="Permalink to this heading"></a></h2>
<dl class="py function">
<dt class="sig sig-object py" id="dos.band_contribution">
<span class="sig-prename descclassname"><span class="pre">dos.</span></span><span class="sig-name descname"><span class="pre">band_contribution</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">eigenvals</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">w_domain</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">volume</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dos.band_contribution" title="Permalink to this definition"></a></dt>
<dd><p>Compute the contribution over a single tetrahedron, from a 
single band, to the density of states</p>
<p><em>args</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p><strong>eigenvals</strong>: numpy array of float, energy values at corners</p></li>
<li><p><strong>w_domain</strong>: numpy array of float, energy domain</p></li>
<li><p><strong>volume</strong>: int, number of tetrahedra in the total mesh</p></li>
</ul>
</div></blockquote>
<p><em>return</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p><strong>DOS</strong>: numpy array of float, same length as w_domain</p></li>
</ul>
</div></blockquote>
<p><a href="#id41"><span class="problematic" id="id42">**</span></a><a href="#id43"><span class="problematic" id="id44">*</span></a></p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="dos.def_dE">
<span class="sig-prename descclassname"><span class="pre">dos.</span></span><span class="sig-name descname"><span class="pre">def_dE</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">Eband</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dos.def_dE" title="Permalink to this definition"></a></dt>
<dd><p>If energy broadening is not passed for density-of-states calculation,
compute a reasonable value based on the energy between adjacent energies
in the tight-binding calculation</p>
<p><em>args</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p><strong>Eband</strong>: numpy array of float, indicating band energies</p></li>
</ul>
</div></blockquote>
<p><em>return</em>:</p>
<blockquote>
<div><p><strong>dE</strong>: float, energy broadening, as the smallest average energy spacing
over all bands.</p>
</div></blockquote>
<p><a href="#id45"><span class="problematic" id="id46">**</span></a><a href="#id47"><span class="problematic" id="id48">*</span></a></p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="dos.dos_broad">
<span class="sig-prename descclassname"><span class="pre">dos.</span></span><span class="sig-name descname"><span class="pre">dos_broad</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">TB</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">NK</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">NE</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dE</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">origin</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">array([0.,</span> <span class="pre">0.,</span> <span class="pre">0.])</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dos.dos_broad" title="Permalink to this definition"></a></dt>
<dd><p>Energy-broadened discrete density of states calculation.
The Hamiltonian is diagonalized over the kmesh defined by NK and
states are summed, as energy-broadened Gaussian peaks, rather than
delta functions.</p>
<p><em>args</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p><strong>TB</strong>: tight-binding model object</p></li>
<li><p><strong>NK</strong>: int, or tuple of int, indicating number of k-points</p></li>
</ul>
</div></blockquote>
<p><em>kwargs</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p><strong>NE</strong>: int, number of energy bins for final output</p></li>
<li><p><strong>dE</strong>: float, energy broadening of peaks, eV</p></li>
<li><p><strong>origin</strong>: numpy array of 3 float, indicating the origin of the mesh to be used,</p></li>
</ul>
<p>relevant for example in kz-specific contributions to density of states</p>
</div></blockquote>
<p><em>return</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p><strong>DOS</strong>: numpy array of float, density-of-states in states/eV</p></li>
<li><p><strong>Elin</strong>: numpy array of float, energy domain in eV</p></li>
</ul>
</div></blockquote>
<p><a href="#id49"><span class="problematic" id="id50">**</span></a><a href="#id51"><span class="problematic" id="id52">*</span></a></p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="dos.dos_func">
<span class="sig-prename descclassname"><span class="pre">dos.</span></span><span class="sig-name descname"><span class="pre">dos_func</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">energy</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">epars</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dos.dos_func" title="Permalink to this definition"></a></dt>
<dd><p>Piecewise function for calculation of density of states</p>
<p><em>args</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p><strong>energy</strong>: numpy array of float (energy domain)</p></li>
<li><p><strong>epars</strong>: tuple of parameters: e[0],e[1],e[2],e[3],V_T,V_G being the ranked band energies for the tetrahedron,</p></li>
</ul>
<p>as well as the volume of both the tetrahedron and the Brillouin zone, all float</p>
</div></blockquote>
<p><em>return</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p>numpy array of float giving DOS contribution from this tetrahedron</p></li>
</ul>
</div></blockquote>
<p><a href="#id53"><span class="problematic" id="id54">**</span></a><a href="#id55"><span class="problematic" id="id56">*</span></a></p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="dos.dos_tetra">
<span class="sig-prename descclassname"><span class="pre">dos.</span></span><span class="sig-name descname"><span class="pre">dos_tetra</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">TB</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">NE</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">NK</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dos.dos_tetra" title="Permalink to this definition"></a></dt>
<dd><p>Generate a tetrahedra mesh of k-points which span the BZ with even distribution
Diagonalize over this mesh and then compute the resulting density of states as
prescribed in the above paper. 
The result is plotted, and DOS returned</p>
<p><em>args</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p><strong>TB</strong>: tight-binding model object</p></li>
<li><p><strong>NE</strong>: int, number of energy points</p></li>
<li><p><strong>NK</strong>: int or list of 3 int – number of k-points in mesh</p></li>
</ul>
</div></blockquote>
<p><em>return</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p><strong>Elin</strong>: linear energy array of float, spanning the range of the eigenspectrum</p></li>
<li><p><strong>DOS</strong>: numpy array of float, same length as Elin, density of states</p></li>
</ul>
</div></blockquote>
<p><a href="#id57"><span class="problematic" id="id58">**</span></a><a href="#id59"><span class="problematic" id="id60">*</span></a></p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="dos.error_function">
<span class="sig-prename descclassname"><span class="pre">dos.</span></span><span class="sig-name descname"><span class="pre">error_function</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sigma</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dos.error_function" title="Permalink to this definition"></a></dt>
<dd><p>Integral over the gaussian function, evaluated from -infinity to x, using
the scipy implementation of the error function</p>
<p><em>args</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p><strong>x0</strong>: float, centre of Gaussian, in eV</p></li>
<li><p><strong>x</strong>: numpy array of float, energy domain eV</p></li>
<li><p><strong>sigma</strong>: float, width of Gaussian, in eV</p></li>
</ul>
</div></blockquote>
<p><em>return</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p>analytical form of integral</p></li>
</ul>
</div></blockquote>
<p><a href="#id61"><span class="problematic" id="id62">**</span></a><a href="#id63"><span class="problematic" id="id64">*</span></a></p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="dos.find_EF_broad_dos">
<span class="sig-prename descclassname"><span class="pre">dos.</span></span><span class="sig-name descname"><span class="pre">find_EF_broad_dos</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">TB</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">NK</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">occ</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">NE</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dE</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">origin</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">array([0.,</span> <span class="pre">0.,</span> <span class="pre">0.])</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dos.find_EF_broad_dos" title="Permalink to this definition"></a></dt>
<dd><p>Find the Fermi level of a model Hamiltonian, for a designated electronic
occupation. Note this is evaluated at T=0, so EF is well-defined.</p>
<p><em>args</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p><strong>TB</strong>: tight-binding model object</p></li>
<li><p><strong>NK</strong>: int, or tuple of int, indicating number of k-points</p></li>
<li><p><strong>occ</strong>: float, desired electronic occupation</p></li>
</ul>
</div></blockquote>
<p><em>kwargs</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p><strong>NE</strong>: int, number of energy bins for final output</p></li>
<li><p><strong>dE</strong>: float, energy spacing of bins, in eV</p></li>
<li><p><strong>origin</strong>: numpy array of 3 float, indicating the origin of the mesh to be used,</p></li>
</ul>
<p>relevant for example in kz-specific contributions to density of states</p>
</div></blockquote>
<p><em>return</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p><strong>EF</strong>: float, Fermi level in eV</p></li>
</ul>
</div></blockquote>
<p><a href="#id65"><span class="problematic" id="id66">**</span></a><a href="#id67"><span class="problematic" id="id68">*</span></a></p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="dos.find_EF_tetra_dos">
<span class="sig-prename descclassname"><span class="pre">dos.</span></span><span class="sig-name descname"><span class="pre">find_EF_tetra_dos</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">TB</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">occ</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dE</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">NK</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dos.find_EF_tetra_dos" title="Permalink to this definition"></a></dt>
<dd><p>Use the tetrahedron-integration method to establish the Fermi-level, for a given
electron occupation.</p>
<p><em>args</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p><strong>TB</strong>: instance of tight-binding model object from <em>TB_lib</em></p></li>
<li><p><strong>occ</strong>: float, desired electronic occupation</p></li>
<li><p><strong>dE</strong>: estimate of energy precision desired for evaluation of the</p></li>
</ul>
<p>Fermi-level (in eV)</p>
<ul class="simple">
<li><p><strong>NK</strong>: int or iterable of 3 int, number of k points in mesh.</p></li>
</ul>
</div></blockquote>
<p><em>return</em>:</p>
<blockquote>
<div><p><strong>EF</strong>: float, Fermi Energy for the desired occupation, to within dE of actual
value.</p>
</div></blockquote>
<p><a href="#id69"><span class="problematic" id="id70">**</span></a><a href="#id71"><span class="problematic" id="id72">*</span></a></p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="dos.gaussian">
<span class="sig-prename descclassname"><span class="pre">dos.</span></span><span class="sig-name descname"><span class="pre">gaussian</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sigma</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dos.gaussian" title="Permalink to this definition"></a></dt>
<dd><p>Evaluate a normalized Gaussian function.</p>
<p><em>args</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p><strong>x0</strong>: float, centre of peak, in eV</p></li>
<li><p><strong>x</strong>: numpy array of float, energy domain in eV</p></li>
<li><p><strong>sigma</strong>: float, width of Gaussian, in eV</p></li>
</ul>
</div></blockquote>
<p><em>return</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p>numpy array of float, gaussian evaluated.</p></li>
</ul>
</div></blockquote>
<p><a href="#id73"><span class="problematic" id="id74">**</span></a><a href="#id75"><span class="problematic" id="id76">*</span></a></p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="dos.n_func">
<span class="sig-prename descclassname"><span class="pre">dos.</span></span><span class="sig-name descname"><span class="pre">n_func</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">energy</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">epars</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dos.n_func" title="Permalink to this definition"></a></dt>
<dd><p>Piecewise function for evaluating contribution of tetrahedra to electronic
occupation number</p>
<p><em>args</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p><strong>energy</strong>: numpy array of float, energy domain</p></li>
</ul>
<blockquote>
<div><ul class="simple">
<li><p><strong>epars</strong>: tuple of parameters: e[0],e[1],e[2],e[3],V_T,V_G being the ranked band energies for the tetrahedron,</p></li>
</ul>
</div></blockquote>
<p>as well as the volume of both the tetrahedron and the Brillouin zone, all float</p>
</div></blockquote>
<p><em>return</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p>numpy array of float, same length as <strong>energy</strong>, providing contribution of</p></li>
</ul>
<p>tetrahedra to the occupation function</p>
</div></blockquote>
<p><a href="#id77"><span class="problematic" id="id78">**</span></a><a href="#id79"><span class="problematic" id="id80">*</span></a></p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="dos.n_tetra">
<span class="sig-prename descclassname"><span class="pre">dos.</span></span><span class="sig-name descname"><span class="pre">n_tetra</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">TB</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dE</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">NK</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">plot</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dos.n_tetra" title="Permalink to this definition"></a></dt>
<dd><p>This function, also from the algorithm of Blochl, gives the integrated DOS
at every given energy (so from bottom of bandstructure up to its top. This makes
for very convenient and precise evaluation of the Fermi level, given an electron
number)</p>
<p><em>args</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p><strong>TB</strong>: tight-binding model object</p></li>
<li><p><strong>dE</strong>: float, energy spacing (meV)</p></li>
<li><p><strong>NK</strong>: int, iterable of 3 int. number of k-points in mesh</p></li>
<li><p><strong>plot</strong>: bool, to plot or not to plot the calculated array</p></li>
</ul>
</div></blockquote>
<p><em>return</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p><strong>Elin</strong>: linear energy array of float, spanning the range of the eigenspectrum</p></li>
<li><p><strong>n_elect</strong>: numpy array of float, same length as <strong>Elin</strong>, integrated DOS</p></li>
</ul>
<p>at each energy, i.e. total number of electrons occupied at each energy</p>
</div></blockquote>
<p><a href="#id81"><span class="problematic" id="id82">**</span></a><a href="#id83"><span class="problematic" id="id84">*</span></a></p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="dos.ne_broad_analytical">
<span class="sig-prename descclassname"><span class="pre">dos.</span></span><span class="sig-name descname"><span class="pre">ne_broad_analytical</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">TB</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">NK</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">NE</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dE</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">origin</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">array([0.,</span> <span class="pre">0.,</span> <span class="pre">0.])</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">plot</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dos.ne_broad_analytical" title="Permalink to this definition"></a></dt>
<dd><p>Analytical evaluation of the occupation function. Uses scipy’s errorfunction
executable to evaluate the analytical form of a Gaussian-broadened state’s contribution
to the total occupation, at each energy</p>
<p><em>args</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p><strong>TB</strong>: tight-binding model object</p></li>
<li><p><strong>NK</strong>: int, or tuple of int, indicating number of k-points</p></li>
</ul>
</div></blockquote>
<p><em>kwargs</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p><strong>NE</strong>: int, number of energy bins for final output</p></li>
<li><p><strong>dE</strong>: float, energy spacing of bins, in eV</p></li>
<li><p><strong>origin</strong>: numpy array of 3 float, indicating the origin of the mesh to be used,</p></li>
</ul>
<p>relevant for example in kz-specific contributions to density of states</p>
<ul class="simple">
<li><p><strong>plot</strong>: boolean, default to True, if false, suppress plot output</p></li>
</ul>
</div></blockquote>
<p><em>return</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p><strong>nE</strong>: numpy array of float, occupied states</p></li>
<li><p><strong>Elin</strong>: numpy array of float, energy domain in eV</p></li>
</ul>
</div></blockquote>
<p><a href="#id85"><span class="problematic" id="id86">**</span></a><a href="#id87"><span class="problematic" id="id88">*</span></a></p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="dos.ne_broad_numerical">
<span class="sig-prename descclassname"><span class="pre">dos.</span></span><span class="sig-name descname"><span class="pre">ne_broad_numerical</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">TB</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">NK</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">NE</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dE</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">origin</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">array([0.,</span> <span class="pre">0.,</span> <span class="pre">0.])</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dos.ne_broad_numerical" title="Permalink to this definition"></a></dt>
<dd><p>Occupation function, as a numerical integral over the density of states function.</p>
<p><em>args</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p><strong>TB</strong>: tight-binding model object</p></li>
<li><p><strong>NK</strong>: int, or tuple of int, indicating number of k-points</p></li>
</ul>
</div></blockquote>
<p><em>kwargs</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p><strong>NE</strong>: int, number of energy bins for final output</p></li>
<li><p><strong>dE</strong>: float, energy spacing of bins, in eV</p></li>
<li><p><strong>origin</strong>: numpy array of 3 float, indicating the origin of the mesh to be used,</p></li>
</ul>
<p>relevant for example in kz-specific contributions to density of states</p>
</div></blockquote>
<p><em>return</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p><strong>ne</strong>: numpy array of float, integrated density-of-states at each energy</p></li>
<li><p><strong>Elin</strong>: numpy array of float, energy domain in eV</p></li>
</ul>
</div></blockquote>
<p><a href="#id89"><span class="problematic" id="id90">**</span></a><a href="#id91"><span class="problematic" id="id92">*</span></a></p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="dos.pdos_tetra">
<span class="sig-prename descclassname"><span class="pre">dos.</span></span><span class="sig-name descname"><span class="pre">pdos_tetra</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">TB</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">NE</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">NK</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">proj</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dos.pdos_tetra" title="Permalink to this definition"></a></dt>
<dd><p>Partial density of states calculation. Follows same tetrahedra method, 
weighting the contribution of a given tetrahedra by the average projection
onto the indicated user-defined projection. The average here taken as the sum
over projection at the 4 vertices of the tetrahedra.</p>
<p><em>args</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p><strong>TB</strong>: tight-binding model object</p></li>
<li><p><strong>NE</strong>: int, number of energy bins</p></li>
<li><p><strong>NK</strong>: int, or iterable of 3 int, indicating the number of k-points</p></li>
</ul>
<p>along each of the axes of the Brillouin zone</p>
<ul class="simple">
<li><p><strong>proj</strong>: numpy array of float, 1D or 2D, c.f. <em>proj_mat</em>.</p></li>
</ul>
</div></blockquote>
<p><em>return</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p><strong>Elin</strong>: numpy array of float, with length <strong>NE</strong>, spanning the</p></li>
</ul>
<p>range of the tight-binding bandstructure</p>
<ul class="simple">
<li><p><strong>pDOS</strong>: numpy array of float, len <strong>NE</strong>, projected density of states</p></li>
<li><p><strong>DOS</strong>: numpy array of float, len <strong>NE</strong>, full density of states</p></li>
</ul>
</div></blockquote>
<p><a href="#id93"><span class="problematic" id="id94">**</span></a><a href="#id95"><span class="problematic" id="id96">*</span></a></p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="dos.proj_avg">
<span class="sig-prename descclassname"><span class="pre">dos.</span></span><span class="sig-name descname"><span class="pre">proj_avg</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">eivecs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">proj_matrix</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dos.proj_avg" title="Permalink to this definition"></a></dt>
<dd><p>Calculate the expectation value of the projection operator, for each of the
eigenvectors, at each of the vertices, and then sum over the vertices. We
use <em>numpy.einsum</em> to perform matrix multiplication and contraction.</p>
<p><em>args</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p><strong>eivecs</strong>: numpy array of complex float, 4xNxM, with M number of eigenvectors,</p></li>
</ul>
<p>N basis dimension</p>
<ul class="simple">
<li><p><strong>proj_matrix</strong>: numpy array of complex float, NxN in size</p></li>
</ul>
</div></blockquote>
<p><em>return</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p>numpy array of M float, indicating the average projection over the 4</p></li>
</ul>
<p>corners of the tetrahedron</p>
</div></blockquote>
<p><a href="#id97"><span class="problematic" id="id98">**</span></a><a href="#id99"><span class="problematic" id="id100">*</span></a></p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="dos.proj_mat">
<span class="sig-prename descclassname"><span class="pre">dos.</span></span><span class="sig-name descname"><span class="pre">proj_mat</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">proj</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lenbasis</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dos.proj_mat" title="Permalink to this definition"></a></dt>
<dd><p>Define projection matrix for fast evaluation of the partial density of states
weighting. As the projector here is diagonal, and represents a Hermitian 
matrix, it is by definition a real matrix operator.</p>
<p><em>args</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p><strong>proj</strong>: numpy array, either 1D (indices of projection), or 2D (indices of</p></li>
</ul>
<p>projection and weight of projection)</p>
<ul class="simple">
<li><p><strong>lenbasis</strong>: int, size of the orbital basis</p></li>
</ul>
</div></blockquote>
<p><em>return</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p><strong>projector</strong>: numpy array of float, lenbasis x lenbasis</p></li>
</ul>
</div></blockquote>
<p><a href="#id101"><span class="problematic" id="id102">**</span></a><a href="#id103"><span class="problematic" id="id104">*</span></a></p>
</dd></dl>

</section>
<section id="module-electron_configs">
<span id="electron-configs"></span><h2>electron_configs:<a class="headerlink" href="#module-electron_configs" title="Permalink to this heading"></a></h2>
<dl class="py function">
<dt class="sig sig-object py" id="electron_configs.Slater_exec">
<span class="sig-prename descclassname"><span class="pre">electron_configs.</span></span><span class="sig-name descname"><span class="pre">Slater_exec</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">Z_ind</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">orb</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#electron_configs.Slater_exec" title="Permalink to this definition"></a></dt>
<dd><p>Define an executable Slater-type orbital wavefunction which takes only
the radius as an input argument. In this way, the usser specifies Z 
and the orbital label string, and this generates a lambda function</p>
<p><span class="math notranslate nohighlight">\(R(r) = (\frac{2Z_{e}}{n_{e}})^{n_{e}} \sqrt{\frac{2Z_{e}}{n_{e}\Gamma(2n_{e}+1)}} r^{n_{e}-1} e^{-\frac{Z_{e} r}{n_{e}}}\)</span></p>
<p><em>args</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p><strong>Z_ind</strong>: int, atomic number</p></li>
<li><p><strong>orb</strong>: string, ‘nlxx’ as per standard orbital definitions used</p></li>
</ul>
<p>throughout the library</p>
</div></blockquote>
<p><em>return</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p>executable function of position (in units of Angstrom)</p></li>
</ul>
</div></blockquote>
<p><a href="#id105"><span class="problematic" id="id106">**</span></a><a href="#id107"><span class="problematic" id="id108">*</span></a></p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="electron_configs.Z_eff">
<span class="sig-prename descclassname"><span class="pre">electron_configs.</span></span><span class="sig-name descname"><span class="pre">Z_eff</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">Z_ind</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">orb</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#electron_configs.Z_eff" title="Permalink to this definition"></a></dt>
<dd><p>Compute the effective nuclear charge, following Slater’s rules.</p>
<p><em>args</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p><strong>Z_ind</strong>: int, the atomic number</p></li>
<li><p><strong>orb</strong>: orbital string, written as nl in either fully numeric, or numeric-alpha format</p></li>
</ul>
</div></blockquote>
<p><em>return</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p><strong>result</strong>: float, effective nuclear charge</p></li>
</ul>
</div></blockquote>
<p><a href="#id109"><span class="problematic" id="id110">**</span></a><a href="#id111"><span class="problematic" id="id112">*</span></a></p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="electron_configs.get_con">
<span class="sig-prename descclassname"><span class="pre">electron_configs.</span></span><span class="sig-name descname"><span class="pre">get_con</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">filename</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Z</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#electron_configs.get_con" title="Permalink to this definition"></a></dt>
<dd><p>Get electron configuration for a given element, from electron_configs.txt.
This is configuration to be used in calculation of the Slater wavefunction.</p>
<p><em>args</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p><strong>filename</strong>: string, text-file where the configurations are saved</p></li>
<li><p><strong>Z</strong>: int, atomic number</p></li>
</ul>
</div></blockquote>
<p><em>return</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p>string, electron configuration of neutral atom</p></li>
</ul>
</div></blockquote>
<p><a href="#id113"><span class="problematic" id="id114">**</span></a><a href="#id115"><span class="problematic" id="id116">*</span></a></p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="electron_configs.hydrogenic_exec">
<span class="sig-prename descclassname"><span class="pre">electron_configs.</span></span><span class="sig-name descname"><span class="pre">hydrogenic_exec</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">Z_ind</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">orb</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#electron_configs.hydrogenic_exec" title="Permalink to this definition"></a></dt>
<dd><p>Similar to Slater_exec, we define an executable function for the 
hydrogenic orbital related to the orbital defined with atomic number
<strong>Z_ind</strong> and orbital label ‘nlxx’</p>
<p><em>args</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p><strong>Z_ind</strong>: int, atomic number</p></li>
<li><p><strong>orb</strong>: string, orbital label ‘nlxx’</p></li>
</ul>
</div></blockquote>
<p><em>return</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p>executable function of float</p></li>
</ul>
</div></blockquote>
<p><a href="#id117"><span class="problematic" id="id118">**</span></a><a href="#id119"><span class="problematic" id="id120">*</span></a></p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="electron_configs.shield_split">
<span class="sig-prename descclassname"><span class="pre">electron_configs.</span></span><span class="sig-name descname"><span class="pre">shield_split</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">shield_string</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#electron_configs.shield_split" title="Permalink to this definition"></a></dt>
<dd><p>Parse the electron configuration string, dividing up into the different orbital
shells.</p>
<p><em>args</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p><strong>shield_string</strong>: string, electron configuration</p></li>
</ul>
</div></blockquote>
<p><em>return</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p><strong>parsed_shield</strong>: list of separated orbital components</p></li>
</ul>
</div></blockquote>
<p><a href="#id121"><span class="problematic" id="id122">**</span></a><a href="#id123"><span class="problematic" id="id124">*</span></a></p>
</dd></dl>

</section>
<section id="module-FS_tetra">
<span id="fs-tetra"></span><h2>FS_tetra:<a class="headerlink" href="#module-FS_tetra" title="Permalink to this heading"></a></h2>
<dl class="py function">
<dt class="sig sig-object py" id="FS_tetra.EF_tetra">
<span class="sig-prename descclassname"><span class="pre">FS_tetra.</span></span><span class="sig-name descname"><span class="pre">EF_tetra</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">TB</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">NK</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">EF</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">degen</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">origin</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#FS_tetra.EF_tetra" title="Permalink to this definition"></a></dt>
<dd><p>Generate a tetrahedra mesh of k-points which span the BZ with even distribution
Diagonalize over this mesh and then compute the resulting density of states as
prescribed in the above paper.</p>
<p><em>args</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p><strong>TB</strong>: tight-binding model object</p></li>
<li><p><strong>NK</strong>: int or list,tuple of 3 int indicating number of k-points in mesh</p></li>
<li><p><strong>EF</strong>: float, Fermi energy, or energy of interest</p></li>
</ul>
</div></blockquote>
<p><em>kwargs</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p><strong>degen</strong>: bool, flag for whether the bands are two-fold degenerate, as for</p></li>
</ul>
<p>Kramers degeneracy</p>
<ul class="simple">
<li><p><strong>origin</strong>: numpy array of 3 float,  corresponding to the desired centre of the</p></li>
</ul>
<p>plotted Brillouin zone</p>
</div></blockquote>
<p><em>return</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p><strong>surfaces</strong>: dictionary of dictionaries: Each key-value pair corresponds</p></li>
</ul>
<p>to a different band index. For each case, the value is a dictionary with key-value
pairs:</p>
<blockquote>
<div><ul class="simple">
<li><p><em>‘pts’</em>: numpy array of Nx3 float, the N coordinates of EF crossing</p></li>
<li><p><em>‘tris’</em>: numpy array of Nx3 int, the triangulation of the surface</p></li>
</ul>
</div></blockquote>
</div></blockquote>
<p><a href="#id125"><span class="problematic" id="id126">**</span></a><a href="#id127"><span class="problematic" id="id128">*</span></a></p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="FS_tetra.FS_generate">
<span class="sig-prename descclassname"><span class="pre">FS_tetra.</span></span><span class="sig-name descname"><span class="pre">FS_generate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">TB</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Nk</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">EF</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">degen</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">origin</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ax</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#FS_tetra.FS_generate" title="Permalink to this definition"></a></dt>
<dd><p>Wrapper function for computing Fermi surface triangulation, and then plotting
the result.</p>
<p><em>args</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p><strong>TB</strong>: tight-binding model object</p></li>
<li><p><strong>Nk</strong>: int, or tuple/list of 3 int, number of k-points in Brillouin zone mesh</p></li>
<li><p><strong>EF</strong>: float, Fermi energy, or constant energy level of interest</p></li>
</ul>
</div></blockquote>
<p><em>kwargs</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p><strong>degen</strong>: bool, flag for whether the bands are two-fold degenerate, as for</p></li>
</ul>
<p>Kramers degeneracy</p>
<ul class="simple">
<li><p><strong>origin</strong>: numpy array of 3 float,  corresponding to the desired centre of the</p></li>
</ul>
<p>plotted Brillouin zone</p>
<ul class="simple">
<li><p><strong>ax</strong>: matplotlib Axes, option for plotting onto existing Axes</p></li>
</ul>
</div></blockquote>
<p><em>return</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p><strong>surfaces</strong>: dictionary of dictionaries: Each key-value pair corresponds</p></li>
</ul>
<p>to a different band index. For each case, the value is a dictionary with key-value
pairs:</p>
<blockquote>
<div><ul class="simple">
<li><p><em>‘pts’</em>: numpy array of Nx3 float, the N coordinates of EF crossing</p></li>
<li><p><em>‘tris’</em>: numpy array of Nx3 int, the triangulation of the surface</p></li>
</ul>
</div></blockquote>
<ul class="simple">
<li><p><strong>ax</strong>: matplotlib Axes, for further modification</p></li>
</ul>
</div></blockquote>
<p><a href="#id129"><span class="problematic" id="id130">**</span></a><a href="#id131"><span class="problematic" id="id132">*</span></a></p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="FS_tetra.fermi_surface_2D">
<span class="sig-prename descclassname"><span class="pre">FS_tetra.</span></span><span class="sig-name descname"><span class="pre">fermi_surface_2D</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">TB</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">npts</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">100</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">kfix</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">(2,</span> <span class="pre">0)</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">energy</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">shift</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">array([0,</span> <span class="pre">0,</span> <span class="pre">0])</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">do_plot</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#FS_tetra.fermi_surface_2D" title="Permalink to this definition"></a></dt>
<dd><p>Generate a 2D contour of the Fermi surface, projected into one of the 3 cardinal planes.
User specifies which b-vector to be normal to, and its fixed value. The user also specifies
the ‘Fermi’ energy, and can shift the centre of the plot away from the origin if desired.</p>
<dl class="simple">
<dt><em>args</em>:</dt><dd><ul class="simple">
<li><p><strong>TB</strong>: tight-binding model object</p></li>
<li><p><strong>npts</strong>: int or tuple of 2-int, number of kpoints in grid</p></li>
<li><p><strong>kfix</strong>: tuple of two numeric. First is b-vector index (0-base), second is the fixed value (float)</p></li>
<li><p><strong>energy</strong>: float, Fermi energy</p></li>
<li><p><strong>shift</strong>: numpy array of 3 float, shift vector, in units or b-vectors</p></li>
<li><p><strong>do_plot</strong>: boolean, option to suppress plot and only return the FS contours</p></li>
</ul>
</dd>
<dt><em>returns</em>:</dt><dd><ul class="simple">
<li><p><strong>ax</strong>: if do_plot, then a figure is generated and the axes object returned</p></li>
<li><dl class="simple">
<dt><strong>FS</strong>: if not do_plot, then a dictionary of contours, with keys indicating the associated band index, and</dt><dd><p>values being the arrays of K points is returned</p>
</dd>
</dl>
</li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="FS_tetra.get_kpts">
<span class="sig-prename descclassname"><span class="pre">FS_tetra.</span></span><span class="sig-name descname"><span class="pre">get_kpts</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">TB</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">kfix</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">npts</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">100</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">shift</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">array([0,</span> <span class="pre">0,</span> <span class="pre">0])</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#FS_tetra.get_kpts" title="Permalink to this definition"></a></dt>
<dd><p>Get k-grid for Brillouin zone sampling</p>
<dl class="simple">
<dt><em>args</em>:</dt><dd><ul class="simple">
<li><p><strong>TB</strong>: tight-binding model object</p></li>
<li><p><strong>kfix</strong>: tuple of two numeric. First is b-vector index (0-base), second is the fixed value (float)</p></li>
<li><p><strong>npts</strong>: int or tuple of 2-int, number of kpoints in grid</p></li>
<li><p><strong>shift</strong>: numpy array of 3 float, shift vector, in units or b-vectors</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="FS_tetra.heron">
<span class="sig-prename descclassname"><span class="pre">FS_tetra.</span></span><span class="sig-name descname"><span class="pre">heron</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">vert</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#FS_tetra.heron" title="Permalink to this definition"></a></dt>
<dd><p>Heron’s algorithm for calculation of triangle area, defined by only the vertices</p>
<p><em>args</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p><strong>vert</strong>: numpy array of 3x3 indicating vertices of triangle</p></li>
</ul>
</div></blockquote>
<p><em>return</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p>float, area of triangle</p></li>
</ul>
</div></blockquote>
<p><a href="#id133"><span class="problematic" id="id134">**</span></a><a href="#id135"><span class="problematic" id="id136">*</span></a></p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="FS_tetra.sim_tri">
<span class="sig-prename descclassname"><span class="pre">FS_tetra.</span></span><span class="sig-name descname"><span class="pre">sim_tri</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">vert</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#FS_tetra.sim_tri" title="Permalink to this definition"></a></dt>
<dd><p>Take 4 vertices of a quadrilateral and split into two alternative triangulations of the corners.
Return the vertices of the triangulation which has the more similar areas between the two
triangles decomposed.</p>
<p><em>args</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p><strong>vert</strong>: (4 by 3 numpy array (or list) of float) in some coordinate frame</p></li>
</ul>
</div></blockquote>
<p><em>return</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p><strong>tris[0]</strong> , <strong>tris[1]</strong>: two numpy arrays of size 3 by 3 float containing</p></li>
</ul>
<p>the coordinates of a triangulation</p>
</div></blockquote>
<p><a href="#id137"><span class="problematic" id="id138">**</span></a><a href="#id139"><span class="problematic" id="id140">*</span></a></p>
</dd></dl>

</section>
<section id="module-H_library">
<span id="h-library"></span><h2>H_library:<a class="headerlink" href="#module-H_library" title="Permalink to this heading"></a></h2>
<dl class="py function">
<dt class="sig sig-object py" id="H_library.AFM_order">
<span class="sig-prename descclassname"><span class="pre">H_library.</span></span><span class="sig-name descname"><span class="pre">AFM_order</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">basis</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dS</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">p_up</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">p_dn</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#H_library.AFM_order" title="Permalink to this definition"></a></dt>
<dd><p>Add antiferromagnetism to the tight-binding model, by adding a different on-site energy to 
orbitals of different spin character, on the designated sites.</p>
<p><em>args</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p><strong>basis</strong>: list, orbital objects</p></li>
<li><p><strong>dS</strong>: float, size of spin-splitting (eV)</p></li>
<li><p><strong>p_up</strong>, <strong>p_dn</strong>: numpy array of float indicating the orbital positions</p></li>
</ul>
<p>for the AFM order</p>
</div></blockquote>
<p><em>return</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p><strong>h_AF</strong>: list of matrix elements, as conventionally arranged [[o1,o2,0,0,0,H12],…]</p></li>
</ul>
</div></blockquote>
<p><a href="#id141"><span class="problematic" id="id142">**</span></a><a href="#id143"><span class="problematic" id="id144">*</span></a></p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="H_library.FM_order">
<span class="sig-prename descclassname"><span class="pre">H_library.</span></span><span class="sig-name descname"><span class="pre">FM_order</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">basis</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dS</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#H_library.FM_order" title="Permalink to this definition"></a></dt>
<dd><p>Add ferromagnetism to the system. Take dS to assume that the splitting puts 
spin-up lower in energy by dS,and viceversa for spin-down. This directly
modifies the <em>TB_model</em>’s <strong>mat_els</strong> attribute</p>
<p><em>args</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p><strong>basis</strong>: list, of orbital objects in basis</p></li>
<li><p><strong>dS</strong>: float, energy of the spin splitting (eV)</p></li>
</ul>
</div></blockquote>
<p><em>return</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p>list of matrix elements [[o1,o2,0,0,0,H12],…]</p></li>
</ul>
</div></blockquote>
<p><a href="#id145"><span class="problematic" id="id146">**</span></a><a href="#id147"><span class="problematic" id="id148">*</span></a></p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="H_library.Lm">
<span class="sig-prename descclassname"><span class="pre">H_library.</span></span><span class="sig-name descname"><span class="pre">Lm</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">l</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#H_library.Lm" title="Permalink to this definition"></a></dt>
<dd><p>L- operator in the l,m_l basis, organized with 
(0,0) = <a href="#id149"><span class="problematic" id="id150">|</span></a>l,l&gt;… (2l,2l) = <a href="#id151"><span class="problematic" id="id152">|</span></a>l,-l&gt;</p>
<p>The nonzero elements are on the upper diagonal</p>
<p><em>arg</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p><strong>l</strong>: int orbital angular momentum</p></li>
</ul>
</div></blockquote>
<p><em>return</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p><strong>M</strong>: numpy array (2l+1,2l+1) of real float</p></li>
</ul>
</div></blockquote>
<p><a href="#id153"><span class="problematic" id="id154">**</span></a><a href="#id155"><span class="problematic" id="id156">*</span></a></p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="H_library.Lp">
<span class="sig-prename descclassname"><span class="pre">H_library.</span></span><span class="sig-name descname"><span class="pre">Lp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">l</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#H_library.Lp" title="Permalink to this definition"></a></dt>
<dd><p>L+ operator in the <span class="math notranslate nohighlight">\(l\)</span>, <span class="math notranslate nohighlight">\(m_l\)</span> basis, organized with 
(0,0) = <a href="#id157"><span class="problematic" id="id158">|</span></a>l,l&gt;… (2l,2l) = <a href="#id159"><span class="problematic" id="id160">|</span></a>l,-l&gt;
The nonzero elements are on the upper diagonal</p>
<p><em>arg</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p><strong>l</strong>: int orbital angular momentum</p></li>
</ul>
</div></blockquote>
<p><em>return</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p><strong>M</strong>: numpy array (2l+1,2l+1) of real float</p></li>
</ul>
</div></blockquote>
<p><a href="#id161"><span class="problematic" id="id162">**</span></a><a href="#id163"><span class="problematic" id="id164">*</span></a></p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="H_library.Lz">
<span class="sig-prename descclassname"><span class="pre">H_library.</span></span><span class="sig-name descname"><span class="pre">Lz</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">l</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#H_library.Lz" title="Permalink to this definition"></a></dt>
<dd><p>Lz operator in the l,:math:<cite>m_l</cite> basis</p>
<p><em>arg</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p><strong>l</strong>: int orbital angular momentum</p></li>
</ul>
</div></blockquote>
<p><em>return</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p>numpy array (2*l+1,2*l+1)</p></li>
</ul>
</div></blockquote>
<p><a href="#id165"><span class="problematic" id="id166">**</span></a><a href="#id167"><span class="problematic" id="id168">*</span></a></p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="H_library.SO">
<span class="sig-prename descclassname"><span class="pre">H_library.</span></span><span class="sig-name descname"><span class="pre">SO</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">basis</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#H_library.SO" title="Permalink to this definition"></a></dt>
<dd><p>Generate L.S  matrix-elements for a given basis. 
This is generic to all l, except the normal_order, which is defined here up to 
and including the f electrons.
Otherwise, this method is generic to any orbital angular momentum.</p>
<p>In the factors dictionary defined here indicates the weight of the 
different <span class="math notranslate nohighlight">\(L_iS_i\)</span> terms. The keys are tuples of (L+/-/z,S+/-/z)
in a bit of a cryptic way: for L, (0,1,2) -&gt;(-1,0,1) and
for S, (-1,0,1) = S1-S2 with S1,2 = +/- 1 here</p>
<p>L+,L-,Lz matrices are defined for each l shell in the basis, 
transformed into the basis of the tight-binding model.
The nonzero terms will then just be used along with the spin and
weighted by the factor value, and slotted into a len(<strong>basis</strong>)xlen(<strong>basis</strong>) matrix <strong>HSO</strong></p>
<p><em>args</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p><strong>basis</strong>: list of orbital objects</p></li>
</ul>
</div></blockquote>
<p><em>return</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p><strong>HSO</strong>: list of matrix elements in standard format [o1,o2,0,0,0,H12]</p></li>
</ul>
</div></blockquote>
<p><a href="#id169"><span class="problematic" id="id170">**</span></a><a href="#id171"><span class="problematic" id="id172">*</span></a></p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="H_library.Vlist_gen">
<span class="sig-prename descclassname"><span class="pre">H_library.</span></span><span class="sig-name descname"><span class="pre">Vlist_gen</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">V</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pair</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#H_library.Vlist_gen" title="Permalink to this definition"></a></dt>
<dd><p>Select the relevant hopping matrix elements to be used in defining the value
of the Slater-Koster matrix elements for a given pair of orbitals. Handles situation where
insufficient parameters have been passed to system.</p>
<p><em>args</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p><strong>V</strong>: dictionary of Slater-Koster hopping terms</p></li>
<li><p><strong>pair</strong>: tuple of int defining the orbitals to be paired, (a1,a2,n1,n2,l1,l2)</p></li>
</ul>
</div></blockquote>
<p><em>return</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p><strong>Vvals</strong>: numpy array of Vllx related to a given pairing, e.g. for s-p np.array([Vsps,Vspp])</p></li>
</ul>
</div></blockquote>
<p><a href="#id173"><span class="problematic" id="id174">**</span></a><a href="#id175"><span class="problematic" id="id176">*</span></a></p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="H_library.cluster_init">
<span class="sig-prename descclassname"><span class="pre">H_library.</span></span><span class="sig-name descname"><span class="pre">cluster_init</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">Vdict</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cutoff</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">avec</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#H_library.cluster_init" title="Permalink to this definition"></a></dt>
<dd><p>Generate a cluster of neighbouring lattice points to use
in defining the hopping paths–ensuring that it extends
sufficiently far enough to capture even the largest hopping vectors.
Also reforms the SK dictionary and cutoff lengths to be in list format.
Returns an array of lattice points which go safely to the edge of the cutoff range.</p>
<p><em>args</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p><strong>Vdict</strong>: dictionary, or list of dictionaries of Slater Koster matrix elements</p></li>
<li><p><strong>cutoff</strong>: float, or list of float</p></li>
<li><p><strong>avec</strong>: numpy array of 3x3 float</p></li>
</ul>
</div></blockquote>
<p><em>return</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p><strong>Vdict</strong>: list of length 1 if a single dictionary passed, else unmodified</p></li>
<li><p><strong>cutoff</strong>: numpy array, append 0 to the beginning of the cutoff list,</p></li>
</ul>
<p>else leave it alone.</p>
<ul class="simple">
<li><p><strong>pts</strong>: numpy array of lattice vector indices for a region of lattice points around</p></li>
</ul>
<p>the origin.</p>
</div></blockquote>
<p><a href="#id177"><span class="problematic" id="id178">**</span></a><a href="#id179"><span class="problematic" id="id180">*</span></a></p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="H_library.index_ordering">
<span class="sig-prename descclassname"><span class="pre">H_library.</span></span><span class="sig-name descname"><span class="pre">index_ordering</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">basis</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#H_library.index_ordering" title="Permalink to this definition"></a></dt>
<dd><p>We use an universal ordering convention for defining the Slater-Koster matrices
which may (and most likely will) not match the ordering chosen by the user.
To account for this, we define a dictionary which gives the ordering, relative 
to the normal order convention defined here, associated with a given a-n-l shell
at each site in the lattice basis.</p>
<p><em>args</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p><strong>basis</strong>: list of orbital objects</p></li>
</ul>
</div></blockquote>
<p><em>return</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p><strong>indexing</strong>: dictionary of key-value pairs (a,n,l,x,y,z):numpy.array([…])</p></li>
</ul>
</div></blockquote>
<p><a href="#id181"><span class="problematic" id="id182">**</span></a><a href="#id183"><span class="problematic" id="id184">*</span></a></p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="H_library.mat_els">
<span class="sig-prename descclassname"><span class="pre">H_library.</span></span><span class="sig-name descname"><span class="pre">mat_els</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">Rij</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">SKmat</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tol</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">i1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">i2</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#H_library.mat_els" title="Permalink to this definition"></a></dt>
<dd><p>Extract the pertinent, and non-zero elements of the Slater-Koster matrix
and transform to the conventional form of Hamiltonian list entries
(o1,o2,Rij0,Rij1,Rij2,H12(Rij))</p>
<p><em>args</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p><strong>Rij</strong>: numpy array of 3 float, relevant connecting vector</p></li>
<li><p><strong>SKmat</strong>: numpy array of float, matrix of hopping elements</p></li>
</ul>
<p>for the coupling of two orbital shells</p>
<ul class="simple">
<li><p><strong>tol</strong>: float, minimum hopping included in model</p></li>
<li><p><strong>i1</strong>, <strong>i2</strong>: int,int, proper index ordering for the relevant</p></li>
</ul>
<p>instance of the orbital shells involved in hopping</p>
</div></blockquote>
<p><em>return</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p><strong>out</strong>: list of Hamiltonian matrix elements, extracted from the</p></li>
</ul>
<p>ordered SKmat, in form [[o1,o2,x12,y12,z12,H12],…]</p>
</div></blockquote>
<p><a href="#id185"><span class="problematic" id="id186">**</span></a><a href="#id187"><span class="problematic" id="id188">*</span></a></p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="H_library.mirror_SK">
<span class="sig-prename descclassname"><span class="pre">H_library.</span></span><span class="sig-name descname"><span class="pre">mirror_SK</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">SK_in</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#H_library.mirror_SK" title="Permalink to this definition"></a></dt>
<dd><p>Generate a list of values which is the input appended with its mirror 
reflection. The mirror boundary condition suppresses the duplicate of the
last value. e.g. [0,1,2,3,4] –&gt; [0,1,2,3,4,3,2,1,0], 
[‘r’,’a’,’c’,’e’,’c’,’a’,’r’] –&gt; [‘r’,’a’,’c’,’e’,’c’,’a’,’r’,’a’,’c’,’e’,’c’,’a’,’r’]
Intended here to take an array of Slater-Koster hopping terms and reflect about 
its last entry i.e. [Vsps,Vspp] -&gt; [Vsps,Vspp,Vsps]</p>
<p><em>args</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p><strong>SK_in</strong>: iterable, of arbitrary length and data-type</p></li>
</ul>
</div></blockquote>
<p><em>return</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p>list of values with same data-type as input</p></li>
</ul>
</div></blockquote>
<p><a href="#id189"><span class="problematic" id="id190">**</span></a><a href="#id191"><span class="problematic" id="id192">*</span></a></p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="H_library.on_site">
<span class="sig-prename descclassname"><span class="pre">H_library.</span></span><span class="sig-name descname"><span class="pre">on_site</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">basis</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">V</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">offset</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#H_library.on_site" title="Permalink to this definition"></a></dt>
<dd><p>On-site matrix element calculation. Try both anl and alabel formats,
if neither is defined, default the onsite energy to 0.0 eV</p>
<p><em>args</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p><strong>basis</strong>: list of orbitals defining the tight-binding basis</p></li>
<li><p><strong>V</strong>: dictionary, Slater Koster terms</p></li>
<li><p><strong>offset</strong>: float, EF shift</p></li>
</ul>
</div></blockquote>
<p><em>return</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p><strong>Ho</strong>: list of Hamiltonian matrix elements</p></li>
</ul>
</div></blockquote>
<p><a href="#id193"><span class="problematic" id="id194">**</span></a><a href="#id195"><span class="problematic" id="id196">*</span></a></p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="H_library.region">
<span class="sig-prename descclassname"><span class="pre">H_library.</span></span><span class="sig-name descname"><span class="pre">region</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">num</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#H_library.region" title="Permalink to this definition"></a></dt>
<dd><p>Generate a symmetric grid of points in number of lattice vectors.</p>
<p><em>args</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p><strong>num</strong>: int, grid will have size 2*num+1 in each direction</p></li>
</ul>
</div></blockquote>
<p><em>return</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p>numpy array of size ((2*num+1)**3,3) with centre value of first entry</p></li>
</ul>
<p>of (-num,-num,-num),…,(0,0,0),…,(num,num,num)</p>
</div></blockquote>
<p><a href="#id197"><span class="problematic" id="id198">**</span></a><a href="#id199"><span class="problematic" id="id200">*</span></a></p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="H_library.sk_build">
<span class="sig-prename descclassname"><span class="pre">H_library.</span></span><span class="sig-name descname"><span class="pre">sk_build</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">avec</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">basis</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Vdict</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cutoff</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tol</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">renorm</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">offset</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#H_library.sk_build" title="Permalink to this definition"></a></dt>
<dd><p>Build SK model from using D-matrices, rather than a list of SK terms from table.
This can handle orbitals of arbitrary orbital angular momentum in principal, 
but right now implemented for up to and including f-electrons. 
NOTE: f-hoppings require thorough testing</p>
<p><em>args</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p><strong>avec</strong>: numpy array 3x3 float, lattice vectors</p></li>
<li><p><strong>basis</strong>: list of orbital objects</p></li>
<li><p><strong>Vdict</strong>: dictionary, or list of dictionaries, of Slater-Koster integrals/ on-site energies</p></li>
<li><p><strong>cutoff</strong>: float or list of float, indicating range where Vdict is applicable</p></li>
<li><p><strong>tol</strong>: float, threshold value below which hoppings are neglected</p></li>
<li><p><strong>offset</strong>: float, offset for Fermi level</p></li>
</ul>
</div></blockquote>
<p><em>return</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p><strong>H_raw</strong>: list of Hamiltonian matrix elements, in form [o1,o2,x12,y12,z12,t12]</p></li>
</ul>
</div></blockquote>
<p><a href="#id201"><span class="problematic" id="id202">**</span></a><a href="#id203"><span class="problematic" id="id204">*</span></a></p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="H_library.spin_double">
<span class="sig-prename descclassname"><span class="pre">H_library.</span></span><span class="sig-name descname"><span class="pre">spin_double</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">H</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lb</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#H_library.spin_double" title="Permalink to this definition"></a></dt>
<dd><p>Duplicate the kinetic Hamiltonian terms to extend over the spin-duplicated 
orbitals, which are by construction in same order and appended to end of the
original basis.</p>
<p><em>args</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p><strong>H</strong>: list, Hamiltonian matrix elements [[o1,o2,x,y,z,H12],…]</p></li>
<li><p><strong>lb</strong>: int, length of basis before spin duplication</p></li>
</ul>
</div></blockquote>
<p><em>return</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p><strong>h2</strong> modified copy of <strong>H</strong>, filled with kinetic terms for both</p></li>
</ul>
<p>spin species</p>
</div></blockquote>
<p><a href="#id205"><span class="problematic" id="id206">**</span></a><a href="#id207"><span class="problematic" id="id208">*</span></a></p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="H_library.txt_build">
<span class="sig-prename descclassname"><span class="pre">H_library.</span></span><span class="sig-name descname"><span class="pre">txt_build</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">filename</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cutoff</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">renorm</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">offset</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tol</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Nonsite</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#H_library.txt_build" title="Permalink to this definition"></a></dt>
<dd><p>Build Hamiltonian from textfile, input is of form
o1,o2,x12,y12,z12,t12, output in form [o1,o2,x12,y12,z12,t12]. 
To be explicit, each row of the textfile is used to generate a
k-space Hamiltonian matrix element of the form:</p>
<div class="math notranslate nohighlight">
\[H_{1,2}(k) = t_{1,2} e^{i (k_x x_{1,2} + k_y y_{1,2} + k_z z_{1,2})}\]</div>
<p><em>args</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p><strong>filename</strong>: string, name of file</p></li>
<li><p><strong>cutoff</strong>: float, maximum distance of hopping allowed, Angstrom</p></li>
<li><p><strong>renorm</strong>: float, renormalization of the bandstructure</p></li>
<li><p><strong>offset</strong>: float, energy offset of chemical potential, electron volts</p></li>
<li><p><strong>tol</strong>: float, minimum Hamiltonian matrix element amplitude</p></li>
<li><p><strong>Nonsite</strong>: int, number of basis states, use to apply <strong>offset</strong></p></li>
</ul>
</div></blockquote>
<p><em>return</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p><strong>Hlist</strong>: the list of Hamiltonian matrix elements</p></li>
</ul>
</div></blockquote>
<p><a href="#id209"><span class="problematic" id="id210">**</span></a><a href="#id211"><span class="problematic" id="id212">*</span></a></p>
</dd></dl>

</section>
<section id="module-intensity_map">
<span id="intensity-map"></span><h2>intensity_map:<a class="headerlink" href="#module-intensity_map" title="Permalink to this heading"></a></h2>
<dl class="py class">
<dt class="sig sig-object py" id="intensity_map.intensity_map">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">intensity_map.</span></span><span class="sig-name descname"><span class="pre">intensity_map</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">index</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Imat</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cube</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">kz</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">T</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">hv</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pol</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dE</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dk</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">self_energy</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">spin</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rot</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">notes</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#intensity_map.intensity_map" title="Permalink to this definition"></a></dt>
<dd><p>Class for organization and saving of data, as well as metadata related to
a specific ARPES calculation.</p>
<dl class="py method">
<dt class="sig sig-object py" id="intensity_map.intensity_map.copy">
<span class="sig-name descname"><span class="pre">copy</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#intensity_map.intensity_map.copy" title="Permalink to this definition"></a></dt>
<dd><p>Copy-by-value of the intensity map object.</p>
<p><em>return</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p><em>intensity_map</em> object with identical attributes to self.</p></li>
</ul>
</div></blockquote>
<p><a href="#id213"><span class="problematic" id="id214">**</span></a><a href="#id215"><span class="problematic" id="id216">*</span></a></p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="intensity_map.intensity_map.save_map">
<span class="sig-name descname"><span class="pre">save_map</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">directory</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#intensity_map.intensity_map.save_map" title="Permalink to this definition"></a></dt>
<dd><p>Save the intensity map: if 2D, just a single file, if 3D, each constant-energy
slice is saved separately. Saved as .txt file</p>
<p><em>args</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p><strong>directory</strong>: string, directory for saving intensity map to</p></li>
</ul>
</div></blockquote>
<p><em>return</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p>boolean</p></li>
</ul>
</div></blockquote>
<p><a href="#id217"><span class="problematic" id="id218">**</span></a><a href="#id219"><span class="problematic" id="id220">*</span></a></p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="intensity_map.intensity_map.write_2D_Imat">
<span class="sig-name descname"><span class="pre">write_2D_Imat</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">filename</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">index</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#intensity_map.intensity_map.write_2D_Imat" title="Permalink to this definition"></a></dt>
<dd><p>Sub-function for producing the textfiles associated with a 2dimensional numpy array of float</p>
<p><em>args</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p><strong>filename</strong>: string, indicating destination of file</p></li>
<li><p><strong>index</strong>: int, energy index of map to save, if -1, then just a 2D map, and save the whole</p></li>
</ul>
<p>thing</p>
</div></blockquote>
<p><em>return</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p>boolean</p></li>
</ul>
</div></blockquote>
<p><a href="#id221"><span class="problematic" id="id222">**</span></a><a href="#id223"><span class="problematic" id="id224">*</span></a></p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="intensity_map.intensity_map.write_meta">
<span class="sig-name descname"><span class="pre">write_meta</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">destination</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#intensity_map.intensity_map.write_meta" title="Permalink to this definition"></a></dt>
<dd><p>Write meta-data file for ARPES intensity calculation.</p>
<p><em>args</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p><strong>destination</strong>: string, file-lead</p></li>
</ul>
</div></blockquote>
<p><em>return</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p>boolean</p></li>
</ul>
</div></blockquote>
<p><a href="#id225"><span class="problematic" id="id226">**</span></a><a href="#id227"><span class="problematic" id="id228">*</span></a></p>
</dd></dl>

</dd></dl>

</section>
<section id="module-klib">
<span id="klib"></span><h2>klib:<a class="headerlink" href="#module-klib" title="Permalink to this heading"></a></h2>
<dl class="py function">
<dt class="sig sig-object py" id="klib.b_zone">
<span class="sig-prename descclassname"><span class="pre">klib.</span></span><span class="sig-name descname"><span class="pre">b_zone</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a_vec</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">N</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">show</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#klib.b_zone" title="Permalink to this definition"></a></dt>
<dd><p>Generate a mesh of points over the Brillouin zone. 
Each of the cardinal axes are divided by the same number of points 
(so points are not necessarily evenly spaced along each axis).</p>
<dl class="simple">
<dt><em>args</em>:</dt><dd><ul class="simple">
<li><p><strong>a_vec</strong>: numpy array of size 3x3 float</p></li>
<li><p><strong>N</strong>: int mesh density</p></li>
</ul>
</dd>
<dt><em>kwargs</em>:     </dt><dd><ul class="simple">
<li><p><strong>show</strong>: boolean for optional plotting of the mesh points</p></li>
</ul>
</dd>
<dt><em>return</em>:</dt><dd><ul class="simple">
<li><p><strong>m_pts</strong>: numpy array of mesh points (float), shape (len(m_pts),3)</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="klib.bvectors">
<span class="sig-prename descclassname"><span class="pre">klib.</span></span><span class="sig-name descname"><span class="pre">bvectors</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a_vec</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#klib.bvectors" title="Permalink to this definition"></a></dt>
<dd><p>Define the reciprocal lattice vectors corresponding to the direct lattice 
in real space</p>
<dl class="simple">
<dt><em>args</em>:</dt><dd><ul class="simple">
<li><p><strong>a_vec</strong>: numpy array of 3x3 float, lattice vectors</p></li>
</ul>
</dd>
<dt><em>return</em>:</dt><dd><ul class="simple">
<li><p><strong>b_vec</strong>: numpy array of 3x3 float, reciprocal lattice vectors</p></li>
</ul>
</dd>
</dl>
<p><a href="#id229"><span class="problematic" id="id230">**</span></a><a href="#id231"><span class="problematic" id="id232">*</span></a></p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="klib.kmesh">
<span class="sig-prename descclassname"><span class="pre">klib.</span></span><span class="sig-name descname"><span class="pre">kmesh</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ang</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">kz</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Vo</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">hv</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">W</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#klib.kmesh" title="Permalink to this definition"></a></dt>
<dd><p>Take a mesh of kx and ky with fixed kz and generate a Nx3 array of points
which rotates the mesh about the z axis by <strong>ang</strong>. N is the flattened shape
of <strong>X</strong> and <strong>Y</strong>.</p>
<dl>
<dt><em>args</em>:</dt><dd><ul class="simple">
<li><p><strong>ang</strong>: float, angle of rotation</p></li>
<li><p><strong>X</strong>: numpy array of float, one coordinate of meshgrid</p></li>
<li><p><strong>Y</strong>: numpy array of float, second coordinate of meshgrid</p></li>
<li><p><strong>kz</strong>: float, third dimension of momentum path, fixed</p></li>
</ul>
</dd>
<dt><em>kwargs</em>:</dt><dd><ul class="simple">
<li><p><strong>Vo</strong>: float, parameter necessary for inclusion of inner potential</p></li>
<li><p><strong>hv</strong>: float, photon energy, to be used if <strong>Vo</strong> also included, for evaluating kz</p></li>
<li><p><strong>W</strong>: float, work function</p></li>
</ul>
</dd>
<dt><em>return</em>:</dt><dd><ul class="simple">
<li><p><strong>k_arr</strong>: numpy array of shape Nx3 float, rotated  kpoint array.</p></li>
<li><p><strong>ph</strong>: numpy array of N float, angles of the in-plane momentum</p></li>
</ul>
<p>points, before rotation.</p>
</dd>
</dl>
<p><a href="#id233"><span class="problematic" id="id234">**</span></a><a href="#id235"><span class="problematic" id="id236">*</span></a></p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="klib.kmesh_hv">
<span class="sig-prename descclassname"><span class="pre">klib.</span></span><span class="sig-name descname"><span class="pre">kmesh_hv</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ang</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">hv</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Vo</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#klib.kmesh_hv" title="Permalink to this definition"></a></dt>
<dd><p>Take a mesh of kx and ky with fixed kz and generate a Nx3 array of points
which rotates the mesh about the z axis by <strong>ang</strong>. N is the flattened shape
of <strong>X</strong> and <strong>Y</strong>.</p>
<dl>
<dt><em>args</em>:</dt><dd><ul class="simple">
<li><p><strong>ang</strong>: float, angle of rotation</p></li>
<li><p><strong>X</strong>: numpy array of float, one coordinate of meshgrid</p></li>
<li><p><strong>Y</strong>: numpy array of float, second coordinate of meshgrid</p></li>
<li><p><strong>kz</strong>: float, third dimension of momentum path, fixed</p></li>
</ul>
</dd>
<dt><em>kwargs</em>:</dt><dd><ul class="simple">
<li><p><strong>Vo</strong>: float, parameter necessary for inclusion of inner potential</p></li>
<li><p><strong>hv</strong>: float, photon energy, to be used if <strong>Vo</strong> also included, for evaluating kz</p></li>
<li><p><strong>W</strong>: float, work function</p></li>
</ul>
</dd>
<dt><em>return</em>:</dt><dd><ul class="simple">
<li><p><strong>k_arr</strong>: numpy array of shape Nx3 float, rotated  kpoint array.</p></li>
<li><p><strong>ph</strong>: numpy array of N float, angles of the in-plane momentum</p></li>
</ul>
<p>points, before rotation.</p>
</dd>
</dl>
<p><a href="#id237"><span class="problematic" id="id238">**</span></a><a href="#id239"><span class="problematic" id="id240">*</span></a></p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="klib.kpath">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">klib.</span></span><span class="sig-name descname"><span class="pre">kpath</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">pts</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">grain</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">labels</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#klib.kpath" title="Permalink to this definition"></a></dt>
<dd><p>Momentum object, defining a path in reciprocal space, for use in defining the 
Hamiltonian at different points in the Brillouin zone.
<a href="#id241"><span class="problematic" id="id242">**</span></a><a href="#id243"><span class="problematic" id="id244">*</span></a></p>
<dl class="py method">
<dt class="sig sig-object py" id="klib.kpath.points">
<span class="sig-name descname"><span class="pre">points</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#klib.kpath.points" title="Permalink to this definition"></a></dt>
<dd><p>Use the endpoints of kpath defined in <strong>kpath.pts</strong> to create numpy array
of len(3) float which cover the entire path, based on method by I.S. Elfimov.</p>
<dl class="simple">
<dt><em>return</em>:</dt><dd><ul class="simple">
<li><p><strong>kpath.kpts</strong>: numpy array of float, len(<strong>kpath.pts</strong>)(1+**kpath.grain**) by 3</p></li>
</ul>
</dd>
</dl>
<p><a href="#id245"><span class="problematic" id="id246">**</span></a><a href="#id247"><span class="problematic" id="id248">*</span></a></p>
</dd></dl>

</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="klib.kz_kpt">
<span class="sig-prename descclassname"><span class="pre">klib.</span></span><span class="sig-name descname"><span class="pre">kz_kpt</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">hv</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">kpt</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">W</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">V</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#klib.kz_kpt" title="Permalink to this definition"></a></dt>
<dd><p>Extract the kz associated with a given in-plane momentum, photon energy, 
work function and inner potential</p>
<dl class="simple">
<dt><em>args</em>:</dt><dd><ul class="simple">
<li><p><strong>hv</strong>: float, photon energ in eV</p></li>
<li><p><strong>kpt</strong>: float, in plane momentum, inverse Angstrom</p></li>
<li><p><strong>W</strong>: float, work function in eV</p></li>
<li><p><strong>V</strong>: float, inner potential in eV</p></li>
</ul>
</dd>
<dt><em>return</em>:</dt><dd><ul class="simple">
<li><p><strong>kz</strong>: float, out of plane momentum, inverse Angstrom</p></li>
</ul>
</dd>
</dl>
<p><a href="#id249"><span class="problematic" id="id250">**</span></a><a href="#id251"><span class="problematic" id="id252">*</span></a></p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="klib.mesh_reduce">
<span class="sig-prename descclassname"><span class="pre">klib.</span></span><span class="sig-name descname"><span class="pre">mesh_reduce</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">blatt</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mesh</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">inds</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#klib.mesh_reduce" title="Permalink to this definition"></a></dt>
<dd><p>Determine and select only k-points corresponding to the first Brillouin
zone, by simply classifying points on the basis
of whether or not the closest lattice point is the origin. 
By construction, the origin is index 13 of the blatt. 
If it is not, return error. Option to take only the indices of
the mesh which we want, rather than the actual array points
–this is relevant for tetrahedral interpolation methods</p>
<dl>
<dt><em>args</em>:</dt><dd><ul class="simple">
<li><p><strong>blatt</strong>: numpy array of len(27,3), nearest reciprocal lattice vector points</p></li>
<li><p><strong>mesh</strong>: numpy array of (N,3) float, defining a mesh of k points, before</p></li>
</ul>
<p>being reduced to contain only the Brillouin zone.</p>
</dd>
<dt><em>kwargs</em>: </dt><dd><ul class="simple">
<li><p><strong>inds</strong>: option to pass a list of bool, indicating the</p></li>
</ul>
<p>indices one wants to keep, instead of autogenerating the mesh</p>
</dd>
<dt><em>return</em>:</dt><dd><ul class="simple">
<li><p><strong>bz_pts</strong>: numpy array of (M,3) float, Brillouin zone points</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="klib.plt_pts">
<span class="sig-prename descclassname"><span class="pre">klib.</span></span><span class="sig-name descname"><span class="pre">plt_pts</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">pts</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#klib.plt_pts" title="Permalink to this definition"></a></dt>
<dd><p>Plot an array of points iin 3D</p>
<dl class="simple">
<dt><em>args</em>:</dt><dd><ul class="simple">
<li><p><strong>pts</strong>: numpy array shape N x 3</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="klib.raw_mesh">
<span class="sig-prename descclassname"><span class="pre">klib.</span></span><span class="sig-name descname"><span class="pre">raw_mesh</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">blatt</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">N</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#klib.raw_mesh" title="Permalink to this definition"></a></dt>
<dd><p>Define a mesh of points filling the region of k-space bounded by the set
of reciprocal lattice points generated by <em>bvectors</em>.
These will be further reduced by <em>mesh_reduce</em> to find points which
are within the first-Brillouin zone</p>
<dl>
<dt><em>args</em>:</dt><dd><ul class="simple">
<li><p><strong>blatt</strong>: numpy array of 27x3 float</p></li>
<li><p><strong>N</strong>: int, or iterable of len 3, defines a coarse estimation</p></li>
</ul>
<p>of number of k-points</p>
</dd>
<dt><em>return</em>:</dt><dd><ul class="simple">
<li><p><strong>mesh</strong>: numpy array of mesh points, size set roughly by N</p></li>
</ul>
</dd>
</dl>
<p><a href="#id253"><span class="problematic" id="id254">**</span></a><a href="#id255"><span class="problematic" id="id256">*</span></a></p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="klib.region">
<span class="sig-prename descclassname"><span class="pre">klib.</span></span><span class="sig-name descname"><span class="pre">region</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">num</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#klib.region" title="Permalink to this definition"></a></dt>
<dd><p>Generate a symmetric grid of points in number of lattice vectors.</p>
<dl>
<dt><em>args</em>:</dt><dd><ul class="simple">
<li><p><strong>num</strong>: int, grid will have size 2 num+1 in each direction</p></li>
</ul>
</dd>
<dt><em>return</em>:</dt><dd><ul class="simple">
<li><p>numpy array of size ((2 num+1)**3,3) with centre value of</p></li>
</ul>
<p>first entry of (-num,-num,-num),…,(0,0,0),…,(num,num,num)</p>
</dd>
</dl>
<p><a href="#id257"><span class="problematic" id="id258">**</span></a><a href="#id259"><span class="problematic" id="id260">*</span></a></p>
</dd></dl>

</section>
<section id="module-matplotlib_plotter">
<span id="matplotlib-plotter"></span><h2>matplotlib_plotter:<a class="headerlink" href="#module-matplotlib_plotter" title="Permalink to this heading"></a></h2>
<p>Created on Thu Sep 12 14:53:36 2019</p>
<p>&#64;author: rday</p>
<dl class="py class">
<dt class="sig sig-object py" id="matplotlib_plotter.interface">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">matplotlib_plotter.</span></span><span class="sig-name descname"><span class="pre">interface</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">experiment</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#matplotlib_plotter.interface" title="Permalink to this definition"></a></dt>
<dd><p>This interactive tool is intended for exploring the dataset associated
with an ARPES simulation using chinook.
The user can scan through the datacube in each dimension.
This uses matplotlib natively rather than alternative gui systems in python like Tkinter,
which makes it a bit more robust across platforms.</p>
<dl class="py method">
<dt class="sig sig-object py" id="matplotlib_plotter.interface.bin_energy">
<span class="sig-name descname"><span class="pre">bin_energy</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#matplotlib_plotter.interface.bin_energy" title="Permalink to this definition"></a></dt>
<dd><p>Translate the exact energy value for the band peaks into the discrete
binning of the intensity map, to allow for cursor queries to be processed.</p>
<p><em>return</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p><strong>coarse_pts</strong>: numpy array of float, same lengths as <em>self.state_coords</em>,</p></li>
</ul>
<p>but sampled over a discrete grid.</p>
</div></blockquote>
<p><a href="#id261"><span class="problematic" id="id262">**</span></a><a href="#id263"><span class="problematic" id="id264">*</span></a></p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="matplotlib_plotter.interface.find_cursor">
<span class="sig-name descname"><span class="pre">find_cursor</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#matplotlib_plotter.interface.find_cursor" title="Permalink to this definition"></a></dt>
<dd><p>Find nearest point to the desired cursor position, as clicked by the
user. The cursor event coordinates are compared against the peak positions
from the tight-binding calculation, and a best choice within the plotted 
slice is selected.</p>
<p><em>args</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p><strong>cursor</strong>: tuple of 2 float, indicating the column and row of the</p></li>
</ul>
<p>event, in units of the data-set scaling (e.g. 1/A or eV)</p>
</div></blockquote>
<p><a href="#id265"><span class="problematic" id="id266">**</span></a><a href="#id267"><span class="problematic" id="id268">*</span></a></p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="matplotlib_plotter.interface.plot_img">
<span class="sig-name descname"><span class="pre">plot_img</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#matplotlib_plotter.interface.plot_img" title="Permalink to this definition"></a></dt>
<dd><p>Update the plotted intensity map slice. The plotted bandstructure states are 
also displayed.</p>
<p><a href="#id269"><span class="problematic" id="id270">**</span></a><a href="#id271"><span class="problematic" id="id272">*</span></a></p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="matplotlib_plotter.interface.run_gui">
<span class="sig-name descname"><span class="pre">run_gui</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#matplotlib_plotter.interface.run_gui" title="Permalink to this definition"></a></dt>
<dd><p>Execution of the matplotlib gui. The figure is initialized, along with all widgets and 
chosen datasets. The user has access to both the slice of ARPES data plotted, in addition
to the orbital projection plotted in upper right panel.</p>
</dd></dl>

</dd></dl>

</section>
<section id="module-operator_library">
<span id="operator-library"></span><h2>operator_library:<a class="headerlink" href="#module-operator_library" title="Permalink to this heading"></a></h2>
<p>Created on Mon Mar 23 20:08:46 2020</p>
<p>&#64;author: ryanday</p>
<dl class="py function">
<dt class="sig sig-object py" id="operator_library.FS">
<span class="sig-prename descclassname"><span class="pre">operator_library.</span></span><span class="sig-name descname"><span class="pre">FS</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">TB</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ktuple</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Ef</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tol</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ax</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#operator_library.FS" title="Permalink to this definition"></a></dt>
<dd><p>A simplified form of Fermi surface extraction, for proper calculation of this,
<em>chinook.FS_tetra.py</em> is preferred. This finds all points in kmesh within a 
tolerance of the constant energy level.</p>
<p><em>args</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p><strong>TB</strong>: tight-binding model object</p></li>
<li><p><strong>ktuple</strong>: tuple of k limits, len (3), First and second should be iterable,</p></li>
</ul>
<p>define the limits and mesh of k for kx,ky, the third is constant, float for kz</p>
<ul class="simple">
<li><p><strong>Ef</strong>: float, energy of interest, eV</p></li>
<li><p><strong>tol</strong>: float, energy tolerance, float</p></li>
<li><p><strong>ax</strong>: matplotlib Axes, option for plotting onto existing Axes</p></li>
</ul>
</div></blockquote>
<p><em>return</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p><strong>pts</strong>: numpy array of len(N) x 3 indicating x,y, band index</p></li>
<li><p><strong>TB.Eband</strong>: numpy array of float, energy spectrum</p></li>
<li><p><strong>TB.Evec</strong>: numpy array of complex float, eigenvectors</p></li>
<li><p><strong>ax</strong>: matplotlib Axes, for further user modification</p></li>
</ul>
</div></blockquote>
<p><a href="#id273"><span class="problematic" id="id274">**</span></a><a href="#id275"><span class="problematic" id="id276">*</span></a></p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="operator_library.LSmat">
<span class="sig-prename descclassname"><span class="pre">operator_library.</span></span><span class="sig-name descname"><span class="pre">LSmat</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">TB</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">axis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#operator_library.LSmat" title="Permalink to this definition"></a></dt>
<dd><p>Generate an arbitary L.S type matrix for a given basis. Uses same <em>Yproj</em> as 
the <em>HSO</em> in the <em>chinook.H_library</em>, but is otherwise different, as it supports
projection onto specific axes, in addition to the full vector dot product operator.</p>
<p>Otherwise, the LiSi matrix is computed with i the axis index. 
To do this, a linear combination of L+S+,L-S-,L+S-,L-S+,LzSz terms are used to compute.</p>
<p>In the factors dictionary, the weight of these terms is defined. 
The keys are tuples of (L+/-/z,S+/-/z) in a bit
of a cryptic way. For L, range (0,1,2) -&gt;(-1,0,1) 
and for S range (-1,0,1) = S1-S2 with S1/2 = +/- 1 here</p>
<p>L+,L-,Lz matrices are defined for each l shell in the basis, 
transformed into the basis of cubic harmonics.
The nonzero terms will then just be used along with the spin and 
weighted by the factor value, and slotted into 
a len(basis)xlen(basis) matrix HSO</p>
<p><em>args</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p><strong>TB</strong>: tight-binding object, as defined in TB_lib.py</p></li>
<li><p><strong>axis</strong>: axis for calculation as either ‘x’,’y’,’z’,None,</p></li>
</ul>
<p>or float (angle in the x-y plane)</p>
</div></blockquote>
<p><em>return</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p><strong>HSO</strong>: (len(basis)xlen(basis)) numpy array of complex float</p></li>
</ul>
</div></blockquote>
<p><a href="#id277"><span class="problematic" id="id278">**</span></a><a href="#id279"><span class="problematic" id="id280">*</span></a></p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="operator_library.LdotS">
<span class="sig-prename descclassname"><span class="pre">operator_library.</span></span><span class="sig-name descname"><span class="pre">LdotS</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">TB</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">axis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ax</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">colourbar</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#operator_library.LdotS" title="Permalink to this definition"></a></dt>
<dd><p>Wrapper for <strong>O_path</strong> for computing L.S along a vector projection of interest,
or none at all.</p>
<p><em>args</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p><strong>TB</strong>: tight-binding obect</p></li>
</ul>
</div></blockquote>
<p><em>kwargs</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p><strong>axis</strong>: numpy array of 3 float, indicating axis, or None for full L.S</p></li>
<li><p><strong>ax</strong>: matplotli.Axes object for plotting</p></li>
<li><p><strong>colourbar</strong>: bool, display colourbar on plot</p></li>
</ul>
</div></blockquote>
<p><em>return</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p><strong>O</strong>: numpy array of Nxlen(basis) float, expectation value of operator</p></li>
</ul>
<p>on each band over the kpath of TB.Kobj.</p>
</div></blockquote>
<p><a href="#id281"><span class="problematic" id="id282">**</span></a><a href="#id283"><span class="problematic" id="id284">*</span></a></p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="operator_library.Lm">
<span class="sig-prename descclassname"><span class="pre">operator_library.</span></span><span class="sig-name descname"><span class="pre">Lm</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">l</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#operator_library.Lm" title="Permalink to this definition"></a></dt>
<dd><p>L- operator in the l,m_l basis, organized with 
(0,0) = <a href="#id285"><span class="problematic" id="id286">|</span></a>l,l&gt;, (2*l,2*l) = <a href="#id287"><span class="problematic" id="id288">|</span></a>l,-l&gt;
The nonzero elements are on the upper diagonal</p>
<p><em>arg</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p><strong>l</strong>: int orbital angular momentum</p></li>
</ul>
</div></blockquote>
<p><em>return</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p><strong>M</strong>: numpy array (2*l+1,2*l+1) of real float</p></li>
</ul>
</div></blockquote>
<p><a href="#id289"><span class="problematic" id="id290">**</span></a><a href="#id291"><span class="problematic" id="id292">*</span></a></p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="operator_library.Lp">
<span class="sig-prename descclassname"><span class="pre">operator_library.</span></span><span class="sig-name descname"><span class="pre">Lp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">l</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#operator_library.Lp" title="Permalink to this definition"></a></dt>
<dd><p>L+ operator in the l,m_l basis, organized with 
(0,0) = <a href="#id293"><span class="problematic" id="id294">|</span></a>l,l&gt;, (2*l,2*l) = <a href="#id295"><span class="problematic" id="id296">|</span></a>l,-l&gt;
The nonzero elements are on the upper diagonal</p>
<p><em>arg</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p><strong>l</strong>: int orbital angular momentum</p></li>
</ul>
</div></blockquote>
<p><em>return</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p><strong>M</strong>: numpy array (2*l+1,2*l+1) of real float</p></li>
</ul>
</div></blockquote>
<p><a href="#id297"><span class="problematic" id="id298">**</span></a><a href="#id299"><span class="problematic" id="id300">*</span></a></p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="operator_library.Lz">
<span class="sig-prename descclassname"><span class="pre">operator_library.</span></span><span class="sig-name descname"><span class="pre">Lz</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">l</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#operator_library.Lz" title="Permalink to this definition"></a></dt>
<dd><p>Lz operator in the l,m_l basis</p>
<p><em>arg</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p><strong>l</strong>: int orbital angular momentum</p></li>
</ul>
</div></blockquote>
<p><em>return</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p>numpy array (2*l+1,2*l+1)</p></li>
</ul>
</div></blockquote>
<p><a href="#id301"><span class="problematic" id="id302">**</span></a><a href="#id303"><span class="problematic" id="id304">*</span></a></p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="operator_library.O_path">
<span class="sig-prename descclassname"><span class="pre">operator_library.</span></span><span class="sig-name descname"><span class="pre">O_path</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">Operator</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">TB</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Kobj</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vlims</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Elims</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">degen</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">plot</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ax</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">colourbar</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">colourmap</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#operator_library.O_path" title="Permalink to this definition"></a></dt>
<dd><p>Compute and plot the expectation value of an user-defined operator along a k-path
Option of summing over degenerate bands (for e.g. fat bands) with degen boolean flag</p>
<p><em>args</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p><strong>Operator</strong>: matrix representation of the operator (numpy array len(basis), len(basis) of complex float)</p></li>
<li><p><strong>TB</strong>: Tight binding object from TB_lib</p></li>
</ul>
</div></blockquote>
<p><em>kwargs</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p><strong>Kobj</strong>: Momentum object, as defined in <em>chinook.klib.py</em></p></li>
<li><p><strong>vlims</strong>: tuple of 2 float, limits of the colourscale for plotting,</p></li>
</ul>
<p>if default value passed, will compute a reasonable range</p>
<ul class="simple">
<li><p><strong>Elims</strong>: tuple of 2 float, limits of vertical scale for plotting</p></li>
<li><p><strong>plot</strong>: bool, default to True, plot, or not plot the result</p></li>
<li><p><strong>degen</strong>: bool, True if bands are degenerate, sum over adjacent bands</p></li>
<li><p><strong>ax</strong>: matplotlib Axes, option for plotting onto existing Axes</p></li>
<li><p><strong>colourbar</strong>: bool, plot colorbar on axes, default to True</p></li>
<li><p><strong>colourmap</strong>: matplotlib colourmap,i.e. LinearSegmentedColormap</p></li>
</ul>
</div></blockquote>
<p><em>return</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p><strong>O_vals</strong>: the numpy array of float, (len Kobj x len basis) expectation values</p></li>
<li><p><strong>ax</strong>: matplotlib Axes, allowing for user to further modify</p></li>
</ul>
</div></blockquote>
<p><a href="#id305"><span class="problematic" id="id306">**</span></a><a href="#id307"><span class="problematic" id="id308">*</span></a></p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="operator_library.O_surf">
<span class="sig-prename descclassname"><span class="pre">operator_library.</span></span><span class="sig-name descname"><span class="pre">O_surf</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">O</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">TB</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ktuple</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Ef</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tol</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vlims</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">(0,</span> <span class="pre">0)</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ax</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#operator_library.O_surf" title="Permalink to this definition"></a></dt>
<dd><p>Compute and plot the expectation value of an user-defined operator over
a surface of constant-binding energy</p>
<p>Option of summing over degenerate bands (for e.g. fat bands) with degen boolean flag</p>
<p><em>args</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p><strong>O</strong>: matrix representation of the operator (numpy array len(basis), len(basis) of complex float)</p></li>
<li><p><strong>TB</strong>: Tight binding object from <em>chinook.TB_lib.py</em></p></li>
<li><dl class="simple">
<dt><strong>ktuple</strong>: momentum range for mesh: </dt><dd><p>ktuple[0] = (x0,xn,n),ktuple[1]=(y0,yn,n),ktuple[2]=kz</p>
</dd>
</dl>
</li>
</ul>
</div></blockquote>
<p><em>kwargs</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p><strong>vlims</strong>: limits for the colourscale (optional argument), will choose</p></li>
</ul>
<p>a reasonable set of limits if none passed by user</p>
<ul class="simple">
<li><p><strong>ax</strong>: matplotlib Axes, option for plotting onto existing Axes</p></li>
</ul>
</div></blockquote>
<p><em>return</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p><strong>pts</strong>: the numpy array of expectation values, of shape Nx3, with first</p></li>
</ul>
<p>two dimensions the kx,ky coordinates of the point, and the third the expectation
value.</p>
<ul class="simple">
<li><p><strong>ax</strong>: matplotlib Axes, allowing for further user modifications</p></li>
</ul>
</div></blockquote>
<p><a href="#id309"><span class="problematic" id="id310">**</span></a><a href="#id311"><span class="problematic" id="id312">*</span></a></p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="operator_library.S_vec">
<span class="sig-prename descclassname"><span class="pre">operator_library.</span></span><span class="sig-name descname"><span class="pre">S_vec</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">LB</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vec</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#operator_library.S_vec" title="Permalink to this definition"></a></dt>
<dd><p>Spin operator along an arbitrary direction can be written as
n.S = nx Sx + ny Sy + nz Sz</p>
<p><em>args</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p><strong>LB</strong>: int, length of basis</p></li>
<li><p><strong>vec</strong>: numpy array of 3 float, direction of spin projection</p></li>
</ul>
</div></blockquote>
<p><em>return</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p>numpy array of complex float (LB by LB), spin operator matrix</p></li>
</ul>
</div></blockquote>
<p><a href="#id313"><span class="problematic" id="id314">**</span></a><a href="#id315"><span class="problematic" id="id316">*</span></a></p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="operator_library.Sz">
<span class="sig-prename descclassname"><span class="pre">operator_library.</span></span><span class="sig-name descname"><span class="pre">Sz</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">TB</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ax</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">colourbar</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#operator_library.Sz" title="Permalink to this definition"></a></dt>
<dd><p>Wrapper for <strong>O_path</strong> for computing Sz along a vector projection of interest,
or none at all.</p>
<p><em>args</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p><strong>TB</strong>: tight-binding obect</p></li>
</ul>
</div></blockquote>
<p><em>kwargs</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p><strong>ax</strong>: matplotlib.Axes plotting object</p></li>
<li><p><strong>colourbar</strong>: bool, display colourbar on plot</p></li>
</ul>
</div></blockquote>
<p><em>return</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p><strong>O</strong>: numpy array of Nxlen(basis) float, expectation value of operator</p></li>
</ul>
<p>on each band over the kpath of TB.Kobj.</p>
</div></blockquote>
<p><a href="#id317"><span class="problematic" id="id318">**</span></a><a href="#id319"><span class="problematic" id="id320">*</span></a></p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="operator_library.colourmaps">
<span class="sig-prename descclassname"><span class="pre">operator_library.</span></span><span class="sig-name descname"><span class="pre">colourmaps</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#operator_library.colourmaps" title="Permalink to this definition"></a></dt>
<dd><p>Plot utility, define a few colourmaps which scale to transparent at their zero values</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="operator_library.degen_Ovals">
<span class="sig-prename descclassname"><span class="pre">operator_library.</span></span><span class="sig-name descname"><span class="pre">degen_Ovals</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">Oper_exp</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Energy</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#operator_library.degen_Ovals" title="Permalink to this definition"></a></dt>
<dd><p>In the presence of degeneracy, we want to average over the
evaluated orbital expectation values–numerically, the degenerate 
subspace can be arbitrarily diagonalized during numpy.linalg.eigh. 
All degeneracies are found, and the expectation values averaged.</p>
<p><em>args</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p><strong>Oper_exp</strong>: numpy array of float, operator expectations</p></li>
<li><p><strong>Energy</strong>: numpy array of float, energy eigenvalues.</p></li>
</ul>
</div></blockquote>
<p><a href="#id321"><span class="problematic" id="id322">**</span></a><a href="#id323"><span class="problematic" id="id324">*</span></a></p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="operator_library.fatbs">
<span class="sig-prename descclassname"><span class="pre">operator_library.</span></span><span class="sig-name descname"><span class="pre">fatbs</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">proj</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">TB</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Kobj</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vlims</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Elims</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">degen</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ax</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">colourbar</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">plot</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#operator_library.fatbs" title="Permalink to this definition"></a></dt>
<dd><p>Fat band projections. User denotes which orbital index projection is of interest
Projection passed either as an Nx1 or Nx2 array of float. If Nx2, first column is
the indices of the desired orbitals, the second column is the weight. If Nx1, then
the weights are all taken to be eqaul</p>
<p><em>args</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p><strong>proj</strong>: iterable of projections, to be passed as either a 1-dimensional</p></li>
</ul>
<p>with indices of projection only, OR, 2-dimensional, with the second column giving
the amplitude of projection (for linear-combination projection)</p>
<ul class="simple">
<li><p><strong>TB</strong>: tight-binding object</p></li>
</ul>
</div></blockquote>
<p><em>kwargs</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p><strong>Kobj</strong>: Momentum object, as defined in <em>chinook.klib.py</em></p></li>
<li><p><strong>vlims</strong>: tuple of 2 float, limits of the colorscale for plotting, default to (0,1)</p></li>
<li><p><strong>Elims</strong>: tuple of 2 float, limits of vertical scale for plotting</p></li>
<li><p><strong>plot</strong>: bool, default to True, plot, or not plot the result</p></li>
<li><p><strong>degen</strong>: bool, True if bands are degenerate, sum over adjacent bands</p></li>
<li><p><strong>ax</strong>: matplotlib Axes, option for plotting onto existing Axes</p></li>
<li><p><strong>colorbar</strong>: bool, plot colorbar on axes, default to True</p></li>
</ul>
</div></blockquote>
<p><em>return</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p><strong>Ovals</strong>: numpy array of float, len(Kobj.kpts)*len(TB.basis)</p></li>
</ul>
</div></blockquote>
<p><a href="#id325"><span class="problematic" id="id326">**</span></a><a href="#id327"><span class="problematic" id="id328">*</span></a></p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="operator_library.is_numeric">
<span class="sig-prename descclassname"><span class="pre">operator_library.</span></span><span class="sig-name descname"><span class="pre">is_numeric</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#operator_library.is_numeric" title="Permalink to this definition"></a></dt>
<dd><p>Quick check if object is numeric</p>
<p><em>args</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p><strong>a</strong>: numeric, float/int</p></li>
</ul>
</div></blockquote>
<p><em>return</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p>bool, if numeric True, else False</p></li>
</ul>
</div></blockquote>
<p><a href="#id329"><span class="problematic" id="id330">**</span></a><a href="#id331"><span class="problematic" id="id332">*</span></a></p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="operator_library.operator_projected_fermi_surface">
<span class="sig-prename descclassname"><span class="pre">operator_library.</span></span><span class="sig-name descname"><span class="pre">operator_projected_fermi_surface</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">TB</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">matrix</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">npts=100</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">kfix=(2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">0)</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">energy=0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">shift=array([0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">0])</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">degen=True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fig=None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cmap=&lt;matplotlib.colors.LinearSegmentedColormap</span> <span class="pre">object&gt;</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">scale=20</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#operator_library.operator_projected_fermi_surface" title="Permalink to this definition"></a></dt>
<dd><p>Simple 2D-projected FS with operator expectation values plot over the FS contours.</p>
<dl class="simple">
<dt><em>args</em>:</dt><dd><ul class="simple">
<li><p><strong>TB</strong>: tight-binding object</p></li>
<li><p><strong>matrix</strong>: numpy array of complex float, operator matrix</p></li>
<li><p><strong>npts</strong>: number of k-points along axes of BZ</p></li>
<li><p><strong>kfix</strong>: fixed index of BZ. First value is projected reciprocal lattice vector (0,1,2), second is value (inverse Angstrom)</p></li>
<li><p><strong>energy</strong>: float, fixed value of energy (EF = 0 )</p></li>
<li><p><strong>shift</strong>: numpy array of 3 float. Shift of centre of plot</p></li>
<li><p><strong>degen</strong>: boolean, average over degenerate bands</p></li>
<li><p><strong>fig</strong>: matplotlib figure to plot on top of</p></li>
<li><p><strong>cmap</strong>: colourmap</p></li>
<li><p><strong>scale</strong>: multiplier for scatterplot point sizes</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="operator_library.surface_proj">
<span class="sig-prename descclassname"><span class="pre">operator_library.</span></span><span class="sig-name descname"><span class="pre">surface_proj</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">basis</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">length</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#operator_library.surface_proj" title="Permalink to this definition"></a></dt>
<dd><p>Operator for computing surface-projection of eigenstates. User passes the orbital basis
and an extinction length (1/e) length for the ‘projection onto surface’. The operator 
is diagonal with exponenential suppression based on depth.</p>
<p>For use with SLAB geometry only</p>
<p><em>args</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p><strong>basis</strong>: list, orbital objects</p></li>
<li><p><strong>cutoff</strong>: float, cutoff length</p></li>
</ul>
</div></blockquote>
<p><em>return</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p><strong>M</strong>: numpy array of float, shape len(TB.basis) x len(TB.basis)</p></li>
</ul>
</div></blockquote>
<p><a href="#id333"><span class="problematic" id="id334">**</span></a><a href="#id335"><span class="problematic" id="id336">*</span></a></p>
</dd></dl>

</section>
<section id="module-orbital">
<span id="orbital"></span><h2>orbital:<a class="headerlink" href="#module-orbital" title="Permalink to this heading"></a></h2>
<dl class="py function">
<dt class="sig sig-object py" id="orbital.fact">
<span class="sig-prename descclassname"><span class="pre">orbital.</span></span><span class="sig-name descname"><span class="pre">fact</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#orbital.fact" title="Permalink to this definition"></a></dt>
<dd><p>Recursive factorial function, works for any non-negative integer.</p>
<p><em>args</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p><strong>n</strong>: int, or integer-float</p></li>
</ul>
</div></blockquote>
<p><em>return</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p>int, recursively evaluates the factorial of the initial input value.</p></li>
</ul>
</div></blockquote>
<p><a href="#id337"><span class="problematic" id="id338">**</span></a><a href="#id339"><span class="problematic" id="id340">*</span></a></p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="orbital.orbital">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">orbital.</span></span><span class="sig-name descname"><span class="pre">orbital</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">atom</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">index</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">label</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pos</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Z</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">orient</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">[0.0]</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">spin</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lam</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sigma</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">slab_index</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#orbital.orbital" title="Permalink to this definition"></a></dt>
<dd><p>The <strong>orbital</strong> object carries all essential details of the elements of the
model Hamiltonian basis, for both generation of the tight-binding model, in
addition to the evaluation of expectation values and ARPES intensity.</p>
<dl class="py method">
<dt class="sig sig-object py" id="orbital.orbital.copy">
<span class="sig-name descname"><span class="pre">copy</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#orbital.orbital.copy" title="Permalink to this definition"></a></dt>
<dd><p>Copy by value method for orbital object</p>
<p><em>return</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p><strong>orbital_copy</strong>: duplicate of <strong>orbital</strong> object</p></li>
</ul>
</div></blockquote>
<p><a href="#id341"><span class="problematic" id="id342">**</span></a><a href="#id343"><span class="problematic" id="id344">*</span></a></p>
</dd></dl>

</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="orbital.rot_projection">
<span class="sig-prename descclassname"><span class="pre">orbital.</span></span><span class="sig-name descname"><span class="pre">rot_projection</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">l</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">proj</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rotation</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#orbital.rot_projection" title="Permalink to this definition"></a></dt>
<dd><p>Go through a projection array, and apply the intended transformation to
the Ylm projections in order.
Define Euler angles in the z-y-z convention
THIS WILL BE A COUNTERCLOCKWISE ROTATION ABOUT a vector BY angle gamma 
expressed in radians. Note that we always define spin in the lab-frame, so
spin degrees of freedom are not rotated when we rotate the orbital degrees
of freedom.</p>
<p><em>args</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p><strong>l</strong>: int,orbital angular momentum</p></li>
<li><p><strong>proj</strong>: numpy array of shape Nx4 of float, each element is</p></li>
</ul>
<p>[Re(projection),Im(projection),l,m]</p>
<ul class="simple">
<li><p><strong>rotation</strong>: float, or list, defining rotation of orbital. If float,</p></li>
</ul>
<p>assume rotation about z-axis. If list, first element is a numpy array 
of len 3, indicating rotation vector, and second element is float, angle.</p>
</div></blockquote>
<p><em>return</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p><strong>proj</strong>: numpy array of Mx4 float, as above, but modified, and may</p></li>
</ul>
<p>now include additional, or fewer elements than input <em>proj</em>.</p>
<ul class="simple">
<li><p><strong>Dmat</strong>: numpy array of (2l+1)x(2l+1) complex float indicating the</p></li>
</ul>
<p>Wigner Big-D matrix associated with the rotation of this orbital shell
about the intended axis.</p>
</div></blockquote>
<p><a href="#id345"><span class="problematic" id="id346">**</span></a><a href="#id347"><span class="problematic" id="id348">*</span></a></p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="orbital.slab_basis_copy">
<span class="sig-prename descclassname"><span class="pre">orbital.</span></span><span class="sig-name descname"><span class="pre">slab_basis_copy</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">basis</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">new_posns</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">new_inds</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#orbital.slab_basis_copy" title="Permalink to this definition"></a></dt>
<dd><p>Copy elements of a slab basis into a new list of
orbitals, with modified positions and index ordering.</p>
<p><em>args</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p><strong>basis</strong>: list or orbital objects</p></li>
<li><p><strong>new_posns</strong>: numpy array of len(basis)x3 float, new positions for</p></li>
</ul>
<p>orbital</p>
<ul class="simple">
<li><p><strong>new_inds</strong>: numpy array of len(basis) int, new indices for orbitals</p></li>
</ul>
</div></blockquote>
<p><em>return</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p><strong>new_basis</strong>: list of duplicated orbitals following modification.</p></li>
</ul>
</div></blockquote>
<p><a href="#id349"><span class="problematic" id="id350">**</span></a><a href="#id351"><span class="problematic" id="id352">*</span></a></p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="orbital.sort_basis">
<span class="sig-prename descclassname"><span class="pre">orbital.</span></span><span class="sig-name descname"><span class="pre">sort_basis</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">basis</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">slab</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#orbital.sort_basis" title="Permalink to this definition"></a></dt>
<dd><p>Utility script for organizing an orbital basis that is out of sequence</p>
<p><em>args</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p><strong>basis</strong>: list of orbital objects</p></li>
<li><p><strong>slab</strong>: bool, True or False if this is for sorting a slab</p></li>
</ul>
</div></blockquote>
<p><em>return</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p><strong>orb_basis</strong>: list of sorted orbital objects (by orbital.index value)</p></li>
</ul>
</div></blockquote>
<p><a href="#id353"><span class="problematic" id="id354">**</span></a><a href="#id355"><span class="problematic" id="id356">*</span></a></p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="orbital.spin_double">
<span class="sig-prename descclassname"><span class="pre">orbital.</span></span><span class="sig-name descname"><span class="pre">spin_double</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">basis</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lamdict</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#orbital.spin_double" title="Permalink to this definition"></a></dt>
<dd><p>Double the size of a basis to introduce spin to the problem.
Go through the basis and create an identical copy with opposite spin and 
incremented index such that the orbital basis order puts spin down in the first
N/2 orbitals, and spin up in the second N/2.</p>
<p><em>args</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p><strong>basis</strong>: list of orbital objects</p></li>
<li><p><strong>lamdict</strong>: dictionary of int:float pairs providing the</p></li>
</ul>
<p>spin-orbit coupling strength for the different inequivalent atoms in 
basis.</p>
</div></blockquote>
<p><em>return</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p>doubled basis carrying all required spin information</p></li>
</ul>
</div></blockquote>
<p><a href="#id357"><span class="problematic" id="id358">**</span></a><a href="#id359"><span class="problematic" id="id360">*</span></a></p>
</dd></dl>

</section>
<section id="module-orbital_plotting">
<span id="orbital-plotting"></span><h2>orbital_plotting:<a class="headerlink" href="#module-orbital_plotting" title="Permalink to this heading"></a></h2>
<dl class="py function">
<dt class="sig sig-object py" id="orbital_plotting.col_phase">
<span class="sig-prename descclassname"><span class="pre">orbital_plotting.</span></span><span class="sig-name descname"><span class="pre">col_phase</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">vals</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#orbital_plotting.col_phase" title="Permalink to this definition"></a></dt>
<dd><p>Define the phase of a complex number</p>
<p><em>args</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p><strong>vals</strong>: complex float, or numpy array of complex float</p></li>
</ul>
</div></blockquote>
<p><em>return</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p>float, or numpy array of float of same shape as vals, from -pi to pi</p></li>
</ul>
</div></blockquote>
<p><a href="#id361"><span class="problematic" id="id362">**</span></a><a href="#id363"><span class="problematic" id="id364">*</span></a></p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="orbital_plotting.make_angle_mesh">
<span class="sig-prename descclassname"><span class="pre">orbital_plotting.</span></span><span class="sig-name descname"><span class="pre">make_angle_mesh</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#orbital_plotting.make_angle_mesh" title="Permalink to this definition"></a></dt>
<dd><p>Quick utility function for generating an angular mesh over spherical surface</p>
<p><em>args</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p><strong>n</strong>: int, number of divisions of the angular space</p></li>
</ul>
</div></blockquote>
<p><em>return</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p><strong>th</strong>: numpy array of 2n float from 0 to pi</p></li>
<li><p><strong>ph</strong>: numpy array of 4n float from 0 to 2pi</p></li>
</ul>
</div></blockquote>
<p><a href="#id365"><span class="problematic" id="id366">**</span></a><a href="#id367"><span class="problematic" id="id368">*</span></a></p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="orbital_plotting.rephase_wavefunctions">
<span class="sig-prename descclassname"><span class="pre">orbital_plotting.</span></span><span class="sig-name descname"><span class="pre">rephase_wavefunctions</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">vecs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">index</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">-</span> <span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#orbital_plotting.rephase_wavefunctions" title="Permalink to this definition"></a></dt>
<dd><p>The wavefunction at different k-points can choose an arbitrary phase, as can 
a subspace of degenerate eigenstates. As such, it is often advisable to choose
a global phase definition when comparing several different vectors. The user here
passes a set of vectors, and they are rephased. The user has the option of specifying
which basis index they would like to set the phasing. It is essential however that the
projection onto at least one basis element is non-zero over the entire set  of vectors 
for this rephasing to work.</p>
<p><em>args</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p><strong>vecs</strong>: numpy array of complex float, ordered as rows:vector index, columns: basis index</p></li>
</ul>
</div></blockquote>
<p><em>kwargs</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p><strong>index</strong>: int, optional choice of basis phase selection</p></li>
</ul>
</div></blockquote>
<p><em>return</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p><strong>rephase</strong>: numpy array of complex float of same shape as <em>vecs</em></p></li>
</ul>
</div></blockquote>
<p><a href="#id369"><span class="problematic" id="id370">**</span></a><a href="#id371"><span class="problematic" id="id372">*</span></a></p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="orbital_plotting.wavefunction">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">orbital_plotting.</span></span><span class="sig-name descname"><span class="pre">wavefunction</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">basis</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vector</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#orbital_plotting.wavefunction" title="Permalink to this definition"></a></dt>
<dd><p>This class acts to reorganize basis and wavefunction information in a more
suitable data structure than the native orbital class, or the sake of plotting
orbital wavefunctions. The relevant eigenvector can be redefined, so long as it
represents a projection onto the same orbital basis set as defined previously.</p>
<p><em>args</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p><strong>basis</strong>: list of orbital objects</p></li>
<li><p><strong>vector</strong>: numpy array of complex float, eigenvector projected onto the basis orbitals</p></li>
</ul>
</div></blockquote>
<dl class="py method">
<dt class="sig sig-object py" id="orbital_plotting.wavefunction.calc_Ylm">
<span class="sig-name descname"><span class="pre">calc_Ylm</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">th</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ph</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#orbital_plotting.wavefunction.calc_Ylm" title="Permalink to this definition"></a></dt>
<dd><p>Calculate all spherical harmonics needed for present calculation</p>
<p><em>return</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p>numpy array of complex float, of shape (len(self.harmonics),len(th))</p></li>
</ul>
</div></blockquote>
<p><a href="#id373"><span class="problematic" id="id374">**</span></a><a href="#id375"><span class="problematic" id="id376">*</span></a></p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="orbital_plotting.wavefunction.find_centres">
<span class="sig-name descname"><span class="pre">find_centres</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#orbital_plotting.wavefunction.find_centres" title="Permalink to this definition"></a></dt>
<dd><p>Create a Pointer array of basis indices and the centres of these basis orbitals.</p>
<p><em>return</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p><strong>all_centres</strong>: list of numpy array of length 3, indicating unique positions in the basis set</p></li>
<li><p><strong>centre_pointers</strong>: list of int, indicating the indices of position array, associated with the</p></li>
</ul>
<p>location of the related orbital in real space.</p>
</div></blockquote>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="orbital_plotting.wavefunction.find_harmonics">
<span class="sig-name descname"><span class="pre">find_harmonics</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#orbital_plotting.wavefunction.find_harmonics" title="Permalink to this definition"></a></dt>
<dd><p>Create a pointer array of basis indices and the associated spherical harmonics, as well as
aa more convenient vector form of the projections themselves, as lists of complex float</p>
<p><em>return</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p><strong>all_lm</strong>: list of int, l,m pairs of all spherical harmonics relevant to calculation</p></li>
<li><p><strong>lm_pointers</strong>: list of int, pointer indices relating each basis orbital projection to the</p></li>
</ul>
<p>lm pairs in <em>all_lm</em></p>
<ul class="simple">
<li><p><strong>projectors</strong>: list of arrays of complex float, providing the complex projection of basis</p></li>
</ul>
<p>onto the related spherical harmonics</p>
</div></blockquote>
<p><a href="#id377"><span class="problematic" id="id378">**</span></a><a href="#id379"><span class="problematic" id="id380">*</span></a></p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="orbital_plotting.wavefunction.plot_wavefunction">
<span class="sig-name descname"><span class="pre">plot_wavefunction</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">vertices</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">triangulations</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">colours</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">plot_ax</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cbar_ax</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#orbital_plotting.wavefunction.plot_wavefunction" title="Permalink to this definition"></a></dt>
<dd><p>Plotting function, for visualizing orbitals.</p>
<p><em>args</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p><strong>vertices</strong>: numpy array of float, shape (len(centres), len(th)*len(ph), 3) locations of vertices</p></li>
<li><p><strong>triangulations</strong>: numpy array of int, indicating the vertices connecting each surface patch</p></li>
<li><p><strong>colours</strong>: numpy array of float, of shape (len(centres),len(triangles)) encoding the orbital phase for each surface patch of the plotting</p></li>
<li><p><strong>plot_ax</strong>: matplotlib Axes, for plotting on existing axes</p></li>
<li><p><strong>cbar_ax</strong>: matplotlib Axes, for use in drawing colourbar</p></li>
</ul>
</div></blockquote>
<p><em>return</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p><strong>plots</strong>: list of plotted surfaces</p></li>
<li><p><strong>plot_ax</strong>: matplotlib Axes, for further modifications</p></li>
</ul>
</div></blockquote>
<p><a href="#id381"><span class="problematic" id="id382">**</span></a><a href="#id383"><span class="problematic" id="id384">*</span></a></p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="orbital_plotting.wavefunction.redefine_vector">
<span class="sig-name descname"><span class="pre">redefine_vector</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">vector</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#orbital_plotting.wavefunction.redefine_vector" title="Permalink to this definition"></a></dt>
<dd><p>Update vector definition</p>
<p><em>args</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p><strong>vector</strong>: numpy array of complex float, same length as self.vector</p></li>
</ul>
</div></blockquote>
<p><a href="#id385"><span class="problematic" id="id386">**</span></a><a href="#id387"><span class="problematic" id="id388">*</span></a></p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="orbital_plotting.wavefunction.triangulate_wavefunction">
<span class="sig-name descname"><span class="pre">triangulate_wavefunction</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">plotting</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ax</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#orbital_plotting.wavefunction.triangulate_wavefunction" title="Permalink to this definition"></a></dt>
<dd><p>Plot the wavefunction stored in the class attributes as self.vector as a projection
over the basis of spherical harmonics. The radial wavefunctions are not explicitly included,
in the event of multiple basis atom sites, the length scale is set by the mean interatomic 
distance. The wavefunction phase is encoded in the colourscale of the mesh plot. The user
sets the smoothness of the orbital projection by the integer argument <em>n</em></p>
<p><em>args</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p><strong>n</strong>: int, number of angles in the mesh: Theta from 0 to pi is divided 2n times, and</p></li>
</ul>
<p>Phi from 0 to 2pi is divided 4n times</p>
</div></blockquote>
<p><em>kwargs</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p><strong>plotting</strong>: boolean, turn on/off to display plot</p></li>
<li><p><strong>ax</strong>: matplotlib Axes, for plotting on existing plot</p></li>
</ul>
</div></blockquote>
<p><em>return</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p><strong>vertices</strong>: numpy array of float, shape (len(centres), len(th)*len(ph), 3) locations of vertices</p></li>
<li><p><strong>triangulations</strong>: numpy array of int, indicating the vertices connecting each surface patch</p></li>
<li><p><strong>colours</strong>: numpy array of float, of shape (len(centres),len(triangles)) encoding the orbital phase for each surface patch of the plotting</p></li>
<li><p><strong>ax</strong>: matplotlib Axes, for further modifications</p></li>
</ul>
</div></blockquote>
<p><a href="#id389"><span class="problematic" id="id390">**</span></a><a href="#id391"><span class="problematic" id="id392">*</span></a></p>
</dd></dl>

</dd></dl>

</section>
<section id="module-radint_lib">
<span id="radint-lib"></span><h2>radint_lib:<a class="headerlink" href="#module-radint_lib" title="Permalink to this heading"></a></h2>
<dl class="py function">
<dt class="sig sig-object py" id="radint_lib.define_radial_wavefunctions">
<span class="sig-prename descclassname"><span class="pre">radint_lib.</span></span><span class="sig-name descname"><span class="pre">define_radial_wavefunctions</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">rad_dict</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">basis</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#radint_lib.define_radial_wavefunctions" title="Permalink to this definition"></a></dt>
<dd><p>Define the executable radial wavefunctions for computation of
the radial integrals</p>
<p><em>args</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p><strong>rad_dict</strong>: essential key is <em>‘rad_type’</em>, if not passed,</p></li>
</ul>
<p>assume Slater orbitals.</p>
<ul>
<li><p><strong>rad_dict[‘rad_type’]</strong>:</p>
<blockquote>
<div><ul class="simple">
<li><p><em>‘slater’</em>: default value, if <em>‘rad_type’</em> is not passed,</p></li>
</ul>
<dl>
<dt>Slater type orbitals assumed and evaluated for the integral</dt><dd><ul class="simple">
<li><p><em>‘rad_args’</em>: dictionary of float, supplying optional final-state</p></li>
</ul>
<p>phase shifts, accounting for scattering-type final states. keys of form
‘a-n-l-lp’. Radial integrals will be accordingly multiplied</p>
</dd>
</dl>
<ul class="simple">
<li><p><em>‘hydrogenic’</em>: similar in execution to <em>‘slater’</em>,</p></li>
</ul>
<dl>
<dt>but uses Hydrogenic orbitals–more realistic for light-atoms</dt><dd><ul class="simple">
<li><p><em>‘rad_args’</em>: dictionary of float, supplying optional final-state</p></li>
</ul>
<p>phase shifts, accounting for scattering-type final states. keys of form
‘a-n-l-lp’. Radial integrals will be accordingly multiplied</p>
</dd>
</dl>
<ul class="simple">
<li><p><em>‘grid’</em>: radial wavefunctions evaluated on a grid of</p></li>
</ul>
<p>radii. Requires also another key_value pair:</p>
<blockquote>
<div><ul class="simple">
<li><p><em>‘rad_args’</em>: dictionary of numpy arrays evaluating</p></li>
</ul>
<p>the radial wavefunctions. Requires an <em>‘r’</em> array,
as well as ‘a-n-l’ indicating ‘atom-principal quantum number-orbital angular momentum’.
Must pass such a grid for each orbital in the basis!</p>
</div></blockquote>
<ul class="simple">
<li><p><em>‘exec’</em>: executable functions for each ‘a-n-l’ i.e.</p></li>
</ul>
<p>‘atom-principal quantum number-orbital angular momentum’. 
If      executable is chosen, require also:</p>
<blockquote>
<div><ul class="simple">
<li><p><em>‘rad_args’</em>, which will be a dictionary of</p></li>
</ul>
<p>executables, labelled by the keys ‘a-n-l’. 
These will be passed to the integral routine.
Note that it is required that the executables
are localized, i.e. vanishing for large radii.</p>
</div></blockquote>
<ul class="simple">
<li><p><em>‘fixed</em>: radial integrals taken to be constant float,</p></li>
</ul>
<p>require dictionary:</p>
<blockquote>
<div><ul class="simple">
<li><p><em>‘rad_args’</em> with keys ‘a-n-l-lp’, i.e.</p></li>
</ul>
<p>‘atom-principal quantum number-orbital angular momentum-final state angular momentum’
and complex float values for the radial integrals.</p>
</div></blockquote>
</div></blockquote>
</li>
<li><p><strong>basis</strong>: list of orbital objects</p></li>
</ul>
</div></blockquote>
<p><em>return</em>:</p>
<blockquote>
<div><p><strong>orbital_funcs</strong>: dictionary of executables</p>
</div></blockquote>
<p><a href="#id393"><span class="problematic" id="id394">**</span></a><a href="#id395"><span class="problematic" id="id396">*</span></a></p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="radint_lib.fill_radint_dic">
<span class="sig-prename descclassname"><span class="pre">radint_lib.</span></span><span class="sig-name descname"><span class="pre">fill_radint_dic</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">Eb</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">orbital_funcs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">hv</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">W</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">phase_shifts</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fixed</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#radint_lib.fill_radint_dic" title="Permalink to this definition"></a></dt>
<dd><p>Function for computing dictionary of radial integrals. 
Can pass either an array of binding energies or a single binding
energy as a float. In either case, returns a dictionary however 
the difference being that the key value pairs will have a value
which is itself either a float, or an interpolation mesh over 
the range of the binding energy array. The output can then be 
used by either writing <strong>Bdic[‘key’]</strong> or
<a href="#id397"><span class="problematic" id="id398">**</span></a>Bdic[‘key’]**(valid float between endpoints of input array)</p>
<p><em>args</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p><strong>Eb</strong>: float or tuple indicating the extremal energies</p></li>
<li><p><strong>orbital_funcs</strong>: dictionary of executable orbital radial wavefunctions</p></li>
<li><p><strong>fixed</strong>: bool, if True, constant radial integral for each scattering</p></li>
</ul>
<p>channel available: then the orbital_funcs dictionary already
has the radial integral evaluated</p>
<ul class="simple">
<li><p><strong>hv</strong>: float, photon energy of incident light.</p></li>
</ul>
</div></blockquote>
<p><em>kwargs</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p><strong>W</strong>: float, work function</p></li>
<li><p><strong>phase_shifts</strong>: dictionary for final state phase shifts, as an optional</p></li>
</ul>
<p>extension beyond pure- free electron final states. For now, float type.</p>
</div></blockquote>
<p><em>return</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p><strong>Brad</strong>: dictionary of executable interpolation grids</p></li>
</ul>
</div></blockquote>
<p><a href="#id399"><span class="problematic" id="id400">**</span></a><a href="#id401"><span class="problematic" id="id402">*</span></a></p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="radint_lib.find_cutoff">
<span class="sig-prename descclassname"><span class="pre">radint_lib.</span></span><span class="sig-name descname"><span class="pre">find_cutoff</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">func</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#radint_lib.find_cutoff" title="Permalink to this definition"></a></dt>
<dd><p>Find a suitable cutoff lengthscale for the radial integration:
Evaluate the function over a range of 20 Angstrom, with reasonable
detail (dr = 0.02 A). Find the maximum in this range. The cutoff
tolerance is set to 1/1e4 of the maximum value. Since this ‘max’
is actually a lower bound on the true maximum, this will only give
us a more strict cutoff tolerance than is absolutely possible. With
this point found, we then find all points which are within the
tolerance of zero. The frequency of these points is then found. When
the frequency is constant and 1 for all subsequent points, we have
found the point of convergence. If the ‘point of convergence’ is the
last point in the array, the radial wavefunction really isn’t suitably
localized and the user should not proceed without giving more
consideration to the application of the LCAO approximation to such
a function.</p>
<p><em>args</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p><strong>func</strong>: the integrand executable</p></li>
</ul>
</div></blockquote>
<p><em>return</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p>float, cutoff distance for integration</p></li>
</ul>
</div></blockquote>
<p><a href="#id403"><span class="problematic" id="id404">**</span></a><a href="#id405"><span class="problematic" id="id406">*</span></a></p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="radint_lib.gen_const">
<span class="sig-prename descclassname"><span class="pre">radint_lib.</span></span><span class="sig-name descname"><span class="pre">gen_const</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">val</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#radint_lib.gen_const" title="Permalink to this definition"></a></dt>
<dd><p>Create executable function returning a constant value</p>
<p><em>args</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p><strong>val</strong>: constant value to return when executable function</p></li>
</ul>
</div></blockquote>
<p><em>return</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p>lambda function with constant value</p></li>
</ul>
</div></blockquote>
<p><a href="#id407"><span class="problematic" id="id408">**</span></a><a href="#id409"><span class="problematic" id="id410">*</span></a></p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="radint_lib.gen_orb_labels">
<span class="sig-prename descclassname"><span class="pre">radint_lib.</span></span><span class="sig-name descname"><span class="pre">gen_orb_labels</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">basis</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#radint_lib.gen_orb_labels" title="Permalink to this definition"></a></dt>
<dd><p>Simple utility function for generating a dictionary of 
atom-n-l:[Z, orbital label] pairs, to establish which radial integrals
need be computed.</p>
<p><em>args</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p><strong>basis</strong>: list of orbitals in basis</p></li>
</ul>
</div></blockquote>
<p><em>return</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p><strong>orbitals</strong>: dictionary of radial integral pairs</p></li>
</ul>
</div></blockquote>
<p><a href="#id411"><span class="problematic" id="id412">**</span></a><a href="#id413"><span class="problematic" id="id414">*</span></a></p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="radint_lib.make_radint_pointer">
<span class="sig-prename descclassname"><span class="pre">radint_lib.</span></span><span class="sig-name descname"><span class="pre">make_radint_pointer</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">rad_dict</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">basis</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Eb</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#radint_lib.make_radint_pointer" title="Permalink to this definition"></a></dt>
<dd><p>Define executable radial integral functions, and store in a 
pointer-integer referenced array. This allows for fewer executions
of the interpolation function in the event where several orbitals
in the basis share the same a,n,l. Each of these gets 2 functions
for l +/-1, which are stored in the rows of the array <strong>B_array</strong>.
The orbitals in the basis then are matched to these executables,
with the corresponding executable row index saved in <strong>B_pointers</strong>.</p>
<p>Begin by defining the executable radial wavefunctions, then perform
integration at several binding energies, finally returning an
interpolation of these integrations.</p>
<p><em>args</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p><strong>rad_dict</strong>: dictionary of ARPES parameters: relevant keys are</p></li>
</ul>
<p>‘hv’ (photon energy), ‘W’ (work function), and the rad_type
(radial wavefunction type, as well as any relevant additional
pars, c.f. <em>radint_lib.define_radial_wavefunctions</em>).
Note: <em>‘rad_type’</em> is optional, (as is <em>rad_args</em>, depending on choice
of radial wavefunction.)</p>
<ul class="simple">
<li><p><strong>basis</strong>: list of orbitals in the basis</p></li>
<li><p><strong>Eb</strong>: tuple of 2 floats indicating the range of energy of</p></li>
</ul>
<p>interest (increasing order)</p>
</div></blockquote>
<p><em>return</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p><strong>B_array</strong>: numpy array of Nx2 executable functions of float</p></li>
<li><p><strong>B_pointers</strong>: numpy array of integer indices matching orbital</p></li>
</ul>
<p>basis ordering to the functions in <strong>B_array</strong></p>
</div></blockquote>
<p><a href="#id415"><span class="problematic" id="id416">**</span></a><a href="#id417"><span class="problematic" id="id418">*</span></a></p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="radint_lib.radint_calc">
<span class="sig-prename descclassname"><span class="pre">radint_lib.</span></span><span class="sig-name descname"><span class="pre">radint_calc</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">k_norm</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">orbital_funcs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">phase_shifts</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#radint_lib.radint_calc" title="Permalink to this definition"></a></dt>
<dd><p>Compute dictionary of radial integrals evaluated at a single <a href="#id781"><span class="problematic" id="id782">|k|</span></a> value
for the whole basis. Will avoid redundant integrations by checking for
the presence of an identical dictionary key. The integration is done
as a simple adaptive integration algorithm, defined in the 
<em>adaptive_int</em> library.</p>
<p><em>args</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p><strong>k_norm</strong>: float, length of the k-vector</p></li>
</ul>
<p>(as an argument for the spherical Bessel Function)</p>
<ul class="simple">
<li><p><strong>orbital_funcs</strong>: dictionary, radial wavefunction executables</p></li>
</ul>
</div></blockquote>
<p><em>kwargs</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p><strong>phase_shifts</strong>: dictionary of phase shifts, to convey final state scattering</p></li>
</ul>
</div></blockquote>
<p><em>returns</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p><strong>Bdic</strong>: dictionary, key value pairs in form – ‘ATOM-N-L’:<em>Bval</em></p></li>
</ul>
</div></blockquote>
<p><a href="#id419"><span class="problematic" id="id420">**</span></a><a href="#id421"><span class="problematic" id="id422">*</span></a></p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="radint_lib.radint_dict_to_arr">
<span class="sig-prename descclassname"><span class="pre">radint_lib.</span></span><span class="sig-name descname"><span class="pre">radint_dict_to_arr</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">Bdict</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">basis</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#radint_lib.radint_dict_to_arr" title="Permalink to this definition"></a></dt>
<dd><p>Take a dictionary of executables defined for different combinations
of a,n,l and send them to an array, with a corresponding pointer
array which can be used to dereference the relevant executable.</p>
<p><em>args</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p><strong>Bdict</strong>: dictionary of executables with ‘a-n-l-l’’ keys</p></li>
<li><p><strong>basis</strong>: list of orbital objects</p></li>
</ul>
</div></blockquote>
<p><em>return</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p><strong>Blist</strong>: numpy array of the executables, organized by a-n-l,</p></li>
</ul>
<p>and l’ (size Nx2, where N is the length of the set of 
distinct a-n-l triplets)</p>
<ul class="simple">
<li><p><strong>pointers</strong>: numpy array of length (basis), integer datatype</p></li>
</ul>
<p>indicating the related positions in the <strong>Blist</strong> array</p>
</div></blockquote>
<p><a href="#id423"><span class="problematic" id="id424">**</span></a><a href="#id425"><span class="problematic" id="id426">*</span></a></p>
</dd></dl>

</section>
<section id="module-rotation_lib">
<span id="rotation-lib"></span><h2>rotation_lib:<a class="headerlink" href="#module-rotation_lib" title="Permalink to this heading"></a></h2>
<p>Created on Mon Oct  1 20:04:24 2018</p>
<p>&#64;author: rday</p>
<p>Various functions relevant to rotations</p>
<dl class="py function">
<dt class="sig sig-object py" id="rotation_lib.Euler">
<span class="sig-prename descclassname"><span class="pre">rotation_lib.</span></span><span class="sig-name descname"><span class="pre">Euler</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">rotation</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#rotation_lib.Euler" title="Permalink to this definition"></a></dt>
<dd><p>Euler rotation angle generation, Z-Y-Z convention, as defined for a user-defined
rotation matrix. Special case for B = +/- Z*pi where conventional approach doesn’t
work due to division by zero, then Euler_A is zero and Euler_y is arctan(R10,R00)</p>
<p><em>args</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p><strong>rotation</strong>: numpy array of 3x3 float (rotation matrix)</p></li>
</ul>
<p>OR tuple/list of vector and angle (numpy array of 3 float, float) respectively</p>
</div></blockquote>
<p><em>return</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p><strong>Euler_A</strong>, <strong>Euler_B</strong>, <strong>Euler_y</strong>: float, Euler angles associated with</p></li>
</ul>
<p>the given rotation.</p>
</div></blockquote>
<p><a href="#id427"><span class="problematic" id="id428">**</span></a><a href="#id429"><span class="problematic" id="id430">*</span></a></p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="rotation_lib.Euler_to_R">
<span class="sig-prename descclassname"><span class="pre">rotation_lib.</span></span><span class="sig-name descname"><span class="pre">Euler_to_R</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">Euler_A</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Euler_B</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Euler_y</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#rotation_lib.Euler_to_R" title="Permalink to this definition"></a></dt>
<dd><p>Inverse of <em>Euler</em>, generate a rotation matrix from the Euler angles A,B,y
with the same conventiona as in <em>Euler</em>.</p>
<p><em>args</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p><strong>Euler_A</strong>, <strong>Euler_B</strong>, <strong>Euler_y</strong>: float</p></li>
</ul>
</div></blockquote>
<p><em>return</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p>numpy array of 3x3 float</p></li>
</ul>
</div></blockquote>
<p><a href="#id431"><span class="problematic" id="id432">**</span></a><a href="#id433"><span class="problematic" id="id434">*</span></a></p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="rotation_lib.Rodrigues_Rmat">
<span class="sig-prename descclassname"><span class="pre">rotation_lib.</span></span><span class="sig-name descname"><span class="pre">Rodrigues_Rmat</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">nvec</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">theta</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#rotation_lib.Rodrigues_Rmat" title="Permalink to this definition"></a></dt>
<dd><p>Following Rodrigues theorem for rotations, define a rotation matrix which
corresponds to the rotation about a vector nvec by the angle theta, in radians.
Works in pre-multiplication order (i.e. v’ = R.v)</p>
<p><em>args</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p><strong>nvec</strong>: numpy array len 3 axis of rotation</p></li>
<li><p><strong>theta</strong>: float radian angle of rotation counter clockwise for theta&gt;0</p></li>
</ul>
</div></blockquote>
<p><em>return</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p><strong>Rmat</strong>: numpy array 3x3 of float rotation matrix</p></li>
</ul>
</div></blockquote>
<p><a href="#id435"><span class="problematic" id="id436">**</span></a><a href="#id437"><span class="problematic" id="id438">*</span></a></p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="rotation_lib.rot_vector">
<span class="sig-prename descclassname"><span class="pre">rotation_lib.</span></span><span class="sig-name descname"><span class="pre">rot_vector</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">Rmatrix</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#rotation_lib.rot_vector" title="Permalink to this definition"></a></dt>
<dd><p>Inverse to <em>Rodrigues_Rmat</em>, take rotation matrix as input and return 
the angle-axis convention rotations corresponding to this rotation matrix.</p>
<p><em>args</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p><strong>Rmatrix</strong>: numpy array of 3x3 float, rotation matrix</p></li>
</ul>
</div></blockquote>
<p><em>return</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p><strong>nvec</strong>: numpy array of 3 float, rotation axis</p></li>
<li><p><strong>theta</strong>: float, rotation angle in float</p></li>
</ul>
</div></blockquote>
<p><a href="#id439"><span class="problematic" id="id440">**</span></a><a href="#id441"><span class="problematic" id="id442">*</span></a></p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="rotation_lib.rotate_v1v2">
<span class="sig-prename descclassname"><span class="pre">rotation_lib.</span></span><span class="sig-name descname"><span class="pre">rotate_v1v2</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">v1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">v2</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#rotation_lib.rotate_v1v2" title="Permalink to this definition"></a></dt>
<dd><p>This generates the rotation matrix for PRE-multiplication rotation:
or written another way, defining R s.t. R.v1 = v2. This rotation will rotate
the vector <strong>v1</strong> onto the vector <strong>v2</strong>.</p>
<p><em>args</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p><strong>v1</strong>: numpy array len 3 of float, input vector</p></li>
<li><p><strong>v2</strong>: numpy array len 3 of float, vector to rotate into</p></li>
</ul>
</div></blockquote>
<p><em>return</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p><strong>Rmat</strong>: numpy array of 3x3 float, rotation matrix</p></li>
</ul>
</div></blockquote>
<p><a href="#id443"><span class="problematic" id="id444">**</span></a><a href="#id445"><span class="problematic" id="id446">*</span></a></p>
</dd></dl>

</section>
<section id="module-slab">
<span id="slab"></span><h2>slab:<a class="headerlink" href="#module-slab" title="Permalink to this heading"></a></h2>
<dl class="py function">
<dt class="sig sig-object py" id="slab.GCD">
<span class="sig-prename descclassname"><span class="pre">slab.</span></span><span class="sig-name descname"><span class="pre">GCD</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#slab.GCD" title="Permalink to this definition"></a></dt>
<dd><p>Basic greatest common denominator function. First find all divisors of each a and b.
Then find the maximal common element of their divisors.</p>
<p><em>args</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p><strong>a</strong>, <strong>b</strong>: int</p></li>
</ul>
</div></blockquote>
<p><em>return</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p>int, GCD of <strong>a</strong>, <strong>b</strong></p></li>
</ul>
</div></blockquote>
<p><a href="#id447"><span class="problematic" id="id448">**</span></a><a href="#id449"><span class="problematic" id="id450">*</span></a></p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="slab.H_conj">
<span class="sig-prename descclassname"><span class="pre">slab.</span></span><span class="sig-name descname"><span class="pre">H_conj</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">h</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#slab.H_conj" title="Permalink to this definition"></a></dt>
<dd><p>Conjugate hopping path</p>
<p><em>args</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p><strong>h</strong>: list, input hopping path in format [i,j,x,y,z,Hij]</p></li>
</ul>
</div></blockquote>
<p><em>return</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p>list, reversed hopping path, swapped indices, complex conjugate of the</p></li>
</ul>
<p>hopping strength</p>
</div></blockquote>
<p><a href="#id451"><span class="problematic" id="id452">**</span></a><a href="#id453"><span class="problematic" id="id454">*</span></a></p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="slab.H_surf">
<span class="sig-prename descclassname"><span class="pre">slab.</span></span><span class="sig-name descname"><span class="pre">H_surf</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">surf_basis</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">avec</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">H_bulk</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Rmat</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lenbasis</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#slab.H_surf" title="Permalink to this definition"></a></dt>
<dd><p>Rewrite the bulk-Hamiltonian in terms of the surface unit cell, with its
(most likely expanded) basis. The idea here is to organize all ‘duplicate’ 
orbitals, in terms of their various connecting vectors. Using modular
arithmetic, we then create an organized dictionary which categorizes the 
hopping paths within the new unit cell according to the new basis index
designation. For each element in the Hamiltonian then, we can do the same
modular definition of the hopping vector, easily determining which orbital
in our new basis this hopping path indeed corresponds to. We then make a
new list, organizing corresponding to the new basis listing.</p>
<p><em>args</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p><strong>surf_basis</strong>: list of orbitals in the surface unit cell</p></li>
<li><p><strong>avec</strong>: numpy array 3x3 of float, surface unit cell vectors</p></li>
<li><p><strong>H_bulk</strong>: <em>H_me</em> object(defined in <em>chinook.TB_lib.py</em>), as</p></li>
</ul>
<p>the bulk-Hamiltonian</p>
<ul class="simple">
<li><p><strong>Rmat</strong>: 3x3 numpy array of float, rotation matrix</p></li>
</ul>
<p>(pre-multiply vectors) for rotating the coordinate system from bulk 
to surface unit cell axes</p>
<ul class="simple">
<li><p><strong>lenbasis</strong>: int, length of bulk basis</p></li>
</ul>
</div></blockquote>
<p><em>return</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p>Hamiltonian object, written in the basis of the surface unit cell,</p></li>
</ul>
<p>and its coordinate frame, rather than those of the bulk system</p>
</div></blockquote>
<p><a href="#id455"><span class="problematic" id="id456">**</span></a><a href="#id457"><span class="problematic" id="id458">*</span></a></p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="slab.Hobj_to_dict">
<span class="sig-prename descclassname"><span class="pre">slab.</span></span><span class="sig-name descname"><span class="pre">Hobj_to_dict</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">Hobj</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">basis</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#slab.Hobj_to_dict" title="Permalink to this definition"></a></dt>
<dd><p>Associate a list of matrix elements with each orbital in the original basis. 
The hopping paths are given not as direct units,but as number of unit-vectors
for each hopping path. So the actual hopping path will be:</p>
<blockquote>
<div><p>np.dot(H[2:5],svec)+TB.basis[j].pos-TB.basis[i].pos</p>
</div></blockquote>
<p>This facilitates determining easily which basis element we are dealing with.
For the slab, the new supercell will be extended along the 001 direction. 
So to redefine the orbital indices for a given element, we just take 
[i, len(basis)*(R_2)+j, (np.dot((R_0,R_1,R_2),svec)+pos[j]-pos[i]),H]
If the path goes into the vacuum buffer don’t add it to the new list!</p>
<p><em>args</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p><strong>Hobj</strong>: <em>H_me</em> object(defined in <em>chinook.TB_lib.py</em>), as</p></li>
</ul>
<p>the bulk-Hamiltonian</p>
<ul class="simple">
<li><p><strong>basis</strong>: list of <em>orbital</em> objects</p></li>
</ul>
</div></blockquote>
<p><em>return</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p><strong>Hdict</strong>: dictionary of hopping paths associated with a given orbital</p></li>
</ul>
<p>index</p>
</div></blockquote>
<p><a href="#id459"><span class="problematic" id="id460">**</span></a><a href="#id461"><span class="problematic" id="id462">*</span></a></p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="slab.LCM">
<span class="sig-prename descclassname"><span class="pre">slab.</span></span><span class="sig-name descname"><span class="pre">LCM</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#slab.LCM" title="Permalink to this definition"></a></dt>
<dd><p>Basic lowest-common multiplier for two values a,b. Based on idea that LCM is just the
product of the two input, divided by their greatest common denominator.</p>
<p><em>args</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p><strong>a</strong>, <strong>b</strong>: int</p></li>
</ul>
</div></blockquote>
<p><em>return</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p>int, LCM of <strong>a</strong> and <strong>b</strong></p></li>
</ul>
</div></blockquote>
<p><a href="#id463"><span class="problematic" id="id464">**</span></a><a href="#id465"><span class="problematic" id="id466">*</span></a></p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="slab.LCM_3">
<span class="sig-prename descclassname"><span class="pre">slab.</span></span><span class="sig-name descname"><span class="pre">LCM_3</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">c</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#slab.LCM_3" title="Permalink to this definition"></a></dt>
<dd><p>For generating spanning vectors, require lowest common multiple of 3
integers, itself just the LCM of one of the numbers, and the LCM of the other two.</p>
<p><em>args</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p><strong>a</strong>, <strong>b</strong>, <strong>c</strong>: int</p></li>
</ul>
</div></blockquote>
<p><em>return</em>:</p>
<blockquote>
<div><p>int, LCM of the three numbers</p>
</div></blockquote>
<p><a href="#id467"><span class="problematic" id="id468">**</span></a><a href="#id469"><span class="problematic" id="id470">*</span></a></p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="slab.abs_to_frac">
<span class="sig-prename descclassname"><span class="pre">slab.</span></span><span class="sig-name descname"><span class="pre">abs_to_frac</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">avec</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vec</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#slab.abs_to_frac" title="Permalink to this definition"></a></dt>
<dd><dl>
<dt>Quick function for taking a row-ordered matrix of lattice vectors: </dt><dd><div class="line-block">
<div class="line">a_11  a_12  a_13  |</div>
<div class="line">a_21  a_22  a_23  |</div>
<div class="line">a_31  a_32  a_33  |</div>
</div>
</dd>
</dl>
<p>and using it to transform a vector, written in absolute units, to fractional units.
Note this function can be used to broadcast over N vectors you would like to transform</p>
<p><em>args</em>:</p>
<blockquote>
<div><blockquote>
<div><ul class="simple">
<li><p><strong>avec</strong>: numpy array of 3x3 float lattice vectors, ordered by rows</p></li>
<li><p><strong>vec</strong>: numpy array of Nx3 float, vectors to be transformed to</p></li>
</ul>
<p>fractional coordinates</p>
</div></blockquote>
<p><em>return</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p>Nx3 array of float, vectors translated into basis of lattice vectors</p></li>
</ul>
</div></blockquote>
</div></blockquote>
<p><a href="#id471"><span class="problematic" id="id472">**</span></a><a href="#id473"><span class="problematic" id="id474">*</span></a></p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="slab.basal_plane">
<span class="sig-prename descclassname"><span class="pre">slab.</span></span><span class="sig-name descname"><span class="pre">basal_plane</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">vvecs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#slab.basal_plane" title="Permalink to this definition"></a></dt>
<dd><p>Everything is most convenient if we redefine the basal plane of the surface
normal to be oriented within a Cartesian plane. To do so, we take the
v-vectors. We get the norm of v1,v2 and then find the cross product with
the z-axis, as well as the angle between these two vectors. We can then
rotate the surface normal onto the z-axis.
In this way we conveniently re-orient the v1,v2 axes into the Cartesian x,y plane.</p>
<p><em>args</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p><strong>vvecs</strong>: numpy array 3x3 float</p></li>
</ul>
</div></blockquote>
<p><em>return</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p><strong>vvec_prime</strong>: numpy array 3x3 of float, rotated v vectors</p></li>
<li><p><strong>Rmat</strong>: numpy array of 3x3 float, rotation matrix to send original</p></li>
</ul>
<p>coordinate frame into the rotated coordinates.</p>
</div></blockquote>
<p><a href="#id475"><span class="problematic" id="id476">**</span></a><a href="#id477"><span class="problematic" id="id478">*</span></a></p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="slab.build_slab_H">
<span class="sig-prename descclassname"><span class="pre">slab.</span></span><span class="sig-name descname"><span class="pre">build_slab_H</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">Hsurf</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">slab_basis</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">surf_basis</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">svec</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#slab.build_slab_H" title="Permalink to this definition"></a></dt>
<dd><p>Build a slab Hamiltonian, having already defined the surface-unit cell
Hamiltonian and basis. Begin by creating a dictionary corresponding to the
Hamiltonian matrix elements associated with the relevant surface unit cell 
orbital which pairs with our slab orbital, and all its possible hoppings
in the original surface unit cell. This dictionary conveniently redefines
the hopping paths in units of lattice vectors between the relevant orbitals.
In this way, we can easily relabel a matrix element by the slab_basis 
elements, and then translate the connecting vector in terms of the 
pertinent orbitals.</p>
<p>If the resulting element is from the lower diagonal, take its conjugate.
Finally, only if the result is physical, i.e. corresponds to a hopping path
contained in the slab, and not e.g. extending into the vacuum, 
should the matrix element be included in the new Hamiltonian. Finally,
the new list Hnew is made into a Hamiltonian object, as always, and
duplicates are removed.</p>
<p><em>args</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p><strong>Hsurf</strong>: <em>H_me</em> object(defined in <em>chinook.TB_lib.py</em>), as</p></li>
</ul>
<p>the bulk-Hamiltonian from the surface unit cell</p>
<ul class="simple">
<li><p><strong>slab_basis</strong>: list of orbital objects, slab unit cell basis</p></li>
<li><p><strong>surf_basis</strong>: list of orbital objects, surface unit cell basis</p></li>
<li><p><strong>svec</strong>: numpy array of 3x3 float, surface unit cell lattice vectors</p></li>
</ul>
</div></blockquote>
<p><em>return</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p>list of Hamiltonian matrix elements in [i,j,x,y,z,Hij] format</p></li>
</ul>
</div></blockquote>
<p><a href="#id479"><span class="problematic" id="id480">**</span></a><a href="#id481"><span class="problematic" id="id482">*</span></a></p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="slab.bulk_to_slab">
<span class="sig-prename descclassname"><span class="pre">slab.</span></span><span class="sig-name descname"><span class="pre">bulk_to_slab</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">slab_dict</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#slab.bulk_to_slab" title="Permalink to this definition"></a></dt>
<dd><p>Wrapper function for generating a slab tight-binding model, having 
established a bulk model.</p>
<p><em>args</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p><strong>slab_dict</strong>: dictionary containing all essential information</p></li>
</ul>
<p>regarding the slab construction:</p>
<blockquote>
<div><ul class="simple">
<li><p><em>‘miller’</em>: numpy array len 3 of int, miller indices</p></li>
<li><p><em>‘TB’</em>: Tight-binding model corresponding to the bulk model</p></li>
<li><p><em>‘fine’</em>:  tuple of 2 float. Fine adjustment of the slab limits,</p></li>
</ul>
<p>beyond the termination to precisely indicate the termination. 
units of Angstrom, relative to the bottom, and top surface generated</p>
<ul class="simple">
<li><p><em>‘thick’</em>: float, minimum thickness of the slab structure</p></li>
<li><p><em>‘vac’</em>: float, minimum thickness of the slab vacuum buffer</p></li>
</ul>
<p>to properly generate a surface with possible surface states</p>
<ul class="simple">
<li><p><em>‘termination’</em>: tuple of 2 int, specifying the basis indices</p></li>
</ul>
<p>for the top and bottom of the slab structure</p>
</div></blockquote>
</div></blockquote>
<p><em>return</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p><strong>slab_TB</strong>: tight-binding TB object containing the slab basis</p></li>
<li><p><strong>slab_ham</strong>: Hamiltonian object, slab Hamiltonian</p></li>
<li><p><strong>Rmat</strong>: numpy array of 3x3 float, rotation matrix</p></li>
</ul>
</div></blockquote>
<p><a href="#id483"><span class="problematic" id="id484">**</span></a><a href="#id485"><span class="problematic" id="id486">*</span></a></p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="slab.divisors">
<span class="sig-prename descclassname"><span class="pre">slab.</span></span><span class="sig-name descname"><span class="pre">divisors</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#slab.divisors" title="Permalink to this definition"></a></dt>
<dd><p>Iterate through all integer divisors of integer input</p>
<p><em>args</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p><strong>a</strong>: int</p></li>
</ul>
</div></blockquote>
<p><em>return</em>:</p>
<blockquote>
<div><p>list of int, divisors of <strong>a</strong></p>
</div></blockquote>
<p><a href="#id487"><span class="problematic" id="id488">**</span></a><a href="#id489"><span class="problematic" id="id490">*</span></a></p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="slab.frac_inside">
<span class="sig-prename descclassname"><span class="pre">slab.</span></span><span class="sig-name descname"><span class="pre">frac_inside</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">points</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">avec</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#slab.frac_inside" title="Permalink to this definition"></a></dt>
<dd><p>Use fractional coordinates to determine whether a point is inside the new unit cell, or not.
This is a very simple way of establishing this point, and circumvents many of the awkward 
rounding issues of the parallelepiped method I have used previously. Ultimately however, 
imprecision of the matrix multiplication and inversion result in some rounding error which
must be corrected for. To do this, the fractional coordinates are rounded to the 4th digit.
This leads to a smaller uncertainty by over an order to 10^3 than each rounding done on the 
direct coordinates.</p>
<p><em>args</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p><strong>points</strong>: numpy array of float (Nx4) indicating positions and basis indices of the points to consider</p></li>
<li><p><strong>avec</strong>: numpy array of 3x3 float, new lattice vectors</p></li>
</ul>
</div></blockquote>
<p><em>return</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p>numpy array of Mx4 float, indicating positions and basis indices of the valid basis elements inside the new</p></li>
</ul>
<p>unit cell.</p>
</div></blockquote>
<p><a href="#id491"><span class="problematic" id="id492">**</span></a><a href="#id493"><span class="problematic" id="id494">*</span></a></p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="slab.frac_to_abs">
<span class="sig-prename descclassname"><span class="pre">slab.</span></span><span class="sig-name descname"><span class="pre">frac_to_abs</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">avec</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vec</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#slab.frac_to_abs" title="Permalink to this definition"></a></dt>
<dd><p>Same as abs_to_frac, but in opposite direction,from fractional to absolute coordinates</p>
<p><em>args</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p><strong>avec</strong>: numpy array of 3x3 float, lattice vectors, row-ordered</p></li>
<li><p><strong>vec</strong>: numpy array of Nx3 float, input vectors</p></li>
</ul>
</div></blockquote>
<p><em>return</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p>N x 3 array of float, vec in units of absolute coordinates (Angstrom)</p></li>
</ul>
</div></blockquote>
<p><a href="#id495"><span class="problematic" id="id496">**</span></a><a href="#id497"><span class="problematic" id="id498">*</span></a></p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="slab.gen_slab">
<span class="sig-prename descclassname"><span class="pre">slab.</span></span><span class="sig-name descname"><span class="pre">gen_slab</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">basis</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vn</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mint</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">minb</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">term</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fine</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">(0,</span> <span class="pre">0)</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#slab.gen_slab" title="Permalink to this definition"></a></dt>
<dd><p>Using the new basis defined for the surface unit cell, generate a slab
of at least mint (minimum thickness), minb (minimum buffer) and terminated
by orbital term. In principal the termination should be same on both top and
bottom to avoid inversion symmetry breaking between the two lattice terminations.
In certain cases, mint,minb may need to be tuned somewhat to get exactly the surface
terminations you want.</p>
<p><em>args</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p><strong>basis</strong>: list of instances of orbital objects</p></li>
<li><p><strong>vn</strong>: numpy array of 3x3 float, surface unit cell lattice vectors</p></li>
<li><p><strong>mint</strong>: float, minimum thickness of the slab, in Angstrom</p></li>
<li><p><strong>minb</strong>: float, minimum thickness of the vacuum buffer, in Angstrom</p></li>
<li><p><strong>term</strong>: tuple of 2 int, termination of the slab tuple (term[0] = top termination, term[1] = bottom termination)</p></li>
<li><p><strong>fine</strong>: tuple of 2 float, fine adjustment of the termination to precisely specify terminating atoms</p></li>
</ul>
</div></blockquote>
<p><em>return</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p><strong>avec</strong>: numpy array of float 3x3, updated lattice vector for the SLAB unit cell</p></li>
<li><p><strong>new_basis</strong>: array of new orbital basis objects, with slab-index corresponding to the original basis indexing,</p></li>
</ul>
<p>and primary index corresponding to the order within the new slab basis</p>
</div></blockquote>
<p><a href="#id499"><span class="problematic" id="id500">**</span></a><a href="#id501"><span class="problematic" id="id502">*</span></a></p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="slab.gen_surface">
<span class="sig-prename descclassname"><span class="pre">slab.</span></span><span class="sig-name descname"><span class="pre">gen_surface</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">avec</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">miller</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">basis</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#slab.gen_surface" title="Permalink to this definition"></a></dt>
<dd><p>Construct the surface unit cell, to then be propagated along the 001 direction to form a slab</p>
<p><em>args</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p><strong>avec</strong>: numpy array of 3x3 float, lattice vectors for original unit cell</p></li>
<li><p><strong>miller</strong>: numpy array of 3 int, Miller indices indicating the surface orientation</p></li>
<li><p><strong>basis</strong>: list of orbital objects, orbital basis for the original lattice</p></li>
</ul>
</div></blockquote>
<p><em>return</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p><strong>new_basis</strong>: list of orbitals, surface unit cell orbital basis</p></li>
<li><p><strong>vn_b</strong>: numpy array of 3x3 float, the surface unit cell primitive lattice vectors</p></li>
<li><p><strong>Rmat</strong>: numpy array of 3x3 float, rotation matrix, to be used in post-multiplication order</p></li>
</ul>
</div></blockquote>
<p><a href="#id503"><span class="problematic" id="id504">**</span></a><a href="#id505"><span class="problematic" id="id506">*</span></a></p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="slab.iszero">
<span class="sig-prename descclassname"><span class="pre">slab.</span></span><span class="sig-name descname"><span class="pre">iszero</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#slab.iszero" title="Permalink to this definition"></a></dt>
<dd><p>Find where an iterable of numeric is zero, returns empty list if none found</p>
<p><em>args</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p><strong>a</strong>: numpy array of numeric</p></li>
</ul>
</div></blockquote>
<p><em>return</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p>list of int, indices of iterable where value is zero</p></li>
</ul>
</div></blockquote>
<p><a href="#id507"><span class="problematic" id="id508">**</span></a><a href="#id509"><span class="problematic" id="id510">*</span></a></p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="slab.mod_dict">
<span class="sig-prename descclassname"><span class="pre">slab.</span></span><span class="sig-name descname"><span class="pre">mod_dict</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">surf_basis</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">av_i</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#slab.mod_dict" title="Permalink to this definition"></a></dt>
<dd><p>Define dictionary establishing connection between slab basis elements and the 
bulk Hamiltonian. The slab_indices relate to the bulk model, we can then compile
a list of <em>slab</em> orbital pairs (along with their connecting vectors) which should
be related to a given bulk model hopping. The hopping is expressed in terms of the
number of surface lattice vectors, rather than direct units of Angstrom.</p>
<p><em>args</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p><strong>surf_basis</strong>: list of orbital objects, covering the slab model</p></li>
<li><p><strong>av_i</strong>: numpy array of 3x3 float, inverse of the lattice vector matrix</p></li>
</ul>
</div></blockquote>
<p><em>return</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p><strong>cv_dict</strong>: dictionary with key-value pairs of</p></li>
</ul>
<p>slab_index[i]-slab_index[j]:numpy.array([[i,j,mod_vec]…])</p>
</div></blockquote>
<p><a href="#id511"><span class="problematic" id="id512">**</span></a><a href="#id513"><span class="problematic" id="id514">*</span></a></p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="slab.nonzero">
<span class="sig-prename descclassname"><span class="pre">slab.</span></span><span class="sig-name descname"><span class="pre">nonzero</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#slab.nonzero" title="Permalink to this definition"></a></dt>
<dd><p>Find where an iterable of numeric is non-zero, returns empty list if none found</p>
<p><em>args</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p><strong>a</strong>: numpy array of numeric</p></li>
</ul>
</div></blockquote>
<p><em>return</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p>list of int, indices of iterable where value is non-zero</p></li>
</ul>
</div></blockquote>
<p><a href="#id515"><span class="problematic" id="id516">**</span></a><a href="#id517"><span class="problematic" id="id518">*</span></a></p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="slab.p_vecs">
<span class="sig-prename descclassname"><span class="pre">slab.</span></span><span class="sig-name descname"><span class="pre">p_vecs</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">miller</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">avec</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#slab.p_vecs" title="Permalink to this definition"></a></dt>
<dd><p>Produce the vectors p, as defined by Ceder, to be used in defining spanning
vectors for plane normal to the Miller axis</p>
<p><em>args</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p><strong>miller</strong>: numpy array of len 3 float</p></li>
<li><p><strong>avec</strong>: numpy array of size 3x3 of float</p></li>
</ul>
</div></blockquote>
<p><em>return</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p><strong>pvecs</strong>: numpy array size 3x3 of float</p></li>
</ul>
</div></blockquote>
<p><a href="#id519"><span class="problematic" id="id520">**</span></a><a href="#id521"><span class="problematic" id="id522">*</span></a></p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="slab.par">
<span class="sig-prename descclassname"><span class="pre">slab.</span></span><span class="sig-name descname"><span class="pre">par</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">avec</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#slab.par" title="Permalink to this definition"></a></dt>
<dd><p>Definition of the parallelepiped, as well as a containing region within the 
Cartesian projection of this form which can then be used to guarantee correct
definition of the new cell basis. The parallelipiped is generated, and then
its extremal coordinates established, from which a containing parallelepiped is
then defined.</p>
<p><em>args</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p><strong>avec</strong>: numpy array of 3x3 float</p></li>
</ul>
</div></blockquote>
<p><em>return</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p><strong>vert</strong>: numpy array  8x3 float vertices of parallelepiped</p></li>
<li><p><strong>box_pts</strong>: numpy array 8 x 3 float vertices of containing box</p></li>
</ul>
</div></blockquote>
<p><a href="#id523"><span class="problematic" id="id524">**</span></a><a href="#id525"><span class="problematic" id="id526">*</span></a></p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="slab.populate_box">
<span class="sig-prename descclassname"><span class="pre">slab.</span></span><span class="sig-name descname"><span class="pre">populate_box</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">box</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">basis</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">avec</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">R</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#slab.populate_box" title="Permalink to this definition"></a></dt>
<dd><p>Populate the bounding box with points from the original lattice basis. These
represent candidate orbitals to populate the surface-projected unit cell.</p>
<p><em>args</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p><strong>box</strong>: numpy array of 8x3 float, vertices of corner of a box</p></li>
<li><p><strong>basis</strong>: list of orbital objects</p></li>
<li><p><strong>avec</strong>: numpy array of 3x3 float, lattice vectors</p></li>
<li><p><strong>R</strong>: numpy array of 3x3 float, rotation matrix</p></li>
</ul>
</div></blockquote>
<p><em>return</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p><strong>basis_full</strong>: list of Nx4 float, representing instances of orbitals copies,</p></li>
</ul>
<p>retaining only their position and their orbital basis index. These orbitals fill
a container box larger than the region of interest.</p>
</div></blockquote>
<p><a href="#id527"><span class="problematic" id="id528">**</span></a><a href="#id529"><span class="problematic" id="id530">*</span></a></p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="slab.populate_par">
<span class="sig-prename descclassname"><span class="pre">slab.</span></span><span class="sig-name descname"><span class="pre">populate_par</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">points</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">avec</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#slab.populate_par" title="Permalink to this definition"></a></dt>
<dd><p>Fill the box with basis points, keeping only those which reside in the new
unit cell.</p>
<p><em>args</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p><strong>points</strong>: numpy array of Nx4 float ([:3] give position, [3] gives index)</p></li>
<li><p><strong>avec</strong>: numpy array of  3x3 float</p></li>
</ul>
</div></blockquote>
<p><em>return</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p><strong>new_points</strong>: Nx3 numpy array of float, coordinates of new orbitals</p></li>
<li><p><strong>indices</strong>: Nx1 numpy array of float, indices in original basis</p></li>
</ul>
</div></blockquote>
<p><a href="#id531"><span class="problematic" id="id532">**</span></a><a href="#id533"><span class="problematic" id="id534">*</span></a></p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="slab.region">
<span class="sig-prename descclassname"><span class="pre">slab.</span></span><span class="sig-name descname"><span class="pre">region</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">num</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#slab.region" title="Permalink to this definition"></a></dt>
<dd><p>Generate a symmetric grid of points in number of lattice vectors.</p>
<p><em>args</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p><strong>num</strong>: int, grid will have size 2 num+1 in each direction</p></li>
</ul>
</div></blockquote>
<p><em>return</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p>numpy array of size ((2 num+1)^3,3) with centre value of first entry of</p></li>
</ul>
<p>(-num,-num,-num),…,(0,0,0),…,(num,num,num)</p>
</div></blockquote>
<p><a href="#id535"><span class="problematic" id="id536">**</span></a><a href="#id537"><span class="problematic" id="id538">*</span></a></p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="slab.sorted_basis">
<span class="sig-prename descclassname"><span class="pre">slab.</span></span><span class="sig-name descname"><span class="pre">sorted_basis</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">pts</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">inds</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#slab.sorted_basis" title="Permalink to this definition"></a></dt>
<dd><p>Re-order the elements of the new basis, with preference to z-position followed
by the original indexing</p>
<p><em>args</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p><strong>pts</strong>: numpy array of Nx3 float, orbital basis positions</p></li>
<li><p><strong>inds</strong>: numpy array of N int, indices of orbitals, from original basis</p></li>
</ul>
</div></blockquote>
<p><em>return</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p><strong>labels_sorted</strong>: numpy array of Nx4 float, [x,y,z,index], in order of increasing z, and index</p></li>
</ul>
</div></blockquote>
<p><a href="#id539"><span class="problematic" id="id540">**</span></a><a href="#id541"><span class="problematic" id="id542">*</span></a></p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="slab.unpack">
<span class="sig-prename descclassname"><span class="pre">slab.</span></span><span class="sig-name descname"><span class="pre">unpack</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">Ham_obj</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#slab.unpack" title="Permalink to this definition"></a></dt>
<dd><p>Reduce a Hamiltonian object down to a list of matrix elements. Include the Hermitian conjugate terms</p>
<p><em>args</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p><strong>Ham_obj</strong>: Hamiltonian object, c.f. <em>chinook.TB_lib.H_me</em></p></li>
</ul>
</div></blockquote>
<p><em>return</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p><strong>Hlist</strong>: list of Hamiltonian matrix elements</p></li>
</ul>
</div></blockquote>
<p><a href="#id543"><span class="problematic" id="id544">**</span></a><a href="#id545"><span class="problematic" id="id546">*</span></a></p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="slab.v_vecs">
<span class="sig-prename descclassname"><span class="pre">slab.</span></span><span class="sig-name descname"><span class="pre">v_vecs</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">miller</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">avec</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#slab.v_vecs" title="Permalink to this definition"></a></dt>
<dd><p>Wrapper for functions used to determine the vectors used to define the new,
surface unit cell.</p>
<p><em>args</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p><strong>miller</strong>: numpy array of 3 int, Miller indices for surface normal</p></li>
<li><p><strong>avec</strong>: numpy array of 3x3 float, Lattice vectors</p></li>
</ul>
</div></blockquote>
<p><em>return</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p><strong>vvecs</strong>: new surface unit cell vectors numpy array of 3x3 float</p></li>
</ul>
</div></blockquote>
</dd></dl>

</section>
<section id="module-SlaterKoster">
<span id="slaterkoster"></span><h2>SlaterKoster:<a class="headerlink" href="#module-SlaterKoster" title="Permalink to this heading"></a></h2>
<dl class="py function">
<dt class="sig sig-object py" id="SlaterKoster.SK_cub">
<span class="sig-prename descclassname"><span class="pre">SlaterKoster.</span></span><span class="sig-name descname"><span class="pre">SK_cub</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">Ymats</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">l1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">l2</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#SlaterKoster.SK_cub" title="Permalink to this definition"></a></dt>
<dd><p>In order to generate a set of independent Lambda functions for rapid 
generation of Hamiltonian matrix elements, one must nest the 
definition of the lambda functions within another function. In this way,
we avoid cross-contamination of unrelated functions.
The variables which are fixed for a given lambda function are the 
cubic -to- spherical harmonics (Ymat) transformations, and the 
orbital angular momentum of the relevant basis channels. The output
lambda functions will be functions of the Euler-angles pertaining 
to the hopping path, as well as the potential matrix V, which will be
passed as a numpy array (min(l1,l2)*2+1) long of float.</p>
<p>We follow the method described for rotated d-orbitals in the thesis of
JM Carter from Toronto (HY Kee), where the Slater-Koster hopping
matrix can be defined as the following operation:</p>
<blockquote>
<div><ol class="arabic simple">
<li><p>Transform local orbital basis into spherical harmonics</p></li>
<li><p>Rotate the hopping path along the z-axis</p></li>
<li><p>Product with the diagonal SK-matrix</p></li>
<li><p>Rotate the path backwards</p></li>
<li><p>Rotate back into basis of local orbitals</p></li>
</ol>
<p>6. Output matrix of hopping elements between all orbitals in the shell 
to fill Hamiltonian</p>
</div></blockquote>
<p><em>args</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p><strong>Ymats</strong>: list of numpy arrays corresponding to the relevant</p></li>
</ul>
<p>transformation from cubic to spherical harmonic basis</p>
<ul class="simple">
<li><p><strong>l1</strong>, <strong>l2</strong>: int orbital angular momentum channels relevant</p></li>
</ul>
<p>to a given hopping pair</p>
</div></blockquote>
<p><em>return</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p>lambda function for the SK-matrix between these orbital shells,</p></li>
</ul>
<p>for arbitrary hopping strength and direction.</p>
</div></blockquote>
<p><a href="#id547"><span class="problematic" id="id548">**</span></a><a href="#id549"><span class="problematic" id="id550">*</span></a></p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="SlaterKoster.SK_full">
<span class="sig-prename descclassname"><span class="pre">SlaterKoster.</span></span><span class="sig-name descname"><span class="pre">SK_full</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">basis</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#SlaterKoster.SK_full" title="Permalink to this definition"></a></dt>
<dd><p>Generate a dictionary of lambda functions which take as keys the
atom,orbital for both first and second element. 
Formatting is a1a2n1n2l1l2, same as for SK dictionary entries</p>
<p><em>args</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p><strong>basis</strong>: list of orbital objects composing the TB-basis</p></li>
</ul>
</div></blockquote>
<p><em>return</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p><strong>SK_funcs</strong>: a dictionary of hopping matrix functions</p></li>
</ul>
<p>(lambda functions with args EA,EB,Ey,V as Euler angles and potential (V))
which can be executed for various hopping paths and potential strengths
The keys of the dictionary will be organized similar to the way the SK
parameters are passed, labelled by a1a2n1n2l1l2, which completely
defines a given orbital-orbital coupling</p>
</div></blockquote>
<p><a href="#id551"><span class="problematic" id="id552">**</span></a><a href="#id553"><span class="problematic" id="id554">*</span></a></p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="SlaterKoster.Vmat">
<span class="sig-prename descclassname"><span class="pre">SlaterKoster.</span></span><span class="sig-name descname"><span class="pre">Vmat</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">l1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">l2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">V</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#SlaterKoster.Vmat" title="Permalink to this definition"></a></dt>
<dd><p>For Slater-Koster matrix element generation, a potential matrix is
sandwiched in between the two bond-rotating Dmatrices. It should be 
of the shape 2*l1+1 x 2*l2+1, and have the V_l,l’,D terms along the 
‘diagonal’– a concept that is only well defined for a square matrix.
For mismatched angular momentum channels, this turns into a diagonal 
square matrix of dimension min(2*l1+1,2*l2+1) centred  along the larger
axis. For channels where the orbital angular momentum change involves a
change in parity, the potential should change sign, as per Slater Koster’s
original definition from 1954. This is taken care of automatically in 
the Wigner formalism I use here, no need to have exceptions</p>
<p><em>args</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p><strong>l1</strong>, <strong>l2</strong>: int orbital angular momentum of initial and final states</p></li>
<li><p><strong>V</strong>: numpy array of float – length should be min(<strong>l1</strong> ,**l2**)*2+1</p></li>
</ul>
</div></blockquote>
<p><em>return</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p><strong>Vm</strong>: numpy array of float, shape 2 <strong>l1</strong> +1 x 2 <strong>l2</strong> +1</p></li>
</ul>
</div></blockquote>
<p><a href="#id555"><span class="problematic" id="id556">**</span></a><a href="#id557"><span class="problematic" id="id558">*</span></a></p>
</dd></dl>

</section>
<section id="module-surface_vector">
<span id="surface-vector"></span><h2>surface_vector:<a class="headerlink" href="#module-surface_vector" title="Permalink to this heading"></a></h2>
<dl class="py function">
<dt class="sig sig-object py" id="surface_vector.ang_v1v2">
<span class="sig-prename descclassname"><span class="pre">surface_vector.</span></span><span class="sig-name descname"><span class="pre">ang_v1v2</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">v1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">v2</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#surface_vector.ang_v1v2" title="Permalink to this definition"></a></dt>
<dd><p>Find angle between two vectors:</p>
<p><em>args</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p><strong>v1</strong>: numpy array of 3 float</p></li>
<li><p><strong>v2</strong>: numpy array of 3 float</p></li>
</ul>
</div></blockquote>
<p><em>return</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p>float, angle between the vectors</p></li>
</ul>
</div></blockquote>
<p><a href="#id559"><span class="problematic" id="id560">**</span></a><a href="#id561"><span class="problematic" id="id562">*</span></a></p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="surface_vector.are_parallel">
<span class="sig-prename descclassname"><span class="pre">surface_vector.</span></span><span class="sig-name descname"><span class="pre">are_parallel</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">v1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">v2</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#surface_vector.are_parallel" title="Permalink to this definition"></a></dt>
<dd><p>Determine if two vectors are parallel:</p>
<p><em>args</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p><strong>v1</strong>: numpy array of 3 float</p></li>
<li><p><strong>v2</strong>: numpy array of 3 float</p></li>
</ul>
</div></blockquote>
<p><em>return</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p>boolean, True if parallel to within 1e-5 radians</p></li>
</ul>
</div></blockquote>
<p><a href="#id563"><span class="problematic" id="id564">**</span></a><a href="#id565"><span class="problematic" id="id566">*</span></a></p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="surface_vector.are_same">
<span class="sig-prename descclassname"><span class="pre">surface_vector.</span></span><span class="sig-name descname"><span class="pre">are_same</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">v1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">v2</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#surface_vector.are_same" title="Permalink to this definition"></a></dt>
<dd><p>Determine if two vectors are identical</p>
<p><em>args</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p><strong>v1</strong>: numpy array of 3 float</p></li>
<li><p><strong>v2</strong>: numpy array of 3 float</p></li>
</ul>
</div></blockquote>
<p><em>return</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p>boolean, True if the two vectors are parallel and have same</p></li>
</ul>
<p>length, both to within 1e-5</p>
</div></blockquote>
<p><a href="#id567"><span class="problematic" id="id568">**</span></a><a href="#id569"><span class="problematic" id="id570">*</span></a></p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="surface_vector.find_v3">
<span class="sig-prename descclassname"><span class="pre">surface_vector.</span></span><span class="sig-name descname"><span class="pre">find_v3</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">v1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">v2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">avec</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">maxlen</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#surface_vector.find_v3" title="Permalink to this definition"></a></dt>
<dd><p>Find the best out-of-plane surface unit cell vector. While we initialize with
a fixed cutoff for maximum length, to avoid endless searching, we can slowly 
increase on each iteration until a good choice is possible.</p>
<p><em>args</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p><strong>v1</strong>, <strong>v2</strong>: numpy array of 3 float, in plane spanning vectors</p></li>
<li><p><strong>avec</strong>: numpy array of 3x3 float, bulk lattice vectors</p></li>
<li><p><strong>maxlen</strong>: float, max length tolerated for the vector we seek</p></li>
</ul>
</div></blockquote>
<p><em>return</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p><strong>v3_choice</strong>: the chosen unit cell vector</p></li>
</ul>
</div></blockquote>
<p><a href="#id571"><span class="problematic" id="id572">**</span></a><a href="#id573"><span class="problematic" id="id574">*</span></a></p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="surface_vector.initialize_search">
<span class="sig-prename descclassname"><span class="pre">surface_vector.</span></span><span class="sig-name descname"><span class="pre">initialize_search</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">v1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">v2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">avec</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#surface_vector.initialize_search" title="Permalink to this definition"></a></dt>
<dd><p>Seed search for v3 with the nearest-neighbouring Bravais latice point
which maximizes the projection out of plane of that spanned by v1 and v2.</p>
<p><em>args</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p><strong>v1</strong>, <strong>v2</strong>: numpy array of 3 float, the spanning vectors for plane</p></li>
<li><p><strong>avec</strong>: numpy array of 3x3 float</p></li>
</ul>
</div></blockquote>
<p><em>return</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p>numpy array of 3 float, the nearby Bravais lattice point which</p></li>
</ul>
<p>maximizes the projection along the plane normal</p>
</div></blockquote>
<p><a href="#id575"><span class="problematic" id="id576">**</span></a><a href="#id577"><span class="problematic" id="id578">*</span></a></p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="surface_vector.refine_search">
<span class="sig-prename descclassname"><span class="pre">surface_vector.</span></span><span class="sig-name descname"><span class="pre">refine_search</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">v3i</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">v1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">v2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">avec</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">maxlen</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#surface_vector.refine_search" title="Permalink to this definition"></a></dt>
<dd><p>Refine the search for the optimal v3–supercell lattice vector which both 
minimizes its length, while maximizing orthogonality with v1 and v2</p>
<p><em>args</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p><strong>v3i</strong>: numpy array of 3 float, initial guess for v3</p></li>
<li><p><strong>v1</strong>: numpy array of 3 float, in-plane supercell vector</p></li>
<li><p><strong>v2</strong>: numpy array of 3 float, in-plane supercell vector</p></li>
<li><p><strong>avec</strong>: numpy array of 3x3 float, bulk lattice vectors</p></li>
<li><p><strong>maxlen</strong>: float, upper limit on how long of a third vector we can</p></li>
</ul>
<p>reasonably tolerate. This becomes relevant for unusual Miller indices.</p>
</div></blockquote>
<p><em>return</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p><strong>v3_opt</strong> list of numpy array of 3 float, list of viable options for</p></li>
</ul>
<p>the out of plane surface unit cell vector</p>
</div></blockquote>
<p><a href="#id579"><span class="problematic" id="id580">**</span></a><a href="#id581"><span class="problematic" id="id582">*</span></a></p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="surface_vector.score">
<span class="sig-prename descclassname"><span class="pre">surface_vector.</span></span><span class="sig-name descname"><span class="pre">score</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">vlist</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">v1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">v2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">avec</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#surface_vector.score" title="Permalink to this definition"></a></dt>
<dd><p>To select the ideal out-of-plane surface unit cell vector, score the 
candidates based on both their length and their orthogonality with respect
to the two in-plane spanning vectors. The lowest scoring candidate is selected
as the ideal choice.</p>
<p><em>args</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p><strong>vlist</strong>: list of len 3 numpy array of float, choices for out-of-plane</p></li>
</ul>
<p>vector</p>
<ul class="simple">
<li><p><strong>v1</strong>, <strong>v2</strong>: numpy array of 3 float, in plane spanning vectors</p></li>
<li><p><strong>avec</strong>: numpy array of 3x3 float, primitive unit cell vectors</p></li>
</ul>
</div></blockquote>
<p><em>return</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p>numpy array of len 3, out of plane surface-projected lattice vector</p></li>
</ul>
</div></blockquote>
<p><a href="#id583"><span class="problematic" id="id584">**</span></a><a href="#id585"><span class="problematic" id="id586">*</span></a></p>
</dd></dl>

</section>
<section id="module-TB_lib">
<span id="tb-lib"></span><h2>TB_lib:<a class="headerlink" href="#module-TB_lib" title="Permalink to this heading"></a></h2>
<dl class="py class">
<dt class="sig sig-object py" id="TB_lib.H_me">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">TB_lib.</span></span><span class="sig-name descname"><span class="pre">H_me</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">i</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">j</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">executable</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#TB_lib.H_me" title="Permalink to this definition"></a></dt>
<dd><p>This class contains the relevant executables and data structure pertaining 
to generation of the Hamiltonian matrix elements for a single set of 
coupled basis orbitals. Its attributes include integer values 
<strong>i</strong>, <strong>j</strong> indicating the basis indices, and a list of hopping
vectors/matrix element values for the Hamiltonian.</p>
<p>The method <strong>H2Hk</strong> provides an executable function of momentum to allow
broadcasting of the Hamiltonian over a large array of momenta.
Python’s flexible protocol for equivalency and passing variables by
reference/value require definition of a copy operator which allows one to
produce safely, a copy of the object rather than its coordinates 
in memory alone.
<a href="#id587"><span class="problematic" id="id588">**</span></a><a href="#id589"><span class="problematic" id="id590">*</span></a></p>
<dl class="py method">
<dt class="sig sig-object py" id="TB_lib.H_me.H2Hk">
<span class="sig-name descname"><span class="pre">H2Hk</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#TB_lib.H_me.H2Hk" title="Permalink to this definition"></a></dt>
<dd><p>Transform the list of hopping elements into a Fourier-series expansion 
of the Hamiltonian. This is run during diagonalization for each
matrix element index. If running a low-energy Hamiltonian, executable functions are
simply summed for each basis index i,j, rather than computing a Fourier series. x is
implicitly a numpy array of Nx3: it is essential that the executable conform to this input type.</p>
<p><em>return</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p>lambda function of a numpy array of float of length 3</p></li>
</ul>
</div></blockquote>
<p><a href="#id591"><span class="problematic" id="id592">**</span></a><a href="#id593"><span class="problematic" id="id594">*</span></a></p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="TB_lib.H_me.append_H">
<span class="sig-name descname"><span class="pre">append_H</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">H</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">R0</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">R1</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">R2</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#TB_lib.H_me.append_H" title="Permalink to this definition"></a></dt>
<dd><p>Add a new hopping path to the coupling of the parent orbitals.</p>
<p><em>args</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p><strong>H</strong>: complex float, matrix element strength, or if self.exectype,</p></li>
</ul>
<p>should be an executable</p>
<ul class="simple">
<li><p><strong>R0</strong>, <strong>R1</strong>, <strong>R2</strong>: float connecting vector in cartesian</p></li>
</ul>
<p>coordinate frame–this is the TOTAL vector, not the relevant 
lattice vectors only</p>
</div></blockquote>
<p><em>return</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p>directly modifies the Hamiltonian list for these matrix</p></li>
</ul>
<p>coordinates</p>
</div></blockquote>
<p><a href="#id595"><span class="problematic" id="id596">**</span></a><a href="#id597"><span class="problematic" id="id598">*</span></a></p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="TB_lib.H_me.clean_H">
<span class="sig-name descname"><span class="pre">clean_H</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#TB_lib.H_me.clean_H" title="Permalink to this definition"></a></dt>
<dd><p>Remove all duplicate instances of hopping elements in the matrix 
element list. This function is run automatically during slab generation.</p>
<p>The Hamiltonian list is not itself directly modified.</p>
<p><em>return</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p>list of hopping vectors and associated Hamiltonian matrix</p></li>
</ul>
<p>element strengths</p>
</div></blockquote>
<p><a href="#id599"><span class="problematic" id="id600">**</span></a><a href="#id601"><span class="problematic" id="id602">*</span></a></p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="TB_lib.H_me.copy">
<span class="sig-name descname"><span class="pre">copy</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#TB_lib.H_me.copy" title="Permalink to this definition"></a></dt>
<dd><p>Copy by value of the <strong>H_me</strong> object</p>
<p><em>return</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p><strong>H_copy</strong>: duplicate <strong>H_me</strong> object</p></li>
</ul>
</div></blockquote>
<p><a href="#id603"><span class="problematic" id="id604">**</span></a><a href="#id605"><span class="problematic" id="id606">*</span></a></p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="TB_lib.TB_model">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">TB_lib.</span></span><span class="sig-name descname"><span class="pre">TB_model</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">basis</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">H_args</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Kobj</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#TB_lib.TB_model" title="Permalink to this definition"></a></dt>
<dd><p>The <strong>TB_model</strong> object carries the model basis as a list of <strong>orbital</strong>
objects, as well as the model Hamiltonian, as a list of <strong>H_me</strong>. The orbital
indices paired in each instance of <strong>H_me</strong> are stored in a dictionary under <strong>ijpairs</strong></p>
<dl class="py method">
<dt class="sig sig-object py" id="TB_lib.TB_model.append_H">
<span class="sig-name descname"><span class="pre">append_H</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">new_elements</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#TB_lib.TB_model.append_H" title="Permalink to this definition"></a></dt>
<dd><p>Add new terms to the Hamiltonian by hand. This directly modifies
the list of Hamiltonian matrix element, self.mat_els of the TB object.</p>
<p><em>args</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p><strong>new_elements</strong>: list of Hamiltonian matrix elements, either a single element [i,j,x_ij,y_ij,z_ij,H_ij(x,y,z)]</p></li>
</ul>
<p>or as a list of such lists. Here i, j are the related orbital-indices.</p>
</div></blockquote>
<p><a href="#id607"><span class="problematic" id="id608">**</span></a><a href="#id609"><span class="problematic" id="id610">*</span></a></p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="TB_lib.TB_model.build_ham">
<span class="sig-name descname"><span class="pre">build_ham</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">H_args</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#TB_lib.TB_model.build_ham" title="Permalink to this definition"></a></dt>
<dd><p>Buld the Hamiltonian using functions from <strong>chinook.H_library.py</strong></p>
<p><em>args</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p><strong>H_args</strong>: dictionary, containing all relevant information for</p></li>
</ul>
<p>defining the Hamiltonian list. For details, see <strong>TB_model.__init__</strong>.</p>
</div></blockquote>
<p><em>return</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p>sorted list of matrix element objects. These objects have</p></li>
</ul>
<p>i,j attributes referencing the orbital basis indices, 
and a list of form [R0,R1,R2,Re(H)+1.0jIm(H)]</p>
</div></blockquote>
<p><a href="#id611"><span class="problematic" id="id612">**</span></a><a href="#id613"><span class="problematic" id="id614">*</span></a></p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="TB_lib.TB_model.copy">
<span class="sig-name descname"><span class="pre">copy</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#TB_lib.TB_model.copy" title="Permalink to this definition"></a></dt>
<dd><p>Copy by value of the <strong>TB_model</strong> object</p>
<p><em>return</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p><strong>TB_copy</strong>: duplicate of the <strong>TB_model</strong> object.</p></li>
</ul>
</div></blockquote>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="TB_lib.TB_model.plot_unitcell">
<span class="sig-name descname"><span class="pre">plot_unitcell</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ax</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#TB_lib.TB_model.plot_unitcell" title="Permalink to this definition"></a></dt>
<dd><p>Utility script for visualizing the lattice and orbital basis.
Distinct atoms are drawn in different colours</p>
<p><em>kwargs</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p><strong>ax</strong>: matplotlib Axes, for plotting on existing Axes</p></li>
</ul>
</div></blockquote>
<p><em>return</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p><strong>ax</strong>: matplotlib Axes, for further modifications to plot</p></li>
</ul>
</div></blockquote>
<p><a href="#id615"><span class="problematic" id="id616">**</span></a><a href="#id617"><span class="problematic" id="id618">*</span></a></p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="TB_lib.TB_model.plotting">
<span class="sig-name descname"><span class="pre">plotting</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">win_min</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">win_max</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ax</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#TB_lib.TB_model.plotting" title="Permalink to this definition"></a></dt>
<dd><p>Plotting routine for a tight-binding model evaluated over some path in k.
If the model has not yet been diagonalized, it is done automatically
before proceeding.</p>
<p><em>kwargs</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p><strong>win_min</strong>, <strong>win_max</strong>: float, vertical axis limits for plotting</p></li>
</ul>
<p>in units of eV. If not passed, a reasonable choice is made which 
covers the entire eigenspectrum.</p>
<ul class="simple">
<li><p><strong>ax</strong>: matplotlib Axes, for plotting on existing Axes</p></li>
</ul>
</div></blockquote>
<p><em>return</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p><strong>ax</strong>: matplotlib axes object</p></li>
</ul>
</div></blockquote>
<p><a href="#id619"><span class="problematic" id="id620">**</span></a><a href="#id621"><span class="problematic" id="id622">*</span></a></p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="TB_lib.TB_model.print_basis_summary">
<span class="sig-name descname"><span class="pre">print_basis_summary</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#TB_lib.TB_model.print_basis_summary" title="Permalink to this definition"></a></dt>
<dd><p>Very basic print function for printing a summary
of the orbital basis, including their label, atomic species, position
and spin character.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="TB_lib.TB_model.solve_H">
<span class="sig-name descname"><span class="pre">solve_H</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">Eonly</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#TB_lib.TB_model.solve_H" title="Permalink to this definition"></a></dt>
<dd><p>This function diagonalizes the Hamiltonian over an array of momentum vectors.
It uses the <strong>mat_el</strong> objects to quickly define lambda functions of 
momentum, which are then filled into the array and diagonalized.
According to <a class="reference external" href="https://ntrs.nasa.gov/archive/nasa/casi.ntrs.nasa.gov/20050192421.pdf">https://ntrs.nasa.gov/archive/nasa/casi.ntrs.nasa.gov/20050192421.pdf</a>
SVD algorithms require memory of 2*order*(4*order + 1) ~ 8*order^2. The matrices are
complex float, so this should be 16 bytes per entry: so len(k)*(2048*order**2). If 
the diagonalization is requesting more than 85% of the available memory, then split
up the k-path into sequential diagonalizations.</p>
<p><em>return</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p><strong>self.Eband</strong>: numpy array of float, shape(len(self.Kobj.kpts),len(self.basis)),</p></li>
</ul>
<p>eigenvalues</p>
<ul class="simple">
<li><p><strong>self.Evec</strong>: numpy array of complex float, shape(len(self.Kobj.kpts),len(self.basis),len(self.basis))</p></li>
</ul>
<p>eigenvectors</p>
</div></blockquote>
<p><a href="#id623"><span class="problematic" id="id624">**</span></a><a href="#id625"><span class="problematic" id="id626">*</span></a></p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="TB_lib.TB_model.unpack">
<span class="sig-name descname"><span class="pre">unpack</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#TB_lib.TB_model.unpack" title="Permalink to this definition"></a></dt>
<dd><p>Reduce a Hamiltonian object down to a list of matrix elements. Include the Hermitian conjugate terms</p>
<p><em>return</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p><strong>Hlist</strong>: list of Hamiltonian matrix elements</p></li>
</ul>
</div></blockquote>
<p><a href="#id627"><span class="problematic" id="id628">**</span></a><a href="#id629"><span class="problematic" id="id630">*</span></a></p>
</dd></dl>

</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="TB_lib.atom_coords">
<span class="sig-prename descclassname"><span class="pre">TB_lib.</span></span><span class="sig-name descname"><span class="pre">atom_coords</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">basis</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#TB_lib.atom_coords" title="Permalink to this definition"></a></dt>
<dd><p>Define a dictionary organizing the distinct coordinates of instances of each
atomic species in the basis</p>
<p><em>args</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p><strong>basis</strong>: list of orbital objects</p></li>
</ul>
</div></blockquote>
<p><em>return</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p><a href="#id631"><span class="problematic" id="id632">**</span></a>dictionary with integer keys, numpy array of float values. atom:locations are</p></li>
</ul>
<p>encoded in this way</p>
</div></blockquote>
<p><a href="#id633"><span class="problematic" id="id634">**</span></a><a href="#id635"><span class="problematic" id="id636">*</span></a>.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="TB_lib.cell_edges">
<span class="sig-prename descclassname"><span class="pre">TB_lib.</span></span><span class="sig-name descname"><span class="pre">cell_edges</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">avec</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#TB_lib.cell_edges" title="Permalink to this definition"></a></dt>
<dd><p>Define set of line segments which enclose the unit cell.</p>
<p><em>args</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p><strong>avec</strong>: numpy array of 3x3 float</p></li>
</ul>
</div></blockquote>
<p><em>return</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p><strong>edges</strong>: numpy array of 12 x 6, endpoints of the 12 edges of the unit cell parallelepiped</p></li>
</ul>
</div></blockquote>
<p><a href="#id637"><span class="problematic" id="id638">**</span></a><a href="#id639"><span class="problematic" id="id640">*</span></a></p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="TB_lib.gen_H_obj">
<span class="sig-prename descclassname"><span class="pre">TB_lib.</span></span><span class="sig-name descname"><span class="pre">gen_H_obj</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">htmp</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">executable</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#TB_lib.gen_H_obj" title="Permalink to this definition"></a></dt>
<dd><p>Take a list of Hamiltonian matrix elements in list format:
[i,j,Rij[0],Rij[1],Rij[2],Hij(R)] and generate a list of <strong>H_me</strong>
objects instead. This collects all related matrix elements for a given
orbital-pair for convenient generation of the matrix Hamiltonians over
an input array of momentum</p>
<p><em>args</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p><strong>htmp</strong>: list of numeric-type values (mixed integer[:2], float[2:5], complex-float[-1])</p></li>
</ul>
</div></blockquote>
<p><em>kwargs</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p><strong>executable</strong>: boolean, if True, we don’t have a standard Fourier-type Hamiltonian,</p></li>
</ul>
<p>but perhaps a low-energy expansion. In this case, the htmp elements are</p>
</div></blockquote>
<p><em>return</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p><strong>Hlist</strong>: list of Hamiltonian matrix element, <strong>H_me</strong> objects</p></li>
</ul>
</div></blockquote>
<p><a href="#id641"><span class="problematic" id="id642">**</span></a><a href="#id643"><span class="problematic" id="id644">*</span></a></p>
</dd></dl>

</section>
<section id="module-tetrahedra">
<span id="tetrahedra"></span><h2>tetrahedra:<a class="headerlink" href="#module-tetrahedra" title="Permalink to this heading"></a></h2>
<p>Created on Tue Sep  4 16:27:40 2018</p>
<p>&#64;author: rday</p>
<dl class="py function">
<dt class="sig sig-object py" id="tetrahedra.corners">
<span class="sig-prename descclassname"><span class="pre">tetrahedra.</span></span><span class="sig-name descname"><span class="pre">corners</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#tetrahedra.corners" title="Permalink to this definition"></a></dt>
<dd><p>Establish the shortest main diagonal of a cube of points, so as to establish
the main diagonal for tetrahedral partitioning of the cube</p>
<p><em>return</em>:</p>
<blockquote>
<div><p><strong>main</strong>: tuple of 2 integers indicating the cube coordinates</p>
<p><strong>cube</strong>: numpy array of 8 corners (8x3) float</p>
</div></blockquote>
<p><a href="#id645"><span class="problematic" id="id646">**</span></a><a href="#id647"><span class="problematic" id="id648">*</span></a></p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="tetrahedra.gen_mesh">
<span class="sig-prename descclassname"><span class="pre">tetrahedra.</span></span><span class="sig-name descname"><span class="pre">gen_mesh</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">avec</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">N</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#tetrahedra.gen_mesh" title="Permalink to this definition"></a></dt>
<dd><p>Generate a mesh of points in 3-dimensional momentum space over the first
Brillouin zone. These are defined first in terms of recirocal lattice vectors,</p>
<p>i.e. from 0-&gt;1 along each, and then are multiplied by the rec. latt. vectors 
themselves. Note that this implicitly provides a mesh which is not centred
at zero, but has an origin at the rec. latt. vector (0,0,0)</p>
<p><em>args</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p><strong>avec</strong>: numpy array of 3x3 float, lattice vectors</p></li>
<li><p><strong>N</strong>: int, or tuple of 3 int, indicating the number of points along</p></li>
</ul>
<p>each of the reciprocal lattice vectors</p>
</div></blockquote>
<p><a href="#id649"><span class="problematic" id="id650">**</span></a><a href="#id651"><span class="problematic" id="id652">*</span></a></p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="tetrahedra.mesh_tetra">
<span class="sig-prename descclassname"><span class="pre">tetrahedra.</span></span><span class="sig-name descname"><span class="pre">mesh_tetra</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">avec</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">N</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#tetrahedra.mesh_tetra" title="Permalink to this definition"></a></dt>
<dd><p>An equivalent definition of a spanning grid over the Brillouin zone is just
one which spans the reciprocal cell unit cell. Translational symmetry imposes
that this partitioning is equivalent to the conventional definition of the 
Brillouin zone, with the very big advantage that we can define a rectilinear
grid which spans this volume in a way which can not be done for most
Bravais lattices in R3.</p>
<p><em>args</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p><strong>avec</strong>: numpy array of 3x3 float, lattice vectors</p></li>
<li><p><strong>N</strong>: int, or iterable of 3 int which define the density of the mesh</p></li>
</ul>
<p>over the Brillouin zone.</p>
</div></blockquote>
<p><em>return</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p><strong>pts</strong>: numpy array of Mx3 float, indicating the points in momentum space</p></li>
</ul>
<p>at the vertices of the mesh</p>
<ul class="simple">
<li><p><strong>mesh_tet</strong>: numpy array of Lx4 int, indicating the L-tetrahedra</p></li>
</ul>
<p>which partition the grid</p>
</div></blockquote>
<p><a href="#id653"><span class="problematic" id="id654">**</span></a><a href="#id655"><span class="problematic" id="id656">*</span></a></p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="tetrahedra.neighbours">
<span class="sig-prename descclassname"><span class="pre">tetrahedra.</span></span><span class="sig-name descname"><span class="pre">neighbours</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#tetrahedra.neighbours" title="Permalink to this definition"></a></dt>
<dd><p>For an unit cube, we can define the set of 3 nearest neighbours by performing
the requisite modular sum along one of the three Cartesian axes. In this way,
for an input point, we can extract its neighbours easily.</p>
<p><em>args</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p><strong>point</strong>: numpy array of 3 int, all either 0 or 1</p></li>
</ul>
</div></blockquote>
<p><em>return</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p>numpy array of 3x3 int, indicating the neighbours of <strong>point</strong> on the</p></li>
</ul>
<p>unit cube.</p>
</div></blockquote>
<p><a href="#id657"><span class="problematic" id="id658">**</span></a><a href="#id659"><span class="problematic" id="id660">*</span></a></p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="tetrahedra.not_point">
<span class="sig-prename descclassname"><span class="pre">tetrahedra.</span></span><span class="sig-name descname"><span class="pre">not_point</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#tetrahedra.not_point" title="Permalink to this definition"></a></dt>
<dd><p>Inverse of point, defined in an N-dimensional binary coordinate frame</p>
<p><em>args</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p><strong>point</strong>: int or numpy array of int between 0 and 1</p></li>
</ul>
</div></blockquote>
<p><em>return</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p>numpy array of int, NOT gate applied to the binary vector point</p></li>
</ul>
</div></blockquote>
<p><a href="#id661"><span class="problematic" id="id662">**</span></a><a href="#id663"><span class="problematic" id="id664">*</span></a></p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="tetrahedra.propagate">
<span class="sig-prename descclassname"><span class="pre">tetrahedra.</span></span><span class="sig-name descname"><span class="pre">propagate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">i</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Nr</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Nc</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#tetrahedra.propagate" title="Permalink to this definition"></a></dt>
<dd><p>Distribute the generic corner numbering convention defined for a cube at the 
origin to a cube starting at some arbitrary point in our grid. Excludes the
edge points as starting points, so that all cubes are within the grid.</p>
<p><em>args</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p><strong>i</strong>: int, index of origin</p></li>
<li><p><strong>Nr</strong>: int, number of rows in grid</p></li>
<li><p><strong>Nc</strong>: int, number of columns in grid</p></li>
</ul>
</div></blockquote>
<p><em>return</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p><a href="#id665"><span class="problematic" id="id666">**</span></a>numpy array of int, len 8 corresponding to the re-numbering of the</p></li>
</ul>
<p>corners of the cube.</p>
</div></blockquote>
<p><a href="#id667"><span class="problematic" id="id668">**</span></a><a href="#id669"><span class="problematic" id="id670">*</span></a></p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="tetrahedra.tet_inds">
<span class="sig-prename descclassname"><span class="pre">tetrahedra.</span></span><span class="sig-name descname"><span class="pre">tet_inds</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#tetrahedra.tet_inds" title="Permalink to this definition"></a></dt>
<dd><p>Generate, for a single cube, the tetrahedral designations, 
for the following conventional numbering:</p>
<blockquote>
<div><blockquote>
<div><p>6 o —- o 7       
/      / |</p>
</div></blockquote>
<dl>
<dt>4 o —- o5 o 3</dt><dd><div class="line-block">
<div class="line">| /</div>
</div>
</dd>
</dl>
<p>0 o —- o 1</p>
<p>with 2 hidden from view (below 6, and behind the line-segment connecting 4-5). 
Here drawn with x along horizontal, z into plane, y vertical
Defining the real-index spacing between adjacent cubes in a larger array, we can apply this simple prescription
to define the spanning tetrahedra over the larger k-mesh</p>
</div></blockquote>
<p><em>return</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p><strong>tetra_inds</strong>: numpy array of integer (6x4), with each</p></li>
</ul>
<p>row containing the index of the 4 tetrahedral vertices. Together, for
of a set of neighbouring points on a grid, we divide into a set of covering
tetrahedra which span the volume of the cube.</p>
</div></blockquote>
<p><a href="#id671"><span class="problematic" id="id672">**</span></a><a href="#id673"><span class="problematic" id="id674">*</span></a></p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="tetrahedra.tetrahedra">
<span class="sig-prename descclassname"><span class="pre">tetrahedra.</span></span><span class="sig-name descname"><span class="pre">tetrahedra</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#tetrahedra.tetrahedra" title="Permalink to this definition"></a></dt>
<dd><p>Perform partitioning of a cube into tetrahedra. The indices can then be
dotted with some basis vector set to put them into the proper coordinate frame.</p>
<p><em>return</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p><strong>tetra</strong>: numpy array of 6 x 4 x 3 int, indicating the corners</p></li>
</ul>
<p>of the 6 tetrahedra</p>
</div></blockquote>
<p><a href="#id675"><span class="problematic" id="id676">**</span></a><a href="#id677"><span class="problematic" id="id678">*</span></a></p>
</dd></dl>

</section>
<section id="module-tilt">
<span id="tilt"></span><h2>tilt:<a class="headerlink" href="#module-tilt" title="Permalink to this heading"></a></h2>
<p>Created on Fri Dec 28 13:33:59 2018</p>
<p>&#64;author: ryanday</p>
<dl class="py function">
<dt class="sig sig-object py" id="tilt.ang_mesh">
<span class="sig-prename descclassname"><span class="pre">tilt.</span></span><span class="sig-name descname"><span class="pre">ang_mesh</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">N</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">th</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ph</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#tilt.ang_mesh" title="Permalink to this definition"></a></dt>
<dd><p>Generate a mesh over the indicated range of theta and phi,
with N elements along each of the two directions</p>
<p><em>args</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p><strong>N</strong>: int or iterable of length 2 indicating # of points along <em>th</em>, and <em>ph</em> respectively</p></li>
<li><p><strong>th</strong>: iterable length 2 of float (endpoints of theta range)</p></li>
<li><p><strong>ph</strong>: iterable length 2 of float (endpoints of phi range)</p></li>
</ul>
</div></blockquote>
<p><em>return</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p>numpy array of N_th x N_ph float, representing mesh of angular coordinates</p></li>
</ul>
</div></blockquote>
<p><a href="#id679"><span class="problematic" id="id680">**</span></a><a href="#id681"><span class="problematic" id="id682">*</span></a></p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="tilt.gen_kpoints">
<span class="sig-prename descclassname"><span class="pre">tilt.</span></span><span class="sig-name descname"><span class="pre">gen_kpoints</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ek</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">N</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">thx</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">thy</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">kz</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#tilt.gen_kpoints" title="Permalink to this definition"></a></dt>
<dd><p>Generate a mesh of kpoints over a mesh of emission angles.</p>
<p><em>args</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p><strong>ek</strong>: float, kinetic energy, eV</p></li>
<li><p><strong>N</strong>: tuple of 2 int, number of points along each axis</p></li>
<li><p><strong>thx</strong>: tuple of 2 float, range of horizontal angles, radian</p></li>
<li><p><strong>thy</strong>: tuple of 2 float, range of vertical angles, radian</p></li>
<li><p><strong>kz</strong>: float, k-perpendicular of interest, inverse Angstrom</p></li>
</ul>
</div></blockquote>
<p><em>return</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p><strong>k_array</strong>: numpy array of N[1]xN[0] float, corresponding to mesh of in-plane momenta</p></li>
</ul>
</div></blockquote>
<p><a href="#id683"><span class="problematic" id="id684">**</span></a><a href="#id685"><span class="problematic" id="id686">*</span></a></p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="tilt.k_mesh">
<span class="sig-prename descclassname"><span class="pre">tilt.</span></span><span class="sig-name descname"><span class="pre">k_mesh</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">Tmesh</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Pmesh</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ek</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#tilt.k_mesh" title="Permalink to this definition"></a></dt>
<dd><p>Application of rotation to a normal-emission vector (i.e. (0,0,1) vector)
Third column of a rotation matrix formed by product of rotation about vertical (ky), and rotation around kx axis
c.f. Labbook 28 December, 2018</p>
<p><em>args</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p><strong>Tmesh</strong>: numpy array of float, output of <em>ang_mesh</em></p></li>
<li><p><strong>Pmesh</strong>: numpy array of float, output of <em>ang_mesh</em></p></li>
<li><p><strong>ek</strong>: float, kinetic energy in eV</p></li>
</ul>
</div></blockquote>
<p><em>return</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p><strong>kvec</strong>: numpy array of float, in-plane momentum array associated with angular emission coordinates</p></li>
</ul>
</div></blockquote>
<p><a href="#id687"><span class="problematic" id="id688">**</span></a><a href="#id689"><span class="problematic" id="id690">*</span></a></p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="tilt.k_parallel">
<span class="sig-prename descclassname"><span class="pre">tilt.</span></span><span class="sig-name descname"><span class="pre">k_parallel</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ek</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#tilt.k_parallel" title="Permalink to this definition"></a></dt>
<dd><p>Convert kinetic energy in eV to inverse Angstrom</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="tilt.plot_mesh">
<span class="sig-prename descclassname"><span class="pre">tilt.</span></span><span class="sig-name descname"><span class="pre">plot_mesh</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ek</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">N</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">th</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ph</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#tilt.plot_mesh" title="Permalink to this definition"></a></dt>
<dd><p>Plotting tool, plot all points in mesh, for an array of N angles,
at a fixed kinetic energy.</p>
<p><em>args</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p><strong>ek</strong>: float, kinetic energy, eV</p></li>
<li><p><strong>N</strong>: tuple of 2 int, number of points along each axis</p></li>
<li><p><strong>thx</strong>: tuple of 2 float, range of horizontal angles, radian</p></li>
<li><p><strong>thy</strong>: tuple of 2 float, range of vertical angles, radian</p></li>
</ul>
</div></blockquote>
<p><a href="#id691"><span class="problematic" id="id692">**</span></a><a href="#id693"><span class="problematic" id="id694">*</span></a></p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="tilt.rot_vector">
<span class="sig-prename descclassname"><span class="pre">tilt.</span></span><span class="sig-name descname"><span class="pre">rot_vector</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">vector</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">th</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ph</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#tilt.rot_vector" title="Permalink to this definition"></a></dt>
<dd><p>Rotation of vector by theta and phi angles, about the global y-axis by theta, followed by a rotation about
the LOCAL x axis by phi. This is analogous to the rotation of a cryostat with a vertical-rotation axis (theta),
and a sample-mount tilt angle (phi). NOTE: need to extend to include cryostats where the horizontal rotation axis
is fixed, as opposed to the vertical axis–I have never seen such a system but it is of course totally possible.</p>
<p><em>args</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p><strong>vector</strong>: numpy array length 3 of float (vector to rotate)</p></li>
<li><p><strong>th</strong>: float, or numpy array of float – vertical rotation angle(s)</p></li>
<li><p><strong>ph</strong>: float, or numpy array of float – horizontal tilt angle(s)</p></li>
</ul>
</div></blockquote>
<p><em>return</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p>numpy array of float, rotated vectors for all angles: shape 3 x len(ph) x len(th)</p></li>
</ul>
<p>NOTE: will flatten any length-one dimensions</p>
</div></blockquote>
<p><a href="#id695"><span class="problematic" id="id696">**</span></a><a href="#id697"><span class="problematic" id="id698">*</span></a></p>
</dd></dl>

</section>
<section id="module-v3find">
<span id="v3find"></span><h2>v3find:<a class="headerlink" href="#module-v3find" title="Permalink to this heading"></a></h2>
<dl class="py function">
<dt class="sig sig-object py" id="v3find.ang_v1v2">
<span class="sig-prename descclassname"><span class="pre">v3find.</span></span><span class="sig-name descname"><span class="pre">ang_v1v2</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">v1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">v2</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#v3find.ang_v1v2" title="Permalink to this definition"></a></dt>
<dd><p>Find angle between two vectors, rounded to floating point precision.</p>
<p><em>args</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p><strong>v1</strong>: numpy array of N float</p></li>
<li><p><strong>v2</strong>: numpy array of N float</p></li>
</ul>
</div></blockquote>
<p><em>return</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p>float, angle in radians</p></li>
</ul>
</div></blockquote>
<p><a href="#id699"><span class="problematic" id="id700">**</span></a><a href="#id701"><span class="problematic" id="id702">*</span></a></p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="v3find.are_parallel">
<span class="sig-prename descclassname"><span class="pre">v3find.</span></span><span class="sig-name descname"><span class="pre">are_parallel</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">v1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">v2</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#v3find.are_parallel" title="Permalink to this definition"></a></dt>
<dd><p>Are two vectors parallel?</p>
<p><em>args</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p><strong>v1</strong>: numpy array of N float</p></li>
<li><p><strong>v2</strong>: numpy array of N float</p></li>
</ul>
</div></blockquote>
<p><em>return</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p>boolean, True if parallel, to within 1e-5 radians, False otherwise</p></li>
</ul>
</div></blockquote>
<p><a href="#id703"><span class="problematic" id="id704">**</span></a><a href="#id705"><span class="problematic" id="id706">*</span></a></p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="v3find.are_same">
<span class="sig-prename descclassname"><span class="pre">v3find.</span></span><span class="sig-name descname"><span class="pre">are_same</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">v1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">v2</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#v3find.are_same" title="Permalink to this definition"></a></dt>
<dd><p>Are two vectors identical, i.e. parallel and of same length, to within 
the precision of <em>are_parallel</em>?</p>
<p><em>args</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p><strong>v1</strong>: numpy array of N float</p></li>
<li><p><strong>v2</strong>: numpy array of N float</p></li>
</ul>
</div></blockquote>
<p><em>return</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p>boolean, True if identical, False otherwise.</p></li>
</ul>
</div></blockquote>
<p><a href="#id707"><span class="problematic" id="id708">**</span></a><a href="#id709"><span class="problematic" id="id710">*</span></a></p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="v3find.find_v3">
<span class="sig-prename descclassname"><span class="pre">v3find.</span></span><span class="sig-name descname"><span class="pre">find_v3</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">v1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">v2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">avec</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">maxlen</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#v3find.find_v3" title="Permalink to this definition"></a></dt>
<dd><p>Wrapper function for finding the surface vector.</p>
<p><em>args</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p><strong>v1</strong>: numpy array of 3 float, a spanning vector of the plane</p></li>
<li><p><strong>v2</strong>: numpy array of 3 float, a spanning vector of the plane</p></li>
<li><p><strong>avec</strong>: numpy array of 3x3 float</p></li>
<li><p><strong>maxlen</strong>: float, longest accepted surface vector</p></li>
</ul>
</div></blockquote>
<p><em>return</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p>numpy array of 3 float, surface vector choice</p></li>
</ul>
</div></blockquote>
<p><a href="#id711"><span class="problematic" id="id712">**</span></a><a href="#id713"><span class="problematic" id="id714">*</span></a></p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="v3find.initialize_search">
<span class="sig-prename descclassname"><span class="pre">v3find.</span></span><span class="sig-name descname"><span class="pre">initialize_search</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">v1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">v2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">avec</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#v3find.initialize_search" title="Permalink to this definition"></a></dt>
<dd><p>Seed search for v3 with the nearest-neighbouring Bravais latice point which maximizes
the projection out of plane of that spanned by v1 and v2</p>
<p><em>args</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p><strong>v1</strong>: numpy array of 3 float, a spanning vector of the plane</p></li>
<li><p><strong>v2</strong>: numpy array of 3 float, a spanning vector of the plane</p></li>
<li><p><strong>avec</strong>: numpy array of 3x3 float</p></li>
</ul>
</div></blockquote>
<p><em>return</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p>numpy array of float, the nearby Bravais lattice point which maximizes</p></li>
</ul>
<blockquote>
<div><p>the projection along the plane normal</p>
</div></blockquote>
</div></blockquote>
<p><a href="#id715"><span class="problematic" id="id716">**</span></a><a href="#id717"><span class="problematic" id="id718">*</span></a></p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="v3find.refine_search">
<span class="sig-prename descclassname"><span class="pre">v3find.</span></span><span class="sig-name descname"><span class="pre">refine_search</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">v3i</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">v1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">v2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">avec</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">maxlen</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#v3find.refine_search" title="Permalink to this definition"></a></dt>
<dd><p>Refine the search for the optimal v3 which both minimalizes the length while
maximizing orthogonality to v1 and v2</p>
<p><em>args</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p><strong>v3i</strong>: numpy array of 3 float, initial guess for the surface vector</p></li>
<li><p><strong>v1</strong>: numpy array of 3 float, a spanning vector of the plane</p></li>
<li><p><strong>v2</strong>: numpy array of 3 float, a spanning vector of the plane</p></li>
<li><p><strong>avec</strong>: numpy array of 3x3 float</p></li>
<li><p><strong>maxlen</strong>: float, longest vector accepted</p></li>
</ul>
</div></blockquote>
<p><em>return</em>:</p>
<blockquote>
<div><p><strong>v3_opt</strong>: list of numpy array of 3 float, options for surface vector</p>
</div></blockquote>
<p><a href="#id719"><span class="problematic" id="id720">**</span></a><a href="#id721"><span class="problematic" id="id722">*</span></a></p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="v3find.score">
<span class="sig-prename descclassname"><span class="pre">v3find.</span></span><span class="sig-name descname"><span class="pre">score</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">vlist</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">v1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">v2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">avec</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#v3find.score" title="Permalink to this definition"></a></dt>
<dd><p>The possible surface vectors are scored based on their legnth and their orthogonality 
to the in-plane vectors.</p>
<p><em>args</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p><strong>vlist</strong>: list fo numpy array of 3 float, options for surface vector</p></li>
<li><p><strong>v1</strong>: numpy array of 3 float, a spanning vector of the plane</p></li>
<li><p><strong>v2</strong>: numpy array of 3 float, a spanning vector of the plane</p></li>
<li><p><strong>avec</strong>: numpy array of 3x3 float</p></li>
</ul>
</div></blockquote>
<p><em>return</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p>numpy array of 3 float, the best scoring vector option</p></li>
</ul>
</div></blockquote>
<p><a href="#id723"><span class="problematic" id="id724">**</span></a><a href="#id725"><span class="problematic" id="id726">*</span></a></p>
</dd></dl>

</section>
<section id="module-wigner">
<span id="wigner"></span><h2>wigner:<a class="headerlink" href="#module-wigner" title="Permalink to this heading"></a></h2>
<dl class="py function">
<dt class="sig sig-object py" id="wigner.Wd_denominator">
<span class="sig-prename descclassname"><span class="pre">wigner.</span></span><span class="sig-name descname"><span class="pre">Wd_denominator</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">j</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">m</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mp</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sp</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#wigner.Wd_denominator" title="Permalink to this definition"></a></dt>
<dd><p>Small function for computing the denominator in the s-summation, one step 
in defining the matrix elements of Wigner’s small d-matrix</p>
<p><em>args</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p><strong>j</strong>, <strong>m</strong>, <strong>mp</strong>: integer (or half-integer) angular momentum</p></li>
</ul>
<p>quantum numbers</p>
<ul class="simple">
<li><p><strong>s</strong>: int, the index of the summation</p></li>
</ul>
</div></blockquote>
<p><em>return</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p>int, product of factorials</p></li>
</ul>
</div></blockquote>
<p><a href="#id727"><span class="problematic" id="id728">**</span></a><a href="#id729"><span class="problematic" id="id730">*</span></a></p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="wigner.WignerD">
<span class="sig-prename descclassname"><span class="pre">wigner.</span></span><span class="sig-name descname"><span class="pre">WignerD</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">l</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Euler_A</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Euler_B</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Euler_y</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#wigner.WignerD" title="Permalink to this definition"></a></dt>
<dd><p>Full matrix representation of Wigner’s Big D matrix relating the rotation
of states within the subspace of the angular momentum l by the Euler rotation
Z”(A)-Y’(B)-Z(y)</p>
<p><em>args</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p><strong>l</strong>: int (or half integer) angular momentum</p></li>
<li><p><strong>Euler_A</strong>, <strong>Euler_B</strong>, <strong>Euler_y</strong>: float z-y-z Euler angles defining</p></li>
</ul>
<p>the rotation</p>
</div></blockquote>
<p><em>return</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p><strong>Dmat</strong>: 2j+1 x 2j+1 numpy array of complex float</p></li>
</ul>
</div></blockquote>
<p><a href="#id731"><span class="problematic" id="id732">**</span></a><a href="#id733"><span class="problematic" id="id734">*</span></a></p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="wigner.big_D_element">
<span class="sig-prename descclassname"><span class="pre">wigner.</span></span><span class="sig-name descname"><span class="pre">big_D_element</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">j</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mp</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">m</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Euler_A</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Euler_B</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Euler_y</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#wigner.big_D_element" title="Permalink to this definition"></a></dt>
<dd><p>Combining Wigner’s small d matrix with the other two rotations, this defines
Wigner’s big D matrix, which defines the projection of an angular momentum state
onto the other azimuthal projections of this angular momentum. Wigner defined 
these matrices in the convention of a set of z-y-z Euler angles, passed here 
along with the relevant quantum numbers:</p>
<p><em>args</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p><strong>j</strong>, <strong>mp</strong>, <strong>m</strong>: integer (half-integer) angular momentum quantum numbers</p></li>
<li><p><strong>Euler_A</strong>, <strong>Euler_B</strong>, <strong>Euler_y</strong>: float z-y-z Euler angles defining</p></li>
</ul>
<p>the rotation</p>
</div></blockquote>
<p><em>return</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p>complex float corresponding to the [mp,m] matrix element</p></li>
</ul>
</div></blockquote>
<p><a href="#id735"><span class="problematic" id="id736">**</span></a><a href="#id737"><span class="problematic" id="id738">*</span></a></p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="wigner.fact">
<span class="sig-prename descclassname"><span class="pre">wigner.</span></span><span class="sig-name descname"><span class="pre">fact</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">N</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#wigner.fact" title="Permalink to this definition"></a></dt>
<dd><p>Recursive factorial function for non-negative integers.</p>
<p><em>args</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p><strong>N</strong>: int, or int-like float</p></li>
</ul>
</div></blockquote>
<p><em>return</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p>factorial of <strong>N</strong></p></li>
</ul>
</div></blockquote>
<p><a href="#id739"><span class="problematic" id="id740">**</span></a><a href="#id741"><span class="problematic" id="id742">*</span></a></p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="wigner.s_lims">
<span class="sig-prename descclassname"><span class="pre">wigner.</span></span><span class="sig-name descname"><span class="pre">s_lims</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">j</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">m</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mp</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#wigner.s_lims" title="Permalink to this definition"></a></dt>
<dd><p>Limits for summation in definition of Wigner’s little d-matrix</p>
<p><em>args</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p><strong>j</strong>: int,(or half-integer) total angular momentum quantum number</p></li>
<li><p><strong>m</strong>: int, (or half-integer) initial azimuthal angular momentum quantum number</p></li>
<li><p><strong>mp</strong>: int, (or half-integer) final azimuthal angular momentum</p></li>
</ul>
<p>quantum number coupled to by rotation</p>
</div></blockquote>
<p><em>return</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p>list of int, viable candidates which result in well-defined factorials in</p></li>
</ul>
<p>summation</p>
</div></blockquote>
<p><a href="#id743"><span class="problematic" id="id744">**</span></a><a href="#id745"><span class="problematic" id="id746">*</span></a></p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="wigner.small_D">
<span class="sig-prename descclassname"><span class="pre">wigner.</span></span><span class="sig-name descname"><span class="pre">small_D</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">j</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mp</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">m</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Euler_B</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#wigner.small_D" title="Permalink to this definition"></a></dt>
<dd><dl class="simple">
<dt>Wigner’s little d matrix, defined as         _</dt><dd><p>j                                                    (-1)^(mp-m+s)                 2j+m-mp-2s         mp-m+2s</p>
</dd>
<dt>d    (B) = sqrt((j+mp)!(j-mp)!(j+m)!(j-m)!)  &gt;  —————————– cos(B/2)          sin(B/2)</dt><dd><p>mp,m                                       /_s  (j+m-s)!s!(mp-m+s)!(j-mp-s)!</p>
</dd>
</dl>
<p>where the sum over s includes all integers for which the factorial arguments in the denominator are non-negative.
The limits for this summation are defined by s_lims(j,m,mp).</p>
<p><em>args</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p><strong>j</strong>, <strong>mp</strong> ,**m** – integer (or half-integer) angular momentum</p></li>
</ul>
<p>quantum numbers for the orbital angular momentum, and its azimuthal projections
which are related by the Wigner D matrix during the rotation</p>
<ul class="simple">
<li><p><strong>Euler_B</strong>: float, angle of rotation in radians, for the y-rotation</p></li>
</ul>
</div></blockquote>
<p><em>return</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p>float representing the matrix element of Wigner’s small d-matrix</p></li>
</ul>
</div></blockquote>
<p><a href="#id747"><span class="problematic" id="id748">**</span></a><a href="#id749"><span class="problematic" id="id750">*</span></a></p>
</dd></dl>

</section>
<section id="module-Ylm">
<span id="ylm"></span><h2>Ylm:<a class="headerlink" href="#module-Ylm" title="Permalink to this heading"></a></h2>
<dl class="py function">
<dt class="sig sig-object py" id="Ylm.GramSchmidt">
<span class="sig-prename descclassname"><span class="pre">Ylm.</span></span><span class="sig-name descname"><span class="pre">GramSchmidt</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Ylm.GramSchmidt" title="Permalink to this definition"></a></dt>
<dd><p>Simple orthogonalization of two vectors, returns orthonormalized vector</p>
<p><em>args</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p><strong>a</strong>, <strong>b</strong>: numpy array of same length</p></li>
</ul>
</div></blockquote>
<p><em>returns</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p><strong>GS_a</strong>: numpy array of same size, orthonormalized to the b vector</p></li>
</ul>
</div></blockquote>
<p><a href="#id751"><span class="problematic" id="id752">**</span></a><a href="#id753"><span class="problematic" id="id754">*</span></a></p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="Ylm.Y">
<span class="sig-prename descclassname"><span class="pre">Ylm.</span></span><span class="sig-name descname"><span class="pre">Y</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">l</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">m</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">theta</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">phi</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Ylm.Y" title="Permalink to this definition"></a></dt>
<dd><p>Spherical harmonics, defined here up to l = 4. This allows for photoemission from
initial states up to and including f-electrons (final states can be d- or g- like).
Can be vectorized with numpy.vectorize() to allow array-like input</p>
<p><em>args</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p><strong>l</strong>: int orbital angular momentum, up to l=4 supported</p></li>
<li><p><strong>m</strong>: int, azimuthal angular momentum <a href="#id755"><span class="problematic" id="id756">|</span></a>m|&lt;=l</p></li>
<li><p><strong>theta</strong>: float, angle in spherical coordinates, radian measured from the z-axis [0,pi]</p></li>
<li><p><strong>phi</strong>: float, angle in spherical coordinates, radian measured from the x-axis [0,2pi]</p></li>
</ul>
</div></blockquote>
<p><em>return</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p>complex float, value of spherical harmonic evaluated at theta,phi</p></li>
</ul>
</div></blockquote>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="Ylm.Yproj">
<span class="sig-prename descclassname"><span class="pre">Ylm.</span></span><span class="sig-name descname"><span class="pre">Yproj</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">basis</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Ylm.Yproj" title="Permalink to this definition"></a></dt>
<dd><p>Define the unitary transformation rotating the basis of different inequivalent atoms in the
basis to the basis of spherical harmonics for sake of defining L.S operator in basis of user</p>
<p>29/09/2018 added reference to the spin character ‘sp’ to handle rotated systems effectively</p>
<p><em>args:</em></p>
<blockquote>
<div><ul class="simple">
<li><p><strong>basis</strong>: list of orbital objects</p></li>
</ul>
</div></blockquote>
<p><em>return</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p>dictionary of matrices for the different atoms and l-shells–keys are tuples of (atom,l)</p></li>
</ul>
</div></blockquote>
<p><a href="#id757"><span class="problematic" id="id758">**</span></a><a href="#id759"><span class="problematic" id="id760">*</span></a></p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="Ylm.binom">
<span class="sig-prename descclassname"><span class="pre">Ylm.</span></span><span class="sig-name descname"><span class="pre">binom</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Ylm.binom" title="Permalink to this definition"></a></dt>
<dd><p>Binomial coefficient for ‘a choose b’</p>
<p><em>args</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p><strong>a</strong>: int, positive</p></li>
<li><p><strong>b</strong>: int, positive</p></li>
</ul>
</div></blockquote>
<p><em>return</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p>float, binomial coefficient</p></li>
</ul>
</div></blockquote>
<p><a href="#id761"><span class="problematic" id="id762">**</span></a><a href="#id763"><span class="problematic" id="id764">*</span></a></p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="Ylm.fillin">
<span class="sig-prename descclassname"><span class="pre">Ylm.</span></span><span class="sig-name descname"><span class="pre">fillin</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">M</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">l</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Dmat</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Ylm.fillin" title="Permalink to this definition"></a></dt>
<dd><p>If only using a reduced subset of an orbital shell (for example, only t2g states in d-shell),
need to fill in the rest of the projection matrix with some defaults</p>
<p><em>args</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p><strong>M</strong>: numpy array of (2l+1)x(2l+1) complex float</p></li>
<li><p><strong>l</strong>: int</p></li>
<li><p><strong>Dmat</strong>: numpy array of (2l+1)x(2l+1) complex float</p></li>
</ul>
</div></blockquote>
<p><em>return</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p><strong>M</strong>: numpy arrayof (2l+1)x(2l+1) complex float</p></li>
</ul>
</div></blockquote>
<p><a href="#id765"><span class="problematic" id="id766">**</span></a><a href="#id767"><span class="problematic" id="id768">*</span></a></p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="Ylm.gaunt">
<span class="sig-prename descclassname"><span class="pre">Ylm.</span></span><span class="sig-name descname"><span class="pre">gaunt</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">l</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">m</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dl</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dm</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Ylm.gaunt" title="Permalink to this definition"></a></dt>
<dd><p>I prefer to avoid using the sympy library where possible, for speed reasons. These are the explicitly defined
Gaunt coefficients required for dipole-allowed transitions (dl = +/-1) for arbitrary m,l and dm
These have been tested against the sympy package to confirm numerical accuracy for all l,m possible
up to l=5. This function is equivalent, for the subset of dm, dl allowed to
sympy.physics.wigner.gaunt(l,1,l+dl,m,dm,-(m+dm))</p>
<p><em>args</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p><strong>l</strong>: int orbital angular momentum quantum number</p></li>
<li><p><strong>m</strong>: int azimuthal angular momentum quantum number</p></li>
<li><p><strong>dl</strong>: int change in l (+/-1)</p></li>
<li><p><strong>dm</strong>: int change in azimuthal angular momentum (-1,0,1)</p></li>
</ul>
</div></blockquote>
<p><em>return</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p>float Gaunt coefficient</p></li>
</ul>
</div></blockquote>
<p><a href="#id769"><span class="problematic" id="id770">**</span></a><a href="#id771"><span class="problematic" id="id772">*</span></a></p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="Ylm.laguerre">
<span class="sig-prename descclassname"><span class="pre">Ylm.</span></span><span class="sig-name descname"><span class="pre">laguerre</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">l</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">j</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Ylm.laguerre" title="Permalink to this definition"></a></dt>
<dd><p>Laguerre polynomial of order l, degree j, evaluated over x</p>
<p><em>args</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p><strong>x</strong>: float or numpy array of float, input</p></li>
<li><p><strong>l</strong>: int, order of polynomial</p></li>
<li><p><strong>j</strong>: int, degree of polynomial</p></li>
</ul>
</div></blockquote>
<p><em>return</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p><strong>laguerre_output</strong>: float or numpy array of float, shape as input <strong>x</strong></p></li>
</ul>
</div></blockquote>
<p><a href="#id773"><span class="problematic" id="id774">**</span></a><a href="#id775"><span class="problematic" id="id776">*</span></a></p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="Ylm.value_one">
<span class="sig-prename descclassname"><span class="pre">Ylm.</span></span><span class="sig-name descname"><span class="pre">value_one</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">theta</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">phi</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Ylm.value_one" title="Permalink to this definition"></a></dt>
<dd><p>Flexible generation of the number 1.0, in either float or array format</p>
<p><em>args</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p><strong>theta</strong>: float or numpy array of float</p></li>
<li><p><strong>phi</strong>: float or numpy array of float</p></li>
</ul>
</div></blockquote>
<p><em>return</em>:</p>
<blockquote>
<div><p><strong>out</strong>: float or numpy array of float, evaluated to 1.0, of same shape and type
as <strong>theta</strong>, <strong>phi</strong></p>
</div></blockquote>
<p><a href="#id777"><span class="problematic" id="id778">**</span></a><a href="#id779"><span class="problematic" id="id780">*</span></a></p>
</dd></dl>

</section>
</section>


           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2019, Ryan P. Day.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>