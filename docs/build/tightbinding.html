<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Tight Binding &mdash; chinook 1.0 documentation</title>
      <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
        <script src="_static/jquery.js"></script>
        <script src="_static/underscore.js"></script>
        <script src="_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script src="_static/doctools.js"></script>
        <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="_static/js/theme.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Model Diagnostics" href="operator.html" />
    <link rel="prev" title="ARPES Simulation" href="arpes.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="index.html">
            <img src="_static/chinook_header_logo.png" class="logo" alt="Logo"/>
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="introduction.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="arpes.html">ARPES Simulation</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Tight Binding</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#slater-koster-models">Slater-Koster Models:</a></li>
<li class="toctree-l2"><a class="reference internal" href="#hamiltonian-construction">Hamiltonian Construction:</a></li>
<li class="toctree-l2"><a class="reference internal" href="#executable-hamiltonians">Executable Hamiltonians:</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-build_lib">Model Initialization</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-H_library">Hamiltonian Library</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-klib">Momentum Library</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-orbital">Orbital Objects</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-SlaterKoster">Slater Koster Library</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-TB_lib">Tight-Binding Library</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="operator.html">Model Diagnostics</a></li>
<li class="toctree-l1"><a class="reference internal" href="slab.html">Slab Calculation</a></li>
<li class="toctree-l1"><a class="reference internal" href="support.html">Support Files</a></li>
<li class="toctree-l1"><a class="reference internal" href="input.html">Input Arguments</a></li>
<li class="toctree-l1"><a class="reference internal" href="tutorial.html">Tutorial</a></li>
<li class="toctree-l1"><a class="reference internal" href="license.html">License</a></li>
<li class="toctree-l1"><a class="reference internal" href="license.html#contact">Contact</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">chinook</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="index.html" class="icon icon-home"></a> &raquo;</li>
      <li>Tight Binding</li>
      <li class="wy-breadcrumbs-aside">
            <a href="_sources/tightbinding.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <div class="toctree-wrapper compound" id="tight-binding">
</div>
<section id="id1">
<h1>Tight Binding<a class="headerlink" href="#id1" title="Permalink to this heading"></a></h1>
<p>The user tight-binding model contains all relevant information regarding the orbital basis, the model Hamiltonian (in addition to eigenvalues/eigenvectors), as well as the momentum domain of interest. In addition, the tight-binding class contains all relevant methods required to extract this information.</p>
<p>The user has a reasonable amount of flexibility in the format which they would use to generate the model Hamiltonian. This is intended to accommodate various programs which can be used to generate a tight-binding Hamiltonian (for example Wannier90), as well as the different presentations used in publications (Slater-Koster <span class="math notranslate nohighlight">\(V_{lmk}\)</span> , <span class="math notranslate nohighlight">\(t_{ij}\)</span> ), as well as alternative Hamiltonian types, such as low-energy effective models which do not adhere to the full translational symmetry required by Bloch’s theorem. These latter models do however provide a highly useful and physically transparent parameterization of the system Hamiltonian for narrow regions of momentum space near high-symmetry points. For these reasons, there are 4 general categories of Hamiltonian inputs we accept. The first three are described as: <em>Slater-Koster</em>, <em>list</em>, and <em>text</em> input. The last is described generically as <em>executable</em>.</p>
<p>While in principal a tight-binding Hamiltonian can be passed in the acceptable form for any of the above, the last option also supports these low-energy theories described above.</p>
<section id="slater-koster-models">
<h2>Slater-Koster Models:<a class="headerlink" href="#slater-koster-models" title="Permalink to this heading"></a></h2>
<p>In their 1954 PRB paper, Slater and Koster presented a fairly simple framework for defining the tight-binding model associated with hoppings between localized atomic-like orbitals on neighbouring lattice sites. To define the overlap for a pair of basis states with orbital angular momentum <span class="math notranslate nohighlight">\(l_1\)</span> and <span class="math notranslate nohighlight">\(l_2\)</span> for an arbitrary lattice geometry, we require only <span class="math notranslate nohighlight">\((min( l_1, l_2 ) + 1)\)</span> parameters. For example, for <span class="math notranslate nohighlight">\(l_1=l_2=1\)</span> we define <span class="math notranslate nohighlight">\(V_{pp\sigma},\ V_{pp\pi}\)</span>. Intuitively, these parameters correspond to overlap integrals between the two orbitals when the lobes of the ‘p’ orbitals are aligned parallel to the connecting vector ( <span class="math notranslate nohighlight">\(\sigma\)</span>) and aligned perpendicular to the connecting vector ( <span class="math notranslate nohighlight">\(\pi\)</span> ). One can often use the frequently published table of Slater-Koster parameters to then define general rules for how these two parameters should be combined for a specific lattice geometry to arrive at the hopping amplitude between each pair of lattice sites.</p>
<p>This table is however restrictive as it provides rules for only hoppings between non-distorted cubic harmonics. One can alternatively take advantage of the representation of the orbital states in the basis of spherical harmonics <span class="math notranslate nohighlight">\(Y_{l}^{m}(\Omega)\)</span> to rotate an arbitrary pair of basis states into a common representation, and then rotate the frame of reference to align the bond-direction with a designated quantization axis: here the <span class="math notranslate nohighlight">\(\hat z\)</span> vector. A diagonal Hamiltonian matrix filled with the associated <span class="math notranslate nohighlight">\(V_{l_1l_2\gamma}\)</span> can then be applied. The rotation and basis transformation can be undone, ultimately producing a matrix of Hamiltonian parameters for the entire orbital shell along the designated bond vector. Mathematically, the procedure is represented by</p>
<div class="math notranslate nohighlight">
\[\left&lt;\psi|H|\phi\right&gt; = \left&lt;\psi| U^{\dagger} R^{-1}(\theta,\phi) V_{SK} R(\theta,\phi) U |\phi\right&gt;\]</div>
<p>This formalism then allows for fast and user-friendly generation of a Hamiltonian over an arbitrary basis and geometry. Given only the <span class="math notranslate nohighlight">\(V_{l_1,l_2,\gamma}\)</span> parameters and the lattice geometry, a full tight-binding Hamiltonian can be built.</p>
<p>The Slater-Koster parameters are passed in the form of a dictionary, with the keys taking the form of <span class="math notranslate nohighlight">\(a_1 a_2 n_1 n_2 l_1 l_2 \gamma\)</span>. For example, if I have two distinct atoms in my basis, where I have the Carbon 2p and Iron 3d <span class="math notranslate nohighlight">\(e_g\)</span> orbitals, the dictionary may look like shown here</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">V_SK</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;021&#39;</span><span class="p">:</span><span class="mf">3.0</span><span class="p">,</span><span class="s1">&#39;13XY&#39;</span><span class="p">:</span><span class="mf">0.0</span><span class="p">,</span><span class="s1">&#39;13ZR&#39;</span><span class="p">:</span><span class="o">-</span><span class="mf">0.5</span><span class="p">,</span>
<span class="s1">&#39;002211S&#39;</span><span class="p">:</span><span class="mf">1.0</span><span class="p">,</span><span class="s1">&#39;002211P&#39;</span><span class="p">:</span><span class="o">-</span><span class="mf">0.5</span><span class="p">,</span>
<span class="s1">&#39;012312S&#39;</span><span class="p">:</span><span class="mf">0.1</span><span class="p">,</span><span class="s1">&#39;012312P&#39;</span><span class="p">:</span><span class="mf">0.6</span><span class="p">,</span>
<span class="s1">&#39;113322S&#39;</span><span class="p">:</span><span class="mf">0.05</span><span class="p">,</span><span class="s1">&#39;113322P&#39;</span><span class="p">:</span><span class="mf">0.7</span><span class="p">,</span><span class="s1">&#39;113322D&#39;</span><span class="p">:</span><span class="o">-</span><span class="mf">0.03</span><span class="p">}</span>
</pre></div>
</div>
<p>In the first line I have written the on-site terms. While in a simple case I may have a single onsite energy for each orbital shell, here I have distinguished the onsite energy of the <span class="math notranslate nohighlight">\(d_{x^2-y^2}\)</span> and <span class="math notranslate nohighlight">\(d_{3z^2-r^2}\)</span> states. In the second-fourth lines, I have written the p-p, p-d, and d-d hopping amplitudes.</p>
<p>In many models, hopping beyond nearest neighbours are relevant, and will typically not have the same strength as the nearest neighbour terms. In these cases, we can pass a list of dictionaries to <em>H_dict</em>. For example</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">H_dict</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;type&#39;</span><span class="p">:</span><span class="s1">&#39;SK&#39;</span><span class="p">,</span>
                <span class="s1">&#39;V&#39;</span><span class="p">:[</span><span class="n">SK_dict1</span><span class="p">,</span><span class="n">SK_dict2</span><span class="p">],</span>
                <span class="s1">&#39;cutoff&#39;</span><span class="p">:[</span><span class="mf">3.5</span><span class="p">,</span><span class="mf">5.0</span><span class="p">],</span>
                <span class="o">...</span><span class="p">}</span>
</pre></div>
</div>
<p>To include these next-nearest neighbour terms, I specify a list of hopping dictionaries, in addition to a list of cutoff distances, indicating the range of connecting vectors each of the indicated dictionaries should apply to. For this case, for connecting vectors where <span class="math notranslate nohighlight">\(|R_{ij}|&lt;3.5\)</span> we use <em>SK_dict1</em>, whereas for <span class="math notranslate nohighlight">\(3.5\leq |R_{ij}|&lt;5.0\)</span> we use <em>SK_dict2</em>.</p>
</section>
<section id="hamiltonian-construction">
<h2>Hamiltonian Construction:<a class="headerlink" href="#hamiltonian-construction" title="Permalink to this heading"></a></h2>
<p>From these matrices, we proceed to build a list of <em>H_me</em> objects. This class is the standard representation of the Hamiltonian in <em>chinook</em>. Each instance of <em>H_me</em> carries integers labelling the associated basis indices. For example <span class="math notranslate nohighlight">\(\left&lt;\phi_3|H|\phi_7\right&gt;\)</span> will be stored with <em>H_me</em>.i = 3, <em>H_me</em>.j = 7. We note here that the Hermiticity of the Hamiltonian allows one to explicitly define only the upper or lower diagonal of the Hamiltonian. Consequently, in <em>chinook</em>, we use only the <em>upper</em> diagonal, that is <span class="math notranslate nohighlight">\(i\leq j\)</span>.</p>
<p>In addition to basis indices, the <em>H_me</em> object carries the functional information of the matrix element in its <em>H_me.H</em> attribute. This will be a list  of connecting vectors and hopping strengths in the case of a standard tight-binding model, or a list of python executables otherwise.</p>
<p>In standard format then one might have</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">TB</span><span class="o">.</span><span class="n">mat_els</span><span class="p">[</span><span class="mi">9</span><span class="p">]</span><span class="o">.</span><span class="n">i</span> <span class="o">=</span> <span class="mi">3</span>
<span class="n">TB</span><span class="o">.</span><span class="n">mat_els</span><span class="p">[</span><span class="mi">9</span><span class="p">]</span><span class="o">.</span><span class="n">j</span> <span class="o">=</span> <span class="mi">3</span>
<span class="n">TB</span><span class="o">.</span><span class="n">mat_els</span><span class="p">[</span><span class="mi">9</span><span class="p">]</span><span class="o">.</span><span class="n">H</span> <span class="o">=</span> <span class="p">[[</span><span class="mf">0.0</span><span class="p">,</span><span class="mf">0.0</span><span class="p">,</span><span class="mf">0.0</span><span class="p">,</span><span class="mf">2.0</span><span class="p">],</span>
                <span class="p">[</span><span class="mf">1.5</span><span class="p">,</span><span class="mf">0.0</span><span class="p">,</span><span class="mf">0.0</span><span class="p">,</span><span class="mf">3.7</span><span class="p">],</span>
                <span class="p">[</span><span class="o">-</span><span class="mf">1.5</span><span class="p">,</span><span class="mf">0.0</span><span class="p">,</span><span class="mf">0.0</span><span class="p">,</span><span class="mf">3.7</span><span class="p">]]</span>
</pre></div>
</div>
<p>This is the 10-th element in our model’s list <em>TB.mat_els</em> of <em>H_me</em> objects. This <em>H_me</em> instance contains an on-site term of strength 2.0, and a cosine-like hopping term along the <span class="math notranslate nohighlight">\(x\)</span> -axis of strength 3.7 eV. A closer consideration of the <em>H</em> attribute reveals the essential information. Each element of the list is a length-4 list of float, containing <span class="math notranslate nohighlight">\(\vec{R_{ij}^n}\)</span> and <span class="math notranslate nohighlight">\(t_{ij}^n\)</span>. Ultimately, the full matrix element will be expressed as</p>
<div class="math notranslate nohighlight">
\[H_{ij}(\vec{k}) = \sum_{n} t_{ij}^n e^{i\vec{k}\cdot\vec{R_{ij}^n}}\]</div>
<p>For this reason, if one does not have access to a suitable Slater-Koster representation of the tight-binding model, we can bypass the methods described above, passing a list of prepared matrix elements directly to the generator of the <em>H_me</em> objects. To accommodate this, we then also accept Hamiltonian input in the form of <em>list</em>, where each element of the list is written as for example</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Hlist</span><span class="p">[</span><span class="mi">10</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mf">1.5</span><span class="p">,</span><span class="mf">0.0</span><span class="p">,</span><span class="mf">0.0</span><span class="p">,</span><span class="mf">3.7</span><span class="p">]</span>
</pre></div>
</div>
<p>The elements then correspond to basis index 1, basis index 2, connecting vector x, y, and z components, and finally the <span class="math notranslate nohighlight">\(t_{ij}\)</span> value.
Similarly, a textfile of this form is also acceptable, with each line in the textfile being a comma-separated list of values</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mf">1.5</span><span class="p">,</span><span class="mf">0.0</span><span class="p">,</span><span class="mf">0.0</span><span class="p">,</span><span class="mf">3.7</span>
<span class="o">...</span>
</pre></div>
</div>
<p>A list of <em>H_me</em> objects can then be built as above.</p>
</section>
<section id="executable-hamiltonians">
<h2>Executable Hamiltonians:<a class="headerlink" href="#executable-hamiltonians" title="Permalink to this heading"></a></h2>
<p>The <em>executable</em> type Hamiltonian will ultimately require a slightly modified form of the input, as we do not intend to express the matrix elements as a Fourier transform of the real-space Hamiltonian in the same way as above.</p>
<p>In this form, we should have</p>
<div class="math notranslate nohighlight">
\[H_{ij}(\vec{k}) = \sum_{n} f_n(\vec{k})\]</div>
<p>This then requires a modified form of <em>H_me.H</em>. By contrast with the above,</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">TB</span><span class="o">.</span><span class="n">mat_els</span><span class="p">[</span><span class="mi">9</span><span class="p">]</span><span class="o">.</span><span class="n">H</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">,</span><span class="n">my_hopping_func</span><span class="p">]</span>
</pre></div>
</div>
<p>where <em>my_hopping_func</em> is a user-defined executable. It could be for example a 2nd order polynomial, or any other function of momentum. The essential point is that the executables <em>must</em> take an Nx3 array of float as their only argument. This allows for these Hamiltonians to fit seamlessly into the <em>chinook</em> framework.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Automated tools for building these Hamiltonians are currently in the process of being built. Proceed with caution, and notify the developers of any unexpected performance.</p>
</div>
<p>For advanced users who would like to take advantage of this functionality now,</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">H_dict</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;type&#39;</span><span class="p">:</span><span class="s1">&#39;exec&#39;</span><span class="p">,</span>
                <span class="s1">&#39;exec&#39;</span><span class="p">:</span><span class="n">exec_list</span><span class="p">,</span>
                <span class="o">...</span><span class="p">}</span>
</pre></div>
</div>
<p>where the item</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">exec_list</span> <span class="o">=</span> <span class="p">[[(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span><span class="n">my_func1</span><span class="p">],</span>
<span class="p">[(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span><span class="n">my_func2</span><span class="p">],</span>
<span class="o">...</span><span class="p">]</span>
</pre></div>
</div>
<p>The tuple of integers preceding the name of the executable corresponds to the basis indices. Here <em>my_func1</em> applies to the diagonal elements of my first basis member, and <em>my_func2</em> to the coupling of my first and second basis elements. As always, indexing in python is 0-based.</p>
<p>For the construction of the executable functions, we recommend the use of python’s <em>lambda</em> functions. For example, to define a function which evaluates to <span class="math notranslate nohighlight">\(\alpha k_x^2 + \beta k_y^2\)</span> , one may define</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">my_func_generator</span><span class="p">(</span><span class="n">alpha</span><span class="p">,</span><span class="n">beta</span><span class="p">):</span>
        <span class="k">return</span> <span class="k">lambda</span> <span class="n">kvec</span><span class="p">:</span> <span class="n">alpha</span><span class="o">*</span><span class="n">k</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">beta</span><span class="o">*</span><span class="n">k</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span>

<span class="c1">#Define specific parameters for my executable functions</span>
<span class="n">a1</span> <span class="o">=</span> <span class="mf">2.3</span>
<span class="n">b1</span> <span class="o">=</span> <span class="mf">0.7</span>

<span class="n">a2</span> <span class="o">=</span> <span class="mf">5.6</span>
<span class="n">b2</span> <span class="o">=</span> <span class="mf">0.9</span>

<span class="c1">#Define my executables</span>
<span class="n">my_func1</span> <span class="o">=</span> <span class="n">my_func_generator</span><span class="p">(</span><span class="n">a1</span><span class="p">,</span><span class="n">b1</span><span class="p">)</span>
<span class="n">my_func2</span> <span class="o">=</span> <span class="n">my_func_generator</span><span class="p">(</span><span class="n">a2</span><span class="p">,</span><span class="n">b2</span><span class="p">)</span>

<span class="c1">#Populate a list of executables</span>
<span class="n">exec_list</span> <span class="o">=</span> <span class="p">[[(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span><span class="n">my_func1</span><span class="p">],</span>
<span class="p">[(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span><span class="n">my_func2</span><span class="p">]]</span>
</pre></div>
</div>
<p>Please stay tuned for further developments which will facilitate more convenient construction of these Hamiltonians.</p>
<p>Below, we include the relevant documentation to the construction of tight-binding models.</p>
</section>
<section id="module-build_lib">
<span id="model-initialization"></span><h2>Model Initialization<a class="headerlink" href="#module-build_lib" title="Permalink to this heading"></a></h2>
<dl class="py function">
<dt class="sig sig-object py" id="build_lib.gen_K">
<span class="sig-prename descclassname"><span class="pre">build_lib.</span></span><span class="sig-name descname"><span class="pre">gen_K</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">Kdic</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#build_lib.gen_K" title="Permalink to this definition"></a></dt>
<dd><p>Generate k-path for TB model to be diagonalized along.</p>
<p><em>args</em>:</p>
<blockquote>
<div><ul>
<li><p><strong>Kdic</strong>: dictionary for generation of kpath with:</p>
<blockquote>
<div><ul class="simple">
<li><p><em>‘type’</em>: string ‘A’ (absolute) or ‘F’ (fractional) units</p></li>
<li><p><em>‘avec’</em>: numpy array of 3x3 float lattice vectors</p></li>
<li><p><em>‘pts’</em>: list of len3 array indicating the high-symmetry points</p></li>
</ul>
<p>along the path of interest</p>
<ul class="simple">
<li><p><em>‘grain’</em>: int, number of points between <em>each</em> element of <em>‘pts’</em></p></li>
</ul>
<p>optional:</p>
<blockquote>
<div><ul class="simple">
<li><p><em>‘labels’</em>:list of strings with same length as <em>‘pts’</em>, giving</p></li>
</ul>
<p>plotting labels for the kpath</p>
</div></blockquote>
</div></blockquote>
</li>
</ul>
</div></blockquote>
<p><em>return</em>:</p>
<blockquote>
<div><p><strong>Kobj</strong>: K-object including necessary attributes to be read by the <strong>TB_model</strong></p>
</div></blockquote>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="build_lib.gen_TB">
<span class="sig-prename descclassname"><span class="pre">build_lib.</span></span><span class="sig-name descname"><span class="pre">gen_TB</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">basis_dict</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">hamiltonian_dict</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Kobj</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">slab_dict</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#build_lib.gen_TB" title="Permalink to this definition"></a></dt>
<dd><p>Build a Tight-Binding Model using the user-input dictionaries</p>
<p><em>args</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p><strong>basis_dict</strong>: dictionary, including the <em>‘bulk’</em> key value pair</p></li>
</ul>
<p>generated by <strong>gen_basis</strong></p>
<ul>
<li><p><strong>hamiltonian_dict</strong>: dictionary,</p>
<blockquote>
<div><ul class="simple">
<li><p><em>‘spin’</em>: same dictionary as passed to <strong>gen_basis</strong></p></li>
<li><p><em>‘type’</em>: string, Hamiltonian type–‘list’ (list of matrix elements),</p></li>
</ul>
<p>‘SK’ (Slater-Koster dictionaries, requires also a ‘V’ and ‘avec’ entry),
‘txt’ (textfile, requires a ‘filename’ key as well)</p>
<ul class="simple">
<li><p><em>‘cutoff’</em>: float, cutoff hopping distance</p></li>
<li><p><em>‘renorm’</em>: optional float, renormalization factor default to 1.0</p></li>
<li><p><em>‘offset’</em>: optional float, offset of chemical potential, default to 0.0</p></li>
<li><p><em>‘tol’</em>: optional float, minimum matrix element tolerance, default to 1e-15</p></li>
</ul>
</div></blockquote>
</li>
<li><p><strong>Kobj</strong>: optional, standard K-object, as generated by <strong>gen_K</strong></p></li>
<li><p><strong>slab_dict</strong>: dictionary for slab generation</p>
<blockquote>
<div><ul class="simple">
<li><p><em>‘avec’</em>: numpy array of 3x3 float, lattice vectors</p></li>
<li><p><em>‘miller’</em>: numpy array of 3 integers, indicating the Miller</p></li>
</ul>
<p>index of the surface normal in units of lattice vectors</p>
<ul class="simple">
<li><p><em>‘fine’</em>: fine adjustment of the slab thickness, tuple of two</p></li>
</ul>
<p>numeric to get desired termination correct (for e.g. inversion symmetry)</p>
<ul class="simple">
<li><p><em>‘thick’</em>: integer approximate number of unit cells in the</p></li>
</ul>
<p>slab (will not be exact, depending on the fine, and termination</p>
<ul class="simple">
<li><p><em>‘vac’</em>: int size of the vacuum buffer – must be larger than</p></li>
</ul>
<p>the largest hopping length to ensure no coupling of slabs</p>
<ul class="simple">
<li><p><em>‘termination’</em>: tuple of 2 integers: atom indices which</p></li>
</ul>
<p>terminate the top and bottom of the slab</p>
</div></blockquote>
</li>
</ul>
</div></blockquote>
<p><em>return</em>:</p>
<blockquote>
<div><p><strong>TB_model</strong>: tight-binding object, as defined in <strong>chinook.TB_lib.py</strong></p>
</div></blockquote>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="build_lib.gen_basis">
<span class="sig-prename descclassname"><span class="pre">build_lib.</span></span><span class="sig-name descname"><span class="pre">gen_basis</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">basis</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#build_lib.gen_basis" title="Permalink to this definition"></a></dt>
<dd><p>Generate a list of orbital objects as the input basis for a tight-binding model.
User passes a basis dictionary, function returns a modified version of this
same dictionary, with the list of orbitals now appended as the <em>‘bulk’</em> entry</p>
<p><em>args</em>:</p>
<blockquote>
<div><ul>
<li><p><strong>basis</strong>–dictionary with keys:</p>
<blockquote>
<div><ul class="simple">
<li><p><em>‘atoms’</em>: list of integer, indices for distinct atoms,</p></li>
<li><p><em>‘Z’</em>: dictionary of integer: <em>‘atom’</em>:element (integer) pairs</p></li>
<li><p><em>‘orbs’</em>: list of lists of string, for each atom containing the</p></li>
</ul>
<p>orbital labels (usually in conventional nlxx format)),</p>
<ul class="simple">
<li><p><em>‘pos’</em>: list of numpy arrays of length 3 float indicating</p></li>
</ul>
<p>positions of the atoms in direct Angstrom units,</p>
<ul>
<li><p>optional keys:</p>
<blockquote>
<div><ul class="simple">
<li><p><em>‘orient’</em>: list, one entry for each atom, indicating a</p></li>
</ul>
<p>local rotation of the indicated atom, various formats accepted; 
for more details, c.f. <strong>chinook.orbital.py</strong></p>
<ul>
<li><p><em>‘spin’</em>: dictionary of spin information:</p>
<blockquote>
<div><ul class="simple">
<li><p><em>‘bool’</em>: boolean, double basis into spinor basis,</p></li>
<li><p><em>‘soc’</em>: boolean, include spin-orbit coupling</p></li>
<li><p><em>‘lam’</em>: dictionary of SOC constants, integer:float</p></li>
</ul>
<p>pairs for atoms in <em>‘atoms’</em> list, and lambda_SOC in eV</p>
</div></blockquote>
</li>
</ul>
</div></blockquote>
</li>
</ul>
</div></blockquote>
</li>
</ul>
</div></blockquote>
<p><em>return</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p><strong>basis</strong> dictionary, modified to include the <strong>bulk</strong> list of orbital</p></li>
</ul>
<p>objects</p>
</div></blockquote>
<p><a href="#id2"><span class="problematic" id="id3">**</span></a><a href="#id4"><span class="problematic" id="id5">*</span></a></p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="build_lib.recur_product">
<span class="sig-prename descclassname"><span class="pre">build_lib.</span></span><span class="sig-name descname"><span class="pre">recur_product</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">elements</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#build_lib.recur_product" title="Permalink to this definition"></a></dt>
<dd><p>Utility function: Recursive evaluation of the product of all elements in a list</p>
<p><em>args</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p><strong>elements</strong>: list of numeric type</p></li>
</ul>
</div></blockquote>
<p><em>return</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p>product of all elements of <strong>elements</strong></p></li>
</ul>
</div></blockquote>
<p><a href="#id6"><span class="problematic" id="id7">**</span></a><a href="#id8"><span class="problematic" id="id9">*</span></a></p>
</dd></dl>

</section>
<section id="module-H_library">
<span id="hamiltonian-library"></span><h2>Hamiltonian Library<a class="headerlink" href="#module-H_library" title="Permalink to this heading"></a></h2>
<dl class="py function">
<dt class="sig sig-object py" id="H_library.AFM_order">
<span class="sig-prename descclassname"><span class="pre">H_library.</span></span><span class="sig-name descname"><span class="pre">AFM_order</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">basis</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dS</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">p_up</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">p_dn</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#H_library.AFM_order" title="Permalink to this definition"></a></dt>
<dd><p>Add antiferromagnetism to the tight-binding model, by adding a different on-site energy to 
orbitals of different spin character, on the designated sites.</p>
<p><em>args</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p><strong>basis</strong>: list, orbital objects</p></li>
<li><p><strong>dS</strong>: float, size of spin-splitting (eV)</p></li>
<li><p><strong>p_up</strong>, <strong>p_dn</strong>: numpy array of float indicating the orbital positions</p></li>
</ul>
<p>for the AFM order</p>
</div></blockquote>
<p><em>return</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p><strong>h_AF</strong>: list of matrix elements, as conventionally arranged [[o1,o2,0,0,0,H12],…]</p></li>
</ul>
</div></blockquote>
<p><a href="#id10"><span class="problematic" id="id11">**</span></a><a href="#id12"><span class="problematic" id="id13">*</span></a></p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="H_library.FM_order">
<span class="sig-prename descclassname"><span class="pre">H_library.</span></span><span class="sig-name descname"><span class="pre">FM_order</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">basis</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dS</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#H_library.FM_order" title="Permalink to this definition"></a></dt>
<dd><p>Add ferromagnetism to the system. Take dS to assume that the splitting puts 
spin-up lower in energy by dS,and viceversa for spin-down. This directly
modifies the <em>TB_model</em>’s <strong>mat_els</strong> attribute</p>
<p><em>args</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p><strong>basis</strong>: list, of orbital objects in basis</p></li>
<li><p><strong>dS</strong>: float, energy of the spin splitting (eV)</p></li>
</ul>
</div></blockquote>
<p><em>return</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p>list of matrix elements [[o1,o2,0,0,0,H12],…]</p></li>
</ul>
</div></blockquote>
<p><a href="#id14"><span class="problematic" id="id15">**</span></a><a href="#id16"><span class="problematic" id="id17">*</span></a></p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="H_library.Lm">
<span class="sig-prename descclassname"><span class="pre">H_library.</span></span><span class="sig-name descname"><span class="pre">Lm</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">l</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#H_library.Lm" title="Permalink to this definition"></a></dt>
<dd><p>L- operator in the l,m_l basis, organized with 
(0,0) = <a href="#id18"><span class="problematic" id="id19">|</span></a>l,l&gt;… (2l,2l) = <a href="#id20"><span class="problematic" id="id21">|</span></a>l,-l&gt;</p>
<p>The nonzero elements are on the upper diagonal</p>
<p><em>arg</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p><strong>l</strong>: int orbital angular momentum</p></li>
</ul>
</div></blockquote>
<p><em>return</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p><strong>M</strong>: numpy array (2l+1,2l+1) of real float</p></li>
</ul>
</div></blockquote>
<p><a href="#id22"><span class="problematic" id="id23">**</span></a><a href="#id24"><span class="problematic" id="id25">*</span></a></p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="H_library.Lp">
<span class="sig-prename descclassname"><span class="pre">H_library.</span></span><span class="sig-name descname"><span class="pre">Lp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">l</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#H_library.Lp" title="Permalink to this definition"></a></dt>
<dd><p>L+ operator in the <span class="math notranslate nohighlight">\(l\)</span>, <span class="math notranslate nohighlight">\(m_l\)</span> basis, organized with 
(0,0) = <a href="#id26"><span class="problematic" id="id27">|</span></a>l,l&gt;… (2l,2l) = <a href="#id28"><span class="problematic" id="id29">|</span></a>l,-l&gt;
The nonzero elements are on the upper diagonal</p>
<p><em>arg</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p><strong>l</strong>: int orbital angular momentum</p></li>
</ul>
</div></blockquote>
<p><em>return</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p><strong>M</strong>: numpy array (2l+1,2l+1) of real float</p></li>
</ul>
</div></blockquote>
<p><a href="#id30"><span class="problematic" id="id31">**</span></a><a href="#id32"><span class="problematic" id="id33">*</span></a></p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="H_library.Lz">
<span class="sig-prename descclassname"><span class="pre">H_library.</span></span><span class="sig-name descname"><span class="pre">Lz</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">l</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#H_library.Lz" title="Permalink to this definition"></a></dt>
<dd><p>Lz operator in the l,:math:<cite>m_l</cite> basis</p>
<p><em>arg</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p><strong>l</strong>: int orbital angular momentum</p></li>
</ul>
</div></blockquote>
<p><em>return</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p>numpy array (2*l+1,2*l+1)</p></li>
</ul>
</div></blockquote>
<p><a href="#id34"><span class="problematic" id="id35">**</span></a><a href="#id36"><span class="problematic" id="id37">*</span></a></p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="H_library.SO">
<span class="sig-prename descclassname"><span class="pre">H_library.</span></span><span class="sig-name descname"><span class="pre">SO</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">basis</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#H_library.SO" title="Permalink to this definition"></a></dt>
<dd><p>Generate L.S  matrix-elements for a given basis. 
This is generic to all l, except the normal_order, which is defined here up to 
and including the f electrons.
Otherwise, this method is generic to any orbital angular momentum.</p>
<p>In the factors dictionary defined here indicates the weight of the 
different <span class="math notranslate nohighlight">\(L_iS_i\)</span> terms. The keys are tuples of (L+/-/z,S+/-/z)
in a bit of a cryptic way: for L, (0,1,2) -&gt;(-1,0,1) and
for S, (-1,0,1) = S1-S2 with S1,2 = +/- 1 here</p>
<p>L+,L-,Lz matrices are defined for each l shell in the basis, 
transformed into the basis of the tight-binding model.
The nonzero terms will then just be used along with the spin and
weighted by the factor value, and slotted into a len(<strong>basis</strong>)xlen(<strong>basis</strong>) matrix <strong>HSO</strong></p>
<p><em>args</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p><strong>basis</strong>: list of orbital objects</p></li>
</ul>
</div></blockquote>
<p><em>return</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p><strong>HSO</strong>: list of matrix elements in standard format [o1,o2,0,0,0,H12]</p></li>
</ul>
</div></blockquote>
<p><a href="#id38"><span class="problematic" id="id39">**</span></a><a href="#id40"><span class="problematic" id="id41">*</span></a></p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="H_library.Vlist_gen">
<span class="sig-prename descclassname"><span class="pre">H_library.</span></span><span class="sig-name descname"><span class="pre">Vlist_gen</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">V</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pair</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#H_library.Vlist_gen" title="Permalink to this definition"></a></dt>
<dd><p>Select the relevant hopping matrix elements to be used in defining the value
of the Slater-Koster matrix elements for a given pair of orbitals. Handles situation where
insufficient parameters have been passed to system.</p>
<p><em>args</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p><strong>V</strong>: dictionary of Slater-Koster hopping terms</p></li>
<li><p><strong>pair</strong>: tuple of int defining the orbitals to be paired, (a1,a2,n1,n2,l1,l2)</p></li>
</ul>
</div></blockquote>
<p><em>return</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p><strong>Vvals</strong>: numpy array of Vllx related to a given pairing, e.g. for s-p np.array([Vsps,Vspp])</p></li>
</ul>
</div></blockquote>
<p><a href="#id42"><span class="problematic" id="id43">**</span></a><a href="#id44"><span class="problematic" id="id45">*</span></a></p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="H_library.cluster_init">
<span class="sig-prename descclassname"><span class="pre">H_library.</span></span><span class="sig-name descname"><span class="pre">cluster_init</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">Vdict</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cutoff</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">avec</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#H_library.cluster_init" title="Permalink to this definition"></a></dt>
<dd><p>Generate a cluster of neighbouring lattice points to use
in defining the hopping paths–ensuring that it extends
sufficiently far enough to capture even the largest hopping vectors.
Also reforms the SK dictionary and cutoff lengths to be in list format.
Returns an array of lattice points which go safely to the edge of the cutoff range.</p>
<p><em>args</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p><strong>Vdict</strong>: dictionary, or list of dictionaries of Slater Koster matrix elements</p></li>
<li><p><strong>cutoff</strong>: float, or list of float</p></li>
<li><p><strong>avec</strong>: numpy array of 3x3 float</p></li>
</ul>
</div></blockquote>
<p><em>return</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p><strong>Vdict</strong>: list of length 1 if a single dictionary passed, else unmodified</p></li>
<li><p><strong>cutoff</strong>: numpy array, append 0 to the beginning of the cutoff list,</p></li>
</ul>
<p>else leave it alone.</p>
<ul class="simple">
<li><p><strong>pts</strong>: numpy array of lattice vector indices for a region of lattice points around</p></li>
</ul>
<p>the origin.</p>
</div></blockquote>
<p><a href="#id46"><span class="problematic" id="id47">**</span></a><a href="#id48"><span class="problematic" id="id49">*</span></a></p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="H_library.index_ordering">
<span class="sig-prename descclassname"><span class="pre">H_library.</span></span><span class="sig-name descname"><span class="pre">index_ordering</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">basis</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#H_library.index_ordering" title="Permalink to this definition"></a></dt>
<dd><p>We use an universal ordering convention for defining the Slater-Koster matrices
which may (and most likely will) not match the ordering chosen by the user.
To account for this, we define a dictionary which gives the ordering, relative 
to the normal order convention defined here, associated with a given a-n-l shell
at each site in the lattice basis.</p>
<p><em>args</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p><strong>basis</strong>: list of orbital objects</p></li>
</ul>
</div></blockquote>
<p><em>return</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p><strong>indexing</strong>: dictionary of key-value pairs (a,n,l,x,y,z):numpy.array([…])</p></li>
</ul>
</div></blockquote>
<p><a href="#id50"><span class="problematic" id="id51">**</span></a><a href="#id52"><span class="problematic" id="id53">*</span></a></p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="H_library.mat_els">
<span class="sig-prename descclassname"><span class="pre">H_library.</span></span><span class="sig-name descname"><span class="pre">mat_els</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">Rij</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">SKmat</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tol</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">i1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">i2</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#H_library.mat_els" title="Permalink to this definition"></a></dt>
<dd><p>Extract the pertinent, and non-zero elements of the Slater-Koster matrix
and transform to the conventional form of Hamiltonian list entries
(o1,o2,Rij0,Rij1,Rij2,H12(Rij))</p>
<p><em>args</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p><strong>Rij</strong>: numpy array of 3 float, relevant connecting vector</p></li>
<li><p><strong>SKmat</strong>: numpy array of float, matrix of hopping elements</p></li>
</ul>
<p>for the coupling of two orbital shells</p>
<ul class="simple">
<li><p><strong>tol</strong>: float, minimum hopping included in model</p></li>
<li><p><strong>i1</strong>, <strong>i2</strong>: int,int, proper index ordering for the relevant</p></li>
</ul>
<p>instance of the orbital shells involved in hopping</p>
</div></blockquote>
<p><em>return</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p><strong>out</strong>: list of Hamiltonian matrix elements, extracted from the</p></li>
</ul>
<p>ordered SKmat, in form [[o1,o2,x12,y12,z12,H12],…]</p>
</div></blockquote>
<p><a href="#id54"><span class="problematic" id="id55">**</span></a><a href="#id56"><span class="problematic" id="id57">*</span></a></p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="H_library.mirror_SK">
<span class="sig-prename descclassname"><span class="pre">H_library.</span></span><span class="sig-name descname"><span class="pre">mirror_SK</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">SK_in</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#H_library.mirror_SK" title="Permalink to this definition"></a></dt>
<dd><p>Generate a list of values which is the input appended with its mirror 
reflection. The mirror boundary condition suppresses the duplicate of the
last value. e.g. [0,1,2,3,4] –&gt; [0,1,2,3,4,3,2,1,0], 
[‘r’,’a’,’c’,’e’,’c’,’a’,’r’] –&gt; [‘r’,’a’,’c’,’e’,’c’,’a’,’r’,’a’,’c’,’e’,’c’,’a’,’r’]
Intended here to take an array of Slater-Koster hopping terms and reflect about 
its last entry i.e. [Vsps,Vspp] -&gt; [Vsps,Vspp,Vsps]</p>
<p><em>args</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p><strong>SK_in</strong>: iterable, of arbitrary length and data-type</p></li>
</ul>
</div></blockquote>
<p><em>return</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p>list of values with same data-type as input</p></li>
</ul>
</div></blockquote>
<p><a href="#id58"><span class="problematic" id="id59">**</span></a><a href="#id60"><span class="problematic" id="id61">*</span></a></p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="H_library.on_site">
<span class="sig-prename descclassname"><span class="pre">H_library.</span></span><span class="sig-name descname"><span class="pre">on_site</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">basis</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">V</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">offset</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#H_library.on_site" title="Permalink to this definition"></a></dt>
<dd><p>On-site matrix element calculation. Try both anl and alabel formats,
if neither is defined, default the onsite energy to 0.0 eV</p>
<p><em>args</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p><strong>basis</strong>: list of orbitals defining the tight-binding basis</p></li>
<li><p><strong>V</strong>: dictionary, Slater Koster terms</p></li>
<li><p><strong>offset</strong>: float, EF shift</p></li>
</ul>
</div></blockquote>
<p><em>return</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p><strong>Ho</strong>: list of Hamiltonian matrix elements</p></li>
</ul>
</div></blockquote>
<p><a href="#id62"><span class="problematic" id="id63">**</span></a><a href="#id64"><span class="problematic" id="id65">*</span></a></p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="H_library.region">
<span class="sig-prename descclassname"><span class="pre">H_library.</span></span><span class="sig-name descname"><span class="pre">region</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">num</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#H_library.region" title="Permalink to this definition"></a></dt>
<dd><p>Generate a symmetric grid of points in number of lattice vectors.</p>
<p><em>args</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p><strong>num</strong>: int, grid will have size 2*num+1 in each direction</p></li>
</ul>
</div></blockquote>
<p><em>return</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p>numpy array of size ((2*num+1)**3,3) with centre value of first entry</p></li>
</ul>
<p>of (-num,-num,-num),…,(0,0,0),…,(num,num,num)</p>
</div></blockquote>
<p><a href="#id66"><span class="problematic" id="id67">**</span></a><a href="#id68"><span class="problematic" id="id69">*</span></a></p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="H_library.sk_build">
<span class="sig-prename descclassname"><span class="pre">H_library.</span></span><span class="sig-name descname"><span class="pre">sk_build</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">avec</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">basis</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Vdict</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cutoff</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tol</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">renorm</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">offset</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#H_library.sk_build" title="Permalink to this definition"></a></dt>
<dd><p>Build SK model from using D-matrices, rather than a list of SK terms from table.
This can handle orbitals of arbitrary orbital angular momentum in principal, 
but right now implemented for up to and including f-electrons. 
NOTE: f-hoppings require thorough testing</p>
<p><em>args</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p><strong>avec</strong>: numpy array 3x3 float, lattice vectors</p></li>
<li><p><strong>basis</strong>: list of orbital objects</p></li>
<li><p><strong>Vdict</strong>: dictionary, or list of dictionaries, of Slater-Koster integrals/ on-site energies</p></li>
<li><p><strong>cutoff</strong>: float or list of float, indicating range where Vdict is applicable</p></li>
<li><p><strong>tol</strong>: float, threshold value below which hoppings are neglected</p></li>
<li><p><strong>offset</strong>: float, offset for Fermi level</p></li>
</ul>
</div></blockquote>
<p><em>return</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p><strong>H_raw</strong>: list of Hamiltonian matrix elements, in form [o1,o2,x12,y12,z12,t12]</p></li>
</ul>
</div></blockquote>
<p><a href="#id70"><span class="problematic" id="id71">**</span></a><a href="#id72"><span class="problematic" id="id73">*</span></a></p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="H_library.spin_double">
<span class="sig-prename descclassname"><span class="pre">H_library.</span></span><span class="sig-name descname"><span class="pre">spin_double</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">H</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lb</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#H_library.spin_double" title="Permalink to this definition"></a></dt>
<dd><p>Duplicate the kinetic Hamiltonian terms to extend over the spin-duplicated 
orbitals, which are by construction in same order and appended to end of the
original basis.</p>
<p><em>args</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p><strong>H</strong>: list, Hamiltonian matrix elements [[o1,o2,x,y,z,H12],…]</p></li>
<li><p><strong>lb</strong>: int, length of basis before spin duplication</p></li>
</ul>
</div></blockquote>
<p><em>return</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p><strong>h2</strong> modified copy of <strong>H</strong>, filled with kinetic terms for both</p></li>
</ul>
<p>spin species</p>
</div></blockquote>
<p><a href="#id74"><span class="problematic" id="id75">**</span></a><a href="#id76"><span class="problematic" id="id77">*</span></a></p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="H_library.txt_build">
<span class="sig-prename descclassname"><span class="pre">H_library.</span></span><span class="sig-name descname"><span class="pre">txt_build</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">filename</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cutoff</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">renorm</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">offset</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tol</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Nonsite</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#H_library.txt_build" title="Permalink to this definition"></a></dt>
<dd><p>Build Hamiltonian from textfile, input is of form
o1,o2,x12,y12,z12,t12, output in form [o1,o2,x12,y12,z12,t12]. 
To be explicit, each row of the textfile is used to generate a
k-space Hamiltonian matrix element of the form:</p>
<div class="math notranslate nohighlight">
\[H_{1,2}(k) = t_{1,2} e^{i (k_x x_{1,2} + k_y y_{1,2} + k_z z_{1,2})}\]</div>
<p><em>args</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p><strong>filename</strong>: string, name of file</p></li>
<li><p><strong>cutoff</strong>: float, maximum distance of hopping allowed, Angstrom</p></li>
<li><p><strong>renorm</strong>: float, renormalization of the bandstructure</p></li>
<li><p><strong>offset</strong>: float, energy offset of chemical potential, electron volts</p></li>
<li><p><strong>tol</strong>: float, minimum Hamiltonian matrix element amplitude</p></li>
<li><p><strong>Nonsite</strong>: int, number of basis states, use to apply <strong>offset</strong></p></li>
</ul>
</div></blockquote>
<p><em>return</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p><strong>Hlist</strong>: the list of Hamiltonian matrix elements</p></li>
</ul>
</div></blockquote>
<p><a href="#id78"><span class="problematic" id="id79">**</span></a><a href="#id80"><span class="problematic" id="id81">*</span></a></p>
</dd></dl>

</section>
<section id="module-klib">
<span id="momentum-library"></span><h2>Momentum Library<a class="headerlink" href="#module-klib" title="Permalink to this heading"></a></h2>
<dl class="py function">
<dt class="sig sig-object py" id="klib.b_zone">
<span class="sig-prename descclassname"><span class="pre">klib.</span></span><span class="sig-name descname"><span class="pre">b_zone</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a_vec</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">N</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">show</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#klib.b_zone" title="Permalink to this definition"></a></dt>
<dd><p>Generate a mesh of points over the Brillouin zone. 
Each of the cardinal axes are divided by the same number of points 
(so points are not necessarily evenly spaced along each axis).</p>
<dl class="simple">
<dt><em>args</em>:</dt><dd><ul class="simple">
<li><p><strong>a_vec</strong>: numpy array of size 3x3 float</p></li>
<li><p><strong>N</strong>: int mesh density</p></li>
</ul>
</dd>
<dt><em>kwargs</em>:     </dt><dd><ul class="simple">
<li><p><strong>show</strong>: boolean for optional plotting of the mesh points</p></li>
</ul>
</dd>
<dt><em>return</em>:</dt><dd><ul class="simple">
<li><p><strong>m_pts</strong>: numpy array of mesh points (float), shape (len(m_pts),3)</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="klib.bvectors">
<span class="sig-prename descclassname"><span class="pre">klib.</span></span><span class="sig-name descname"><span class="pre">bvectors</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a_vec</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#klib.bvectors" title="Permalink to this definition"></a></dt>
<dd><p>Define the reciprocal lattice vectors corresponding to the direct lattice 
in real space</p>
<dl class="simple">
<dt><em>args</em>:</dt><dd><ul class="simple">
<li><p><strong>a_vec</strong>: numpy array of 3x3 float, lattice vectors</p></li>
</ul>
</dd>
<dt><em>return</em>:</dt><dd><ul class="simple">
<li><p><strong>b_vec</strong>: numpy array of 3x3 float, reciprocal lattice vectors</p></li>
</ul>
</dd>
</dl>
<p><a href="#id82"><span class="problematic" id="id83">**</span></a><a href="#id84"><span class="problematic" id="id85">*</span></a></p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="klib.kmesh">
<span class="sig-prename descclassname"><span class="pre">klib.</span></span><span class="sig-name descname"><span class="pre">kmesh</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ang</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">kz</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Vo</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">hv</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">W</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#klib.kmesh" title="Permalink to this definition"></a></dt>
<dd><p>Take a mesh of kx and ky with fixed kz and generate a Nx3 array of points
which rotates the mesh about the z axis by <strong>ang</strong>. N is the flattened shape
of <strong>X</strong> and <strong>Y</strong>.</p>
<dl>
<dt><em>args</em>:</dt><dd><ul class="simple">
<li><p><strong>ang</strong>: float, angle of rotation</p></li>
<li><p><strong>X</strong>: numpy array of float, one coordinate of meshgrid</p></li>
<li><p><strong>Y</strong>: numpy array of float, second coordinate of meshgrid</p></li>
<li><p><strong>kz</strong>: float, third dimension of momentum path, fixed</p></li>
</ul>
</dd>
<dt><em>kwargs</em>:</dt><dd><ul class="simple">
<li><p><strong>Vo</strong>: float, parameter necessary for inclusion of inner potential</p></li>
<li><p><strong>hv</strong>: float, photon energy, to be used if <strong>Vo</strong> also included, for evaluating kz</p></li>
<li><p><strong>W</strong>: float, work function</p></li>
</ul>
</dd>
<dt><em>return</em>:</dt><dd><ul class="simple">
<li><p><strong>k_arr</strong>: numpy array of shape Nx3 float, rotated  kpoint array.</p></li>
<li><p><strong>ph</strong>: numpy array of N float, angles of the in-plane momentum</p></li>
</ul>
<p>points, before rotation.</p>
</dd>
</dl>
<p><a href="#id86"><span class="problematic" id="id87">**</span></a><a href="#id88"><span class="problematic" id="id89">*</span></a></p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="klib.kmesh_hv">
<span class="sig-prename descclassname"><span class="pre">klib.</span></span><span class="sig-name descname"><span class="pre">kmesh_hv</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ang</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">hv</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Vo</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#klib.kmesh_hv" title="Permalink to this definition"></a></dt>
<dd><p>Take a mesh of kx and ky with fixed kz and generate a Nx3 array of points
which rotates the mesh about the z axis by <strong>ang</strong>. N is the flattened shape
of <strong>X</strong> and <strong>Y</strong>.</p>
<dl>
<dt><em>args</em>:</dt><dd><ul class="simple">
<li><p><strong>ang</strong>: float, angle of rotation</p></li>
<li><p><strong>X</strong>: numpy array of float, one coordinate of meshgrid</p></li>
<li><p><strong>Y</strong>: numpy array of float, second coordinate of meshgrid</p></li>
<li><p><strong>kz</strong>: float, third dimension of momentum path, fixed</p></li>
</ul>
</dd>
<dt><em>kwargs</em>:</dt><dd><ul class="simple">
<li><p><strong>Vo</strong>: float, parameter necessary for inclusion of inner potential</p></li>
<li><p><strong>hv</strong>: float, photon energy, to be used if <strong>Vo</strong> also included, for evaluating kz</p></li>
<li><p><strong>W</strong>: float, work function</p></li>
</ul>
</dd>
<dt><em>return</em>:</dt><dd><ul class="simple">
<li><p><strong>k_arr</strong>: numpy array of shape Nx3 float, rotated  kpoint array.</p></li>
<li><p><strong>ph</strong>: numpy array of N float, angles of the in-plane momentum</p></li>
</ul>
<p>points, before rotation.</p>
</dd>
</dl>
<p><a href="#id90"><span class="problematic" id="id91">**</span></a><a href="#id92"><span class="problematic" id="id93">*</span></a></p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="klib.kpath">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">klib.</span></span><span class="sig-name descname"><span class="pre">kpath</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">pts</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">grain</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">labels</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#klib.kpath" title="Permalink to this definition"></a></dt>
<dd><p>Momentum object, defining a path in reciprocal space, for use in defining the 
Hamiltonian at different points in the Brillouin zone.
<a href="#id94"><span class="problematic" id="id95">**</span></a><a href="#id96"><span class="problematic" id="id97">*</span></a></p>
<dl class="py method">
<dt class="sig sig-object py" id="klib.kpath.points">
<span class="sig-name descname"><span class="pre">points</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#klib.kpath.points" title="Permalink to this definition"></a></dt>
<dd><p>Use the endpoints of kpath defined in <strong>kpath.pts</strong> to create numpy array
of len(3) float which cover the entire path, based on method by I.S. Elfimov.</p>
<dl class="simple">
<dt><em>return</em>:</dt><dd><ul class="simple">
<li><p><strong>kpath.kpts</strong>: numpy array of float, len(<strong>kpath.pts</strong>)(1+**kpath.grain**) by 3</p></li>
</ul>
</dd>
</dl>
<p><a href="#id98"><span class="problematic" id="id99">**</span></a><a href="#id100"><span class="problematic" id="id101">*</span></a></p>
</dd></dl>

</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="klib.kz_kpt">
<span class="sig-prename descclassname"><span class="pre">klib.</span></span><span class="sig-name descname"><span class="pre">kz_kpt</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">hv</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">kpt</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">W</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">V</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#klib.kz_kpt" title="Permalink to this definition"></a></dt>
<dd><p>Extract the kz associated with a given in-plane momentum, photon energy, 
work function and inner potential</p>
<dl class="simple">
<dt><em>args</em>:</dt><dd><ul class="simple">
<li><p><strong>hv</strong>: float, photon energ in eV</p></li>
<li><p><strong>kpt</strong>: float, in plane momentum, inverse Angstrom</p></li>
<li><p><strong>W</strong>: float, work function in eV</p></li>
<li><p><strong>V</strong>: float, inner potential in eV</p></li>
</ul>
</dd>
<dt><em>return</em>:</dt><dd><ul class="simple">
<li><p><strong>kz</strong>: float, out of plane momentum, inverse Angstrom</p></li>
</ul>
</dd>
</dl>
<p><a href="#id102"><span class="problematic" id="id103">**</span></a><a href="#id104"><span class="problematic" id="id105">*</span></a></p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="klib.mesh_reduce">
<span class="sig-prename descclassname"><span class="pre">klib.</span></span><span class="sig-name descname"><span class="pre">mesh_reduce</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">blatt</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mesh</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">inds</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#klib.mesh_reduce" title="Permalink to this definition"></a></dt>
<dd><p>Determine and select only k-points corresponding to the first Brillouin
zone, by simply classifying points on the basis
of whether or not the closest lattice point is the origin. 
By construction, the origin is index 13 of the blatt. 
If it is not, return error. Option to take only the indices of
the mesh which we want, rather than the actual array points
–this is relevant for tetrahedral interpolation methods</p>
<dl>
<dt><em>args</em>:</dt><dd><ul class="simple">
<li><p><strong>blatt</strong>: numpy array of len(27,3), nearest reciprocal lattice vector points</p></li>
<li><p><strong>mesh</strong>: numpy array of (N,3) float, defining a mesh of k points, before</p></li>
</ul>
<p>being reduced to contain only the Brillouin zone.</p>
</dd>
<dt><em>kwargs</em>: </dt><dd><ul class="simple">
<li><p><strong>inds</strong>: option to pass a list of bool, indicating the</p></li>
</ul>
<p>indices one wants to keep, instead of autogenerating the mesh</p>
</dd>
<dt><em>return</em>:</dt><dd><ul class="simple">
<li><p><strong>bz_pts</strong>: numpy array of (M,3) float, Brillouin zone points</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="klib.plt_pts">
<span class="sig-prename descclassname"><span class="pre">klib.</span></span><span class="sig-name descname"><span class="pre">plt_pts</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">pts</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#klib.plt_pts" title="Permalink to this definition"></a></dt>
<dd><p>Plot an array of points iin 3D</p>
<dl class="simple">
<dt><em>args</em>:</dt><dd><ul class="simple">
<li><p><strong>pts</strong>: numpy array shape N x 3</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="klib.raw_mesh">
<span class="sig-prename descclassname"><span class="pre">klib.</span></span><span class="sig-name descname"><span class="pre">raw_mesh</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">blatt</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">N</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#klib.raw_mesh" title="Permalink to this definition"></a></dt>
<dd><p>Define a mesh of points filling the region of k-space bounded by the set
of reciprocal lattice points generated by <em>bvectors</em>.
These will be further reduced by <em>mesh_reduce</em> to find points which
are within the first-Brillouin zone</p>
<dl>
<dt><em>args</em>:</dt><dd><ul class="simple">
<li><p><strong>blatt</strong>: numpy array of 27x3 float</p></li>
<li><p><strong>N</strong>: int, or iterable of len 3, defines a coarse estimation</p></li>
</ul>
<p>of number of k-points</p>
</dd>
<dt><em>return</em>:</dt><dd><ul class="simple">
<li><p><strong>mesh</strong>: numpy array of mesh points, size set roughly by N</p></li>
</ul>
</dd>
</dl>
<p><a href="#id106"><span class="problematic" id="id107">**</span></a><a href="#id108"><span class="problematic" id="id109">*</span></a></p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="klib.region">
<span class="sig-prename descclassname"><span class="pre">klib.</span></span><span class="sig-name descname"><span class="pre">region</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">num</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#klib.region" title="Permalink to this definition"></a></dt>
<dd><p>Generate a symmetric grid of points in number of lattice vectors.</p>
<dl>
<dt><em>args</em>:</dt><dd><ul class="simple">
<li><p><strong>num</strong>: int, grid will have size 2 num+1 in each direction</p></li>
</ul>
</dd>
<dt><em>return</em>:</dt><dd><ul class="simple">
<li><p>numpy array of size ((2 num+1)**3,3) with centre value of</p></li>
</ul>
<p>first entry of (-num,-num,-num),…,(0,0,0),…,(num,num,num)</p>
</dd>
</dl>
<p><a href="#id110"><span class="problematic" id="id111">**</span></a><a href="#id112"><span class="problematic" id="id113">*</span></a></p>
</dd></dl>

</section>
<section id="module-orbital">
<span id="orbital-objects"></span><h2>Orbital Objects<a class="headerlink" href="#module-orbital" title="Permalink to this heading"></a></h2>
<dl class="py function">
<dt class="sig sig-object py" id="orbital.fact">
<span class="sig-prename descclassname"><span class="pre">orbital.</span></span><span class="sig-name descname"><span class="pre">fact</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#orbital.fact" title="Permalink to this definition"></a></dt>
<dd><p>Recursive factorial function, works for any non-negative integer.</p>
<p><em>args</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p><strong>n</strong>: int, or integer-float</p></li>
</ul>
</div></blockquote>
<p><em>return</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p>int, recursively evaluates the factorial of the initial input value.</p></li>
</ul>
</div></blockquote>
<p><a href="#id114"><span class="problematic" id="id115">**</span></a><a href="#id116"><span class="problematic" id="id117">*</span></a></p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="orbital.orbital">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">orbital.</span></span><span class="sig-name descname"><span class="pre">orbital</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">atom</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">index</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">label</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pos</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Z</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">orient</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">[0.0]</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">spin</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lam</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sigma</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">slab_index</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#orbital.orbital" title="Permalink to this definition"></a></dt>
<dd><p>The <strong>orbital</strong> object carries all essential details of the elements of the
model Hamiltonian basis, for both generation of the tight-binding model, in
addition to the evaluation of expectation values and ARPES intensity.</p>
<dl class="py method">
<dt class="sig sig-object py" id="orbital.orbital.copy">
<span class="sig-name descname"><span class="pre">copy</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#orbital.orbital.copy" title="Permalink to this definition"></a></dt>
<dd><p>Copy by value method for orbital object</p>
<p><em>return</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p><strong>orbital_copy</strong>: duplicate of <strong>orbital</strong> object</p></li>
</ul>
</div></blockquote>
<p><a href="#id118"><span class="problematic" id="id119">**</span></a><a href="#id120"><span class="problematic" id="id121">*</span></a></p>
</dd></dl>

</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="orbital.rot_projection">
<span class="sig-prename descclassname"><span class="pre">orbital.</span></span><span class="sig-name descname"><span class="pre">rot_projection</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">l</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">proj</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rotation</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#orbital.rot_projection" title="Permalink to this definition"></a></dt>
<dd><p>Go through a projection array, and apply the intended transformation to
the Ylm projections in order.
Define Euler angles in the z-y-z convention
THIS WILL BE A COUNTERCLOCKWISE ROTATION ABOUT a vector BY angle gamma 
expressed in radians. Note that we always define spin in the lab-frame, so
spin degrees of freedom are not rotated when we rotate the orbital degrees
of freedom.</p>
<p><em>args</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p><strong>l</strong>: int,orbital angular momentum</p></li>
<li><p><strong>proj</strong>: numpy array of shape Nx4 of float, each element is</p></li>
</ul>
<p>[Re(projection),Im(projection),l,m]</p>
<ul class="simple">
<li><p><strong>rotation</strong>: float, or list, defining rotation of orbital. If float,</p></li>
</ul>
<p>assume rotation about z-axis. If list, first element is a numpy array 
of len 3, indicating rotation vector, and second element is float, angle.</p>
</div></blockquote>
<p><em>return</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p><strong>proj</strong>: numpy array of Mx4 float, as above, but modified, and may</p></li>
</ul>
<p>now include additional, or fewer elements than input <em>proj</em>.</p>
<ul class="simple">
<li><p><strong>Dmat</strong>: numpy array of (2l+1)x(2l+1) complex float indicating the</p></li>
</ul>
<p>Wigner Big-D matrix associated with the rotation of this orbital shell
about the intended axis.</p>
</div></blockquote>
<p><a href="#id122"><span class="problematic" id="id123">**</span></a><a href="#id124"><span class="problematic" id="id125">*</span></a></p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="orbital.slab_basis_copy">
<span class="sig-prename descclassname"><span class="pre">orbital.</span></span><span class="sig-name descname"><span class="pre">slab_basis_copy</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">basis</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">new_posns</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">new_inds</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#orbital.slab_basis_copy" title="Permalink to this definition"></a></dt>
<dd><p>Copy elements of a slab basis into a new list of
orbitals, with modified positions and index ordering.</p>
<p><em>args</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p><strong>basis</strong>: list or orbital objects</p></li>
<li><p><strong>new_posns</strong>: numpy array of len(basis)x3 float, new positions for</p></li>
</ul>
<p>orbital</p>
<ul class="simple">
<li><p><strong>new_inds</strong>: numpy array of len(basis) int, new indices for orbitals</p></li>
</ul>
</div></blockquote>
<p><em>return</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p><strong>new_basis</strong>: list of duplicated orbitals following modification.</p></li>
</ul>
</div></blockquote>
<p><a href="#id126"><span class="problematic" id="id127">**</span></a><a href="#id128"><span class="problematic" id="id129">*</span></a></p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="orbital.sort_basis">
<span class="sig-prename descclassname"><span class="pre">orbital.</span></span><span class="sig-name descname"><span class="pre">sort_basis</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">basis</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">slab</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#orbital.sort_basis" title="Permalink to this definition"></a></dt>
<dd><p>Utility script for organizing an orbital basis that is out of sequence</p>
<p><em>args</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p><strong>basis</strong>: list of orbital objects</p></li>
<li><p><strong>slab</strong>: bool, True or False if this is for sorting a slab</p></li>
</ul>
</div></blockquote>
<p><em>return</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p><strong>orb_basis</strong>: list of sorted orbital objects (by orbital.index value)</p></li>
</ul>
</div></blockquote>
<p><a href="#id130"><span class="problematic" id="id131">**</span></a><a href="#id132"><span class="problematic" id="id133">*</span></a></p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="orbital.spin_double">
<span class="sig-prename descclassname"><span class="pre">orbital.</span></span><span class="sig-name descname"><span class="pre">spin_double</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">basis</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lamdict</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#orbital.spin_double" title="Permalink to this definition"></a></dt>
<dd><p>Double the size of a basis to introduce spin to the problem.
Go through the basis and create an identical copy with opposite spin and 
incremented index such that the orbital basis order puts spin down in the first
N/2 orbitals, and spin up in the second N/2.</p>
<p><em>args</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p><strong>basis</strong>: list of orbital objects</p></li>
<li><p><strong>lamdict</strong>: dictionary of int:float pairs providing the</p></li>
</ul>
<p>spin-orbit coupling strength for the different inequivalent atoms in 
basis.</p>
</div></blockquote>
<p><em>return</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p>doubled basis carrying all required spin information</p></li>
</ul>
</div></blockquote>
<p><a href="#id134"><span class="problematic" id="id135">**</span></a><a href="#id136"><span class="problematic" id="id137">*</span></a></p>
</dd></dl>

</section>
<section id="module-SlaterKoster">
<span id="slater-koster-library"></span><h2>Slater Koster Library<a class="headerlink" href="#module-SlaterKoster" title="Permalink to this heading"></a></h2>
<dl class="py function">
<dt class="sig sig-object py" id="SlaterKoster.SK_cub">
<span class="sig-prename descclassname"><span class="pre">SlaterKoster.</span></span><span class="sig-name descname"><span class="pre">SK_cub</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">Ymats</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">l1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">l2</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#SlaterKoster.SK_cub" title="Permalink to this definition"></a></dt>
<dd><p>In order to generate a set of independent Lambda functions for rapid 
generation of Hamiltonian matrix elements, one must nest the 
definition of the lambda functions within another function. In this way,
we avoid cross-contamination of unrelated functions.
The variables which are fixed for a given lambda function are the 
cubic -to- spherical harmonics (Ymat) transformations, and the 
orbital angular momentum of the relevant basis channels. The output
lambda functions will be functions of the Euler-angles pertaining 
to the hopping path, as well as the potential matrix V, which will be
passed as a numpy array (min(l1,l2)*2+1) long of float.</p>
<p>We follow the method described for rotated d-orbitals in the thesis of
JM Carter from Toronto (HY Kee), where the Slater-Koster hopping
matrix can be defined as the following operation:</p>
<blockquote>
<div><ol class="arabic simple">
<li><p>Transform local orbital basis into spherical harmonics</p></li>
<li><p>Rotate the hopping path along the z-axis</p></li>
<li><p>Product with the diagonal SK-matrix</p></li>
<li><p>Rotate the path backwards</p></li>
<li><p>Rotate back into basis of local orbitals</p></li>
</ol>
<p>6. Output matrix of hopping elements between all orbitals in the shell 
to fill Hamiltonian</p>
</div></blockquote>
<p><em>args</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p><strong>Ymats</strong>: list of numpy arrays corresponding to the relevant</p></li>
</ul>
<p>transformation from cubic to spherical harmonic basis</p>
<ul class="simple">
<li><p><strong>l1</strong>, <strong>l2</strong>: int orbital angular momentum channels relevant</p></li>
</ul>
<p>to a given hopping pair</p>
</div></blockquote>
<p><em>return</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p>lambda function for the SK-matrix between these orbital shells,</p></li>
</ul>
<p>for arbitrary hopping strength and direction.</p>
</div></blockquote>
<p><a href="#id138"><span class="problematic" id="id139">**</span></a><a href="#id140"><span class="problematic" id="id141">*</span></a></p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="SlaterKoster.SK_full">
<span class="sig-prename descclassname"><span class="pre">SlaterKoster.</span></span><span class="sig-name descname"><span class="pre">SK_full</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">basis</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#SlaterKoster.SK_full" title="Permalink to this definition"></a></dt>
<dd><p>Generate a dictionary of lambda functions which take as keys the
atom,orbital for both first and second element. 
Formatting is a1a2n1n2l1l2, same as for SK dictionary entries</p>
<p><em>args</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p><strong>basis</strong>: list of orbital objects composing the TB-basis</p></li>
</ul>
</div></blockquote>
<p><em>return</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p><strong>SK_funcs</strong>: a dictionary of hopping matrix functions</p></li>
</ul>
<p>(lambda functions with args EA,EB,Ey,V as Euler angles and potential (V))
which can be executed for various hopping paths and potential strengths
The keys of the dictionary will be organized similar to the way the SK
parameters are passed, labelled by a1a2n1n2l1l2, which completely
defines a given orbital-orbital coupling</p>
</div></blockquote>
<p><a href="#id142"><span class="problematic" id="id143">**</span></a><a href="#id144"><span class="problematic" id="id145">*</span></a></p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="SlaterKoster.Vmat">
<span class="sig-prename descclassname"><span class="pre">SlaterKoster.</span></span><span class="sig-name descname"><span class="pre">Vmat</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">l1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">l2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">V</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#SlaterKoster.Vmat" title="Permalink to this definition"></a></dt>
<dd><p>For Slater-Koster matrix element generation, a potential matrix is
sandwiched in between the two bond-rotating Dmatrices. It should be 
of the shape 2*l1+1 x 2*l2+1, and have the V_l,l’,D terms along the 
‘diagonal’– a concept that is only well defined for a square matrix.
For mismatched angular momentum channels, this turns into a diagonal 
square matrix of dimension min(2*l1+1,2*l2+1) centred  along the larger
axis. For channels where the orbital angular momentum change involves a
change in parity, the potential should change sign, as per Slater Koster’s
original definition from 1954. This is taken care of automatically in 
the Wigner formalism I use here, no need to have exceptions</p>
<p><em>args</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p><strong>l1</strong>, <strong>l2</strong>: int orbital angular momentum of initial and final states</p></li>
<li><p><strong>V</strong>: numpy array of float – length should be min(<strong>l1</strong> ,**l2**)*2+1</p></li>
</ul>
</div></blockquote>
<p><em>return</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p><strong>Vm</strong>: numpy array of float, shape 2 <strong>l1</strong> +1 x 2 <strong>l2</strong> +1</p></li>
</ul>
</div></blockquote>
<p><a href="#id146"><span class="problematic" id="id147">**</span></a><a href="#id148"><span class="problematic" id="id149">*</span></a></p>
</dd></dl>

</section>
<section id="module-TB_lib">
<span id="tight-binding-library"></span><h2>Tight-Binding Library<a class="headerlink" href="#module-TB_lib" title="Permalink to this heading"></a></h2>
<dl class="py class">
<dt class="sig sig-object py" id="TB_lib.H_me">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">TB_lib.</span></span><span class="sig-name descname"><span class="pre">H_me</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">i</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">j</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">executable</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#TB_lib.H_me" title="Permalink to this definition"></a></dt>
<dd><p>This class contains the relevant executables and data structure pertaining 
to generation of the Hamiltonian matrix elements for a single set of 
coupled basis orbitals. Its attributes include integer values 
<strong>i</strong>, <strong>j</strong> indicating the basis indices, and a list of hopping
vectors/matrix element values for the Hamiltonian.</p>
<p>The method <strong>H2Hk</strong> provides an executable function of momentum to allow
broadcasting of the Hamiltonian over a large array of momenta.
Python’s flexible protocol for equivalency and passing variables by
reference/value require definition of a copy operator which allows one to
produce safely, a copy of the object rather than its coordinates 
in memory alone.
<a href="#id150"><span class="problematic" id="id151">**</span></a><a href="#id152"><span class="problematic" id="id153">*</span></a></p>
<dl class="py method">
<dt class="sig sig-object py" id="TB_lib.H_me.H2Hk">
<span class="sig-name descname"><span class="pre">H2Hk</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#TB_lib.H_me.H2Hk" title="Permalink to this definition"></a></dt>
<dd><p>Transform the list of hopping elements into a Fourier-series expansion 
of the Hamiltonian. This is run during diagonalization for each
matrix element index. If running a low-energy Hamiltonian, executable functions are
simply summed for each basis index i,j, rather than computing a Fourier series. x is
implicitly a numpy array of Nx3: it is essential that the executable conform to this input type.</p>
<p><em>return</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p>lambda function of a numpy array of float of length 3</p></li>
</ul>
</div></blockquote>
<p><a href="#id154"><span class="problematic" id="id155">**</span></a><a href="#id156"><span class="problematic" id="id157">*</span></a></p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="TB_lib.H_me.append_H">
<span class="sig-name descname"><span class="pre">append_H</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">H</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">R0</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">R1</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">R2</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#TB_lib.H_me.append_H" title="Permalink to this definition"></a></dt>
<dd><p>Add a new hopping path to the coupling of the parent orbitals.</p>
<p><em>args</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p><strong>H</strong>: complex float, matrix element strength, or if self.exectype,</p></li>
</ul>
<p>should be an executable</p>
<ul class="simple">
<li><p><strong>R0</strong>, <strong>R1</strong>, <strong>R2</strong>: float connecting vector in cartesian</p></li>
</ul>
<p>coordinate frame–this is the TOTAL vector, not the relevant 
lattice vectors only</p>
</div></blockquote>
<p><em>return</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p>directly modifies the Hamiltonian list for these matrix</p></li>
</ul>
<p>coordinates</p>
</div></blockquote>
<p><a href="#id158"><span class="problematic" id="id159">**</span></a><a href="#id160"><span class="problematic" id="id161">*</span></a></p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="TB_lib.H_me.clean_H">
<span class="sig-name descname"><span class="pre">clean_H</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#TB_lib.H_me.clean_H" title="Permalink to this definition"></a></dt>
<dd><p>Remove all duplicate instances of hopping elements in the matrix 
element list. This function is run automatically during slab generation.</p>
<p>The Hamiltonian list is not itself directly modified.</p>
<p><em>return</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p>list of hopping vectors and associated Hamiltonian matrix</p></li>
</ul>
<p>element strengths</p>
</div></blockquote>
<p><a href="#id162"><span class="problematic" id="id163">**</span></a><a href="#id164"><span class="problematic" id="id165">*</span></a></p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="TB_lib.H_me.copy">
<span class="sig-name descname"><span class="pre">copy</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#TB_lib.H_me.copy" title="Permalink to this definition"></a></dt>
<dd><p>Copy by value of the <strong>H_me</strong> object</p>
<p><em>return</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p><strong>H_copy</strong>: duplicate <strong>H_me</strong> object</p></li>
</ul>
</div></blockquote>
<p><a href="#id166"><span class="problematic" id="id167">**</span></a><a href="#id168"><span class="problematic" id="id169">*</span></a></p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="TB_lib.TB_model">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">TB_lib.</span></span><span class="sig-name descname"><span class="pre">TB_model</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">basis</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">H_args</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Kobj</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#TB_lib.TB_model" title="Permalink to this definition"></a></dt>
<dd><p>The <strong>TB_model</strong> object carries the model basis as a list of <strong>orbital</strong>
objects, as well as the model Hamiltonian, as a list of <strong>H_me</strong>. The orbital
indices paired in each instance of <strong>H_me</strong> are stored in a dictionary under <strong>ijpairs</strong></p>
<dl class="py method">
<dt class="sig sig-object py" id="TB_lib.TB_model.append_H">
<span class="sig-name descname"><span class="pre">append_H</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">new_elements</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#TB_lib.TB_model.append_H" title="Permalink to this definition"></a></dt>
<dd><p>Add new terms to the Hamiltonian by hand. This directly modifies
the list of Hamiltonian matrix element, self.mat_els of the TB object.</p>
<p><em>args</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p><strong>new_elements</strong>: list of Hamiltonian matrix elements, either a single element [i,j,x_ij,y_ij,z_ij,H_ij(x,y,z)]</p></li>
</ul>
<p>or as a list of such lists. Here i, j are the related orbital-indices.</p>
</div></blockquote>
<p><a href="#id170"><span class="problematic" id="id171">**</span></a><a href="#id172"><span class="problematic" id="id173">*</span></a></p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="TB_lib.TB_model.build_ham">
<span class="sig-name descname"><span class="pre">build_ham</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">H_args</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#TB_lib.TB_model.build_ham" title="Permalink to this definition"></a></dt>
<dd><p>Buld the Hamiltonian using functions from <strong>chinook.H_library.py</strong></p>
<p><em>args</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p><strong>H_args</strong>: dictionary, containing all relevant information for</p></li>
</ul>
<p>defining the Hamiltonian list. For details, see <strong>TB_model.__init__</strong>.</p>
</div></blockquote>
<p><em>return</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p>sorted list of matrix element objects. These objects have</p></li>
</ul>
<p>i,j attributes referencing the orbital basis indices, 
and a list of form [R0,R1,R2,Re(H)+1.0jIm(H)]</p>
</div></blockquote>
<p><a href="#id174"><span class="problematic" id="id175">**</span></a><a href="#id176"><span class="problematic" id="id177">*</span></a></p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="TB_lib.TB_model.copy">
<span class="sig-name descname"><span class="pre">copy</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#TB_lib.TB_model.copy" title="Permalink to this definition"></a></dt>
<dd><p>Copy by value of the <strong>TB_model</strong> object</p>
<p><em>return</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p><strong>TB_copy</strong>: duplicate of the <strong>TB_model</strong> object.</p></li>
</ul>
</div></blockquote>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="TB_lib.TB_model.plot_unitcell">
<span class="sig-name descname"><span class="pre">plot_unitcell</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ax</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#TB_lib.TB_model.plot_unitcell" title="Permalink to this definition"></a></dt>
<dd><p>Utility script for visualizing the lattice and orbital basis.
Distinct atoms are drawn in different colours</p>
<p><em>kwargs</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p><strong>ax</strong>: matplotlib Axes, for plotting on existing Axes</p></li>
</ul>
</div></blockquote>
<p><em>return</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p><strong>ax</strong>: matplotlib Axes, for further modifications to plot</p></li>
</ul>
</div></blockquote>
<p><a href="#id178"><span class="problematic" id="id179">**</span></a><a href="#id180"><span class="problematic" id="id181">*</span></a></p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="TB_lib.TB_model.plotting">
<span class="sig-name descname"><span class="pre">plotting</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">win_min</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">win_max</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ax</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#TB_lib.TB_model.plotting" title="Permalink to this definition"></a></dt>
<dd><p>Plotting routine for a tight-binding model evaluated over some path in k.
If the model has not yet been diagonalized, it is done automatically
before proceeding.</p>
<p><em>kwargs</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p><strong>win_min</strong>, <strong>win_max</strong>: float, vertical axis limits for plotting</p></li>
</ul>
<p>in units of eV. If not passed, a reasonable choice is made which 
covers the entire eigenspectrum.</p>
<ul class="simple">
<li><p><strong>ax</strong>: matplotlib Axes, for plotting on existing Axes</p></li>
</ul>
</div></blockquote>
<p><em>return</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p><strong>ax</strong>: matplotlib axes object</p></li>
</ul>
</div></blockquote>
<p><a href="#id182"><span class="problematic" id="id183">**</span></a><a href="#id184"><span class="problematic" id="id185">*</span></a></p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="TB_lib.TB_model.print_basis_summary">
<span class="sig-name descname"><span class="pre">print_basis_summary</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#TB_lib.TB_model.print_basis_summary" title="Permalink to this definition"></a></dt>
<dd><p>Very basic print function for printing a summary
of the orbital basis, including their label, atomic species, position
and spin character.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="TB_lib.TB_model.solve_H">
<span class="sig-name descname"><span class="pre">solve_H</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">Eonly</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#TB_lib.TB_model.solve_H" title="Permalink to this definition"></a></dt>
<dd><p>This function diagonalizes the Hamiltonian over an array of momentum vectors.
It uses the <strong>mat_el</strong> objects to quickly define lambda functions of 
momentum, which are then filled into the array and diagonalized.
According to <a class="reference external" href="https://ntrs.nasa.gov/archive/nasa/casi.ntrs.nasa.gov/20050192421.pdf">https://ntrs.nasa.gov/archive/nasa/casi.ntrs.nasa.gov/20050192421.pdf</a>
SVD algorithms require memory of 2*order*(4*order + 1) ~ 8*order^2. The matrices are
complex float, so this should be 16 bytes per entry: so len(k)*(2048*order**2). If 
the diagonalization is requesting more than 85% of the available memory, then split
up the k-path into sequential diagonalizations.</p>
<p><em>return</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p><strong>self.Eband</strong>: numpy array of float, shape(len(self.Kobj.kpts),len(self.basis)),</p></li>
</ul>
<p>eigenvalues</p>
<ul class="simple">
<li><p><strong>self.Evec</strong>: numpy array of complex float, shape(len(self.Kobj.kpts),len(self.basis),len(self.basis))</p></li>
</ul>
<p>eigenvectors</p>
</div></blockquote>
<p><a href="#id186"><span class="problematic" id="id187">**</span></a><a href="#id188"><span class="problematic" id="id189">*</span></a></p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="TB_lib.TB_model.unpack">
<span class="sig-name descname"><span class="pre">unpack</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#TB_lib.TB_model.unpack" title="Permalink to this definition"></a></dt>
<dd><p>Reduce a Hamiltonian object down to a list of matrix elements. Include the Hermitian conjugate terms</p>
<p><em>return</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p><strong>Hlist</strong>: list of Hamiltonian matrix elements</p></li>
</ul>
</div></blockquote>
<p><a href="#id190"><span class="problematic" id="id191">**</span></a><a href="#id192"><span class="problematic" id="id193">*</span></a></p>
</dd></dl>

</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="TB_lib.atom_coords">
<span class="sig-prename descclassname"><span class="pre">TB_lib.</span></span><span class="sig-name descname"><span class="pre">atom_coords</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">basis</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#TB_lib.atom_coords" title="Permalink to this definition"></a></dt>
<dd><p>Define a dictionary organizing the distinct coordinates of instances of each
atomic species in the basis</p>
<p><em>args</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p><strong>basis</strong>: list of orbital objects</p></li>
</ul>
</div></blockquote>
<p><em>return</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p><a href="#id194"><span class="problematic" id="id195">**</span></a>dictionary with integer keys, numpy array of float values. atom:locations are</p></li>
</ul>
<p>encoded in this way</p>
</div></blockquote>
<p><a href="#id196"><span class="problematic" id="id197">**</span></a><a href="#id198"><span class="problematic" id="id199">*</span></a>.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="TB_lib.cell_edges">
<span class="sig-prename descclassname"><span class="pre">TB_lib.</span></span><span class="sig-name descname"><span class="pre">cell_edges</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">avec</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#TB_lib.cell_edges" title="Permalink to this definition"></a></dt>
<dd><p>Define set of line segments which enclose the unit cell.</p>
<p><em>args</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p><strong>avec</strong>: numpy array of 3x3 float</p></li>
</ul>
</div></blockquote>
<p><em>return</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p><strong>edges</strong>: numpy array of 12 x 6, endpoints of the 12 edges of the unit cell parallelepiped</p></li>
</ul>
</div></blockquote>
<p><a href="#id200"><span class="problematic" id="id201">**</span></a><a href="#id202"><span class="problematic" id="id203">*</span></a></p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="TB_lib.gen_H_obj">
<span class="sig-prename descclassname"><span class="pre">TB_lib.</span></span><span class="sig-name descname"><span class="pre">gen_H_obj</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">htmp</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">executable</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#TB_lib.gen_H_obj" title="Permalink to this definition"></a></dt>
<dd><p>Take a list of Hamiltonian matrix elements in list format:
[i,j,Rij[0],Rij[1],Rij[2],Hij(R)] and generate a list of <strong>H_me</strong>
objects instead. This collects all related matrix elements for a given
orbital-pair for convenient generation of the matrix Hamiltonians over
an input array of momentum</p>
<p><em>args</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p><strong>htmp</strong>: list of numeric-type values (mixed integer[:2], float[2:5], complex-float[-1])</p></li>
</ul>
</div></blockquote>
<p><em>kwargs</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p><strong>executable</strong>: boolean, if True, we don’t have a standard Fourier-type Hamiltonian,</p></li>
</ul>
<p>but perhaps a low-energy expansion. In this case, the htmp elements are</p>
</div></blockquote>
<p><em>return</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p><strong>Hlist</strong>: list of Hamiltonian matrix element, <strong>H_me</strong> objects</p></li>
</ul>
</div></blockquote>
<p><a href="#id204"><span class="problematic" id="id205">**</span></a><a href="#id206"><span class="problematic" id="id207">*</span></a></p>
</dd></dl>

</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="arpes.html" class="btn btn-neutral float-left" title="ARPES Simulation" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="operator.html" class="btn btn-neutral float-right" title="Model Diagnostics" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2019, Ryan P. Day.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>